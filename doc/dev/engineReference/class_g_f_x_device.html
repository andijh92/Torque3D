<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: GFXDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_g_f_x_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GFXDevice Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="gfx_device_8h_source.html">gfxDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GFXDevice:</div>
<div class="dyncontent">
<div class="center"><img src="class_g_f_x_device__inherit__graph.png" border="0" usemap="#_g_f_x_device_inherit__map" alt="Inheritance graph"/></div>
<map name="_g_f_x_device_inherit__map" id="_g_f_x_device_inherit__map">
<area shape="rect" id="node2" href="class_g_f_x_d3_d11_device.html" title="GFXD3D11Device" alt="" coords="5,80,129,107"/>
<area shape="rect" id="node3" href="class_g_f_x_g_l_device.html" title="GFXGLDevice" alt="" coords="153,80,256,107"/>
<area shape="rect" id="node4" href="class_g_f_x_null_device.html" title="GFXNullDevice" alt="" coords="281,80,387,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for GFXDevice:</div>
<div class="dyncontent">
<div class="center"><img src="class_g_f_x_device__coll__graph.png" border="0" usemap="#_g_f_x_device_coll__map" alt="Collaboration graph"/></div>
<map name="_g_f_x_device_coll__map" id="_g_f_x_device_coll__map">
<area shape="rect" id="node22" href="class_g_f_x_texture_object.html" title="GFXTextureObject" alt="" coords="1704,1680,1832,1707"/>
<area shape="rect" id="node32" href="class_g_f_x_draw_util.html" title="GFXDrawUtil" alt="" coords="1721,844,1815,871"/>
<area shape="rect" id="node2" href="class_g_f_x_device_statistics.html" title="GFXDeviceStatistics" alt="" coords="953,996,1093,1023"/>
<area shape="rect" id="node3" href="class_g_f_x_cubemap_handle.html" title="A reference counted handle to a cubemap resource. " alt="" coords="951,29,1094,56"/>
<area shape="rect" id="node4" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXCubemap \&gt;" alt="" coords="448,56,648,83"/>
<area shape="rect" id="node5" href="class_strong_object_ref.html" title="Base class for StrongRefBase strong reference pointers. " alt="" coords="216,255,333,281"/>
<area shape="rect" id="node8" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXTarget \&gt;" alt="" coords="695,156,876,183"/>
<area shape="rect" id="node14" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; T \&gt;" alt="" coords="485,223,611,249"/>
<area shape="rect" id="node35" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXStateBlock \&gt;" alt="" coords="918,80,1127,107"/>
<area shape="rect" id="node40" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXVertexBuffer \&gt;" alt="" coords="677,297,893,324"/>
<area shape="rect" id="node44" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXPrimitive\lBuffer \&gt;" alt="" coords="694,598,877,639"/>
<area shape="rect" id="node50" href="class_strong_ref_ptr.html" title="StrongRefPtr\&lt; GFXTexture\lObject \&gt;" alt="" coords="460,657,636,698"/>
<area shape="rect" id="node6" href="class_strong_ref_base.html" title="StrongRefBase" alt="" coords="5,1543,115,1569"/>
<area shape="rect" id="node36" href="class_g_f_x_shader_const_buffer.html" title="GFXShaderConstBuffer" alt="" coords="945,1413,1100,1440"/>
<area shape="rect" id="node38" href="class_g_f_x_target.html" title="GFXTarget" alt="" coords="981,1577,1064,1604"/>
<area shape="rect" id="node7" href="class_swizzle.html" title="Swizzle\&lt; U8, 3 \&gt;" alt="" coords="961,1097,1084,1124"/>
<area shape="rect" id="node9" href="class_swizzle.html" title="Swizzle\&lt; U8, 4 \&gt;" alt="" coords="961,1211,1084,1237"/>
<area shape="rect" id="node10" href="class_rect_i.html" title="RectI" alt="" coords="759,856,811,883"/>
<area shape="rect" id="node11" href="class_point2_i.html" title="Point2I" alt="" coords="243,775,306,801"/>
<area shape="rect" id="node17" href="struct_g_f_x_video_mode.html" title="GFXVideoMode" alt="" coords="492,723,604,749"/>
<area shape="rect" id="node46" href="class_frustum.html" title="Frustum" alt="" coords="987,523,1058,549"/>
<area shape="rect" id="node12" href="class_platform_timer.html" title="PlatformTimer" alt="" coords="971,1261,1074,1288"/>
<area shape="rect" id="node13" href="class_vector.html" title="Vector\&lt; StrongRefPtr \&gt;" alt="" coords="943,208,1102,235"/>
<area shape="rect" id="node15" href="class_g_f_x_vertex_decl.html" title="GFXVertexDecl" alt="" coords="967,1363,1078,1389"/>
<area shape="rect" id="node16" href="class_vector.html" title="Vector\&lt; GFXVideoMode \&gt;" alt="" coords="935,805,1110,832"/>
<area shape="rect" id="node18" href="class_g_f_x_light_info.html" title="GFXLightInfo" alt="" coords="975,1047,1070,1073"/>
<area shape="rect" id="node19" href="class_point3_f.html" title="Point3F" alt="" coords="515,1064,581,1091"/>
<area shape="rect" id="node20" href="class_linear_color_f.html" title="LinearColorF" alt="" coords="501,1241,595,1268"/>
<area shape="rect" id="node41" href="struct_g_f_x_light_material.html" title="GFXLightMaterial" alt="" coords="962,1312,1083,1339"/>
<area shape="rect" id="node21" href="class_g_f_x_texture_manager.html" title="GFXTextureManager" alt="" coords="2409,1731,2549,1757"/>
<area shape="rect" id="node27" href="class_vector.html" title="Vector\&lt; GFXTextureObject * \&gt;" alt="" coords="2033,1680,2232,1707"/>
<area shape="rect" id="node37" href="class_g_f_x_texture_target.html" title="GFXTextureTarget" alt="" coords="2069,1537,2196,1564"/>
<area shape="rect" id="node23" href="class_g_f_x_resource.html" title="GFXResource" alt="" coords="497,1540,599,1567"/>
<area shape="rect" id="node24" href="class_string.html" title="The String class represents a 0&#45;terminated array of characters. " alt="" coords="520,1817,576,1844"/>
<area shape="rect" id="node25" href="struct_d_d_s_file.html" title="DDSFile" alt="" coords="1199,1725,1270,1752"/>
<area shape="rect" id="node42" href="class_g_f_x_card_profiler.html" title="GFXCardProfiler" alt="" coords="965,1464,1080,1491"/>
<area shape="rect" id="node26" href="class_point3_i.html" title="Point3I" alt="" coords="1391,1795,1453,1821"/>
<area shape="rect" id="node28" href="class_signal.html" title="Signal\&lt; Signature \&gt;" alt="" coords="2064,1731,2201,1757"/>
<area shape="rect" id="node29" href="class_hash_table.html" title="HashTable\&lt; GFXTextureProfile\l *, StrongRefPtr\&lt; GFXTextureObject \&gt; \&gt;" alt="" coords="2005,1782,2260,1823"/>
<area shape="rect" id="node30" href="class_hash_table.html" title="HashTable\&lt; String,\l GFXCubemap * \&gt;" alt="" coords="2066,1847,2199,1889"/>
<area shape="rect" id="node31" href="struct_fov_port.html" title="Advanced fov specification for oculus. " alt="" coords="989,259,1056,285"/>
<area shape="rect" id="node33" href="class_g_f_x_vertex_color.html" title="GFXVertexColor" alt="" coords="1365,844,1479,871"/>
<area shape="rect" id="node34" href="class_font_render_batcher.html" title="FontRenderBatcher" alt="" coords="1355,784,1489,811"/>
<area shape="rect" id="node39" href="class_matrix_f.html" title="MatrixF" alt="" coords="515,371,581,397"/>
<area shape="rect" id="node43" href="class_map.html" title="Map\&lt; String, U32 \&gt;" alt="" coords="480,887,616,913"/>
<area shape="rect" id="node45" href="class_map.html" title="Map\&lt; U32, GFXStateBlockRef \&gt;" alt="" coords="917,755,1128,781"/>
<area shape="rect" id="node47" href="struct_polyhedron_impl.html" title="PolyhedronImpl\&lt; FrustumData \&gt;" alt="" coords="443,421,653,448"/>
<area shape="rect" id="node48" href="class_point2_f.html" title="2D floating&#45;point point. " alt="" coords="515,555,581,581"/>
<area shape="rect" id="node49" href="class_g_f_x_tex_handle.html" title="A reference counted handle to a texture resource. " alt="" coords="969,704,1077,731"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7afb5ceeaa0ddff954175417e43d5141"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDeviceEventType</a> { <br />
&#160;&#160;<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a531f9b88d21ccaa4780797716753d0ce">deCreate</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a51ab624fd7dd399629f1e45d898ecaae">deInit</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a4f3b136d74fbcdfdf1aa8e488e13899e">deDestroy</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a05c1fa3c4a024c0978fc60a85c2999c1">deStartOfFrame</a>, 
<br />
&#160;&#160;<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a83e2494cae3a09d7a22e515fcb449cd6">deEndOfFrame</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a7a077ed6b615369c276ab5bbc6a042a7">dePostFrame</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a2b34f47ff10868d4739a83017c69aff3">deStartOfField</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a2b777ea4e88f4f030ec923d09b7748f4">deLeftStereoFrameRendered</a>, 
<br />
&#160;&#160;<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a485c5070f709ecd02b8e7c4e2f8f2428">deRightStereoFrameRendered</a>, 
<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141a9e62077d15f8445dcac3a0eca6638ddb">deEndOfField</a>
<br />
 }</td></tr>
<tr class="separator:a7afb5ceeaa0ddff954175417e43d5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3225b9116288563b521a711d8e6a44c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3225b9116288563b521a711d8e6a44c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>GFXDeviceRenderStyles</b> { <b>RS_Standard</b> = 0, 
<b>RS_StereoSideBySide</b> = (1&lt;&lt;0), 
<b>RS_StereoSeparate</b> = (1&lt;&lt;1)
 }</td></tr>
<tr class="separator:ad3225b9116288563b521a711d8e6a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a682b30e5aee6a9a7c1386ac7ad1f34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a682b30e5aee6a9a7c1386ac7ad1f34"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>GFXDeviceLimits</b> { <b>NumStereoPorts</b> = 2
 }</td></tr>
<tr class="separator:a7a682b30e5aee6a9a7c1386ac7ad1f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ec26ff908a29191c0052937d8154da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154da"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>GenericShaderType</b> { <br />
&#160;&#160;<b>GSColor</b> = 0, 
<b>GSTexture</b>, 
<b>GSModColorTexture</b>, 
<b>GSAddColorTexture</b>, 
<br />
&#160;&#160;<b>GSTargetRestore</b>, 
<b>GS_COUNT</b>
<br />
 }</td></tr>
<tr class="separator:ad4ec26ff908a29191c0052937d8154da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e60f6690dbd79a0bd11e4af78f9fa6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e60f6690dbd79a0bd11e4af78f9fa6a"></a>
typedef <a class="el" href="class_signal.html">Signal</a>&lt; bool(<a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDeviceEventType</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceEventSignal</b></td></tr>
<tr class="separator:a3e60f6690dbd79a0bd11e4af78f9fa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cbf75c122df59247deff17c794a932f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a0cbf75c122df59247deff17c794a932f">~GFXDevice</a> ()</td></tr>
<tr class="separator:a0cbf75c122df59247deff17c794a932f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e77604d95bf67bf892a6bc6ddf15a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a975e77604d95bf67bf892a6bc6ddf15a">init</a> (const <a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a> &amp;mode, <a class="el" href="class_platform_window.html">PlatformWindow</a> *window=NULL)=0</td></tr>
<tr class="separator:a975e77604d95bf67bf892a6bc6ddf15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6891dec318410ef94116b4ec950342c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#af6891dec318410ef94116b4ec950342c">canCurrentlyRender</a> () const </td></tr>
<tr class="separator:af6891dec318410ef94116b4ec950342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eab068a5df508c89b42926e272ab4fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eab068a5df508c89b42926e272ab4fa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>recentlyReset</b> ()</td></tr>
<tr class="separator:a1eab068a5df508c89b42926e272ab4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bafdaef04ee0db78d8f5c443383363f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bafdaef04ee0db78d8f5c443383363f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>beginReset</b> ()</td></tr>
<tr class="separator:a2bafdaef04ee0db78d8f5c443383363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073437d6c949e49416478ac6bac5b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4073437d6c949e49416478ac6bac5b2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finalizeReset</b> ()</td></tr>
<tr class="separator:a4073437d6c949e49416478ac6bac5b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba845cb4964bf84eb90a8fa97e38adda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba845cb4964bf84eb90a8fa97e38adda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllowRender</b> (bool render)</td></tr>
<tr class="separator:aba845cb4964bf84eb90a8fa97e38adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d2c4cb480f486ecb002f514568353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc5d2c4cb480f486ecb002f514568353"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allowRender</b> () const </td></tr>
<tr class="separator:afc5d2c4cb480f486ecb002f514568353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e3f85ba5431ed2ad27fc5c4312dd0f"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#af0e3f85ba5431ed2ad27fc5c4312dd0f">getCurrentRenderStyle</a> () const </td></tr>
<tr class="memdesc:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current rendering style based on GFXDeviceRenderStyles. <br /></td></tr>
<tr class="separator:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311ad224954a89f24ba649a2825ceec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac311ad224954a89f24ba649a2825ceec"></a>
S32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac311ad224954a89f24ba649a2825ceec">getCurrentStereoTarget</a> () const </td></tr>
<tr class="memdesc:ac311ad224954a89f24ba649a2825ceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current stereo target being rendered to. <br /></td></tr>
<tr class="separator:ac311ad224954a89f24ba649a2825ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16f89a7d220bb185911b325a168a6a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16f89a7d220bb185911b325a168a6a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aa16f89a7d220bb185911b325a168a6a4">setCurrentRenderStyle</a> (U32 style)</td></tr>
<tr class="memdesc:aa16f89a7d220bb185911b325a168a6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current rendering style, based on GFXDeviceRenderStyles. <br /></td></tr>
<tr class="separator:aa16f89a7d220bb185911b325a168a6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdc4198cbd7b593a18ca8be755f8998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fdc4198cbd7b593a18ca8be755f8998"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a0fdc4198cbd7b593a18ca8be755f8998">setCurrentStereoTarget</a> (const F32 targetId)</td></tr>
<tr class="memdesc:a0fdc4198cbd7b593a18ca8be755f8998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current stereo target being rendered to (in case we're doing anything with postfx) <br /></td></tr>
<tr class="separator:a0fdc4198cbd7b593a18ca8be755f8998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a774881e8870ee0dcb8d2116d6aef5a6f"></a>
const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a774881e8870ee0dcb8d2116d6aef5a6f">getStereoEyeOffsets</a> ()</td></tr>
<tr class="memdesc:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current eye offset used during stereo rendering. <br /></td></tr>
<tr class="separator:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4a01652d52c2d9884586959513d733"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b4a01652d52c2d9884586959513d733"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getStereoHeadTransform</b> ()</td></tr>
<tr class="separator:a4b4a01652d52c2d9884586959513d733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7fb9d807efd6e23c3d5316b25ecaba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7fb9d807efd6e23c3d5316b25ecaba"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getStereoEyeTransforms</b> ()</td></tr>
<tr class="separator:abc7fb9d807efd6e23c3d5316b25ecaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3946bcacb1fe7cce0a5ad2a808d683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3946bcacb1fe7cce0a5ad2a808d683"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getInverseStereoEyeTransforms</b> ()</td></tr>
<tr class="separator:afe3946bcacb1fe7cce0a5ad2a808d683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c6586d8a6a1403b3d0a65a55e236d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a78c6586d8a6a1403b3d0a65a55e236d8">setStereoHeadTransform</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;mat)</td></tr>
<tr class="memdesc:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the head matrix for stereo rendering. <br /></td></tr>
<tr class="separator:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dbbef99f73865489e232014932812"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a423dbbef99f73865489e232014932812"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a423dbbef99f73865489e232014932812">setStereoEyeOffsets</a> (<a class="el" href="class_point3_f.html">Point3F</a> *offsets)</td></tr>
<tr class="memdesc:a423dbbef99f73865489e232014932812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current eye offset used during stereo rendering. <br /></td></tr>
<tr class="separator:a423dbbef99f73865489e232014932812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4715b4049f9d80a5eff9c837835f4209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4715b4049f9d80a5eff9c837835f4209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStereoEyeTransforms</b> (<a class="el" href="class_matrix_f.html">MatrixF</a> *transforms)</td></tr>
<tr class="separator:a4715b4049f9d80a5eff9c837835f4209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b056605f616c21dd2cad10917031e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19b056605f616c21dd2cad10917031e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a19b056605f616c21dd2cad10917031e9">setStereoFovPort</a> (const <a class="el" href="struct_fov_port.html">FovPort</a> *ports)</td></tr>
<tr class="memdesc:a19b056605f616c21dd2cad10917031e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current eye offset used during stereo rendering. Assumes NumStereoPorts are available. <br /></td></tr>
<tr class="separator:a19b056605f616c21dd2cad10917031e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf529e9c3301c71809b7cb41b052dd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cf529e9c3301c71809b7cb41b052dd2"></a>
const <a class="el" href="struct_fov_port.html">FovPort</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9cf529e9c3301c71809b7cb41b052dd2">getStereoFovPort</a> ()</td></tr>
<tr class="memdesc:a9cf529e9c3301c71809b7cb41b052dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current eye offset used during stereo rendering. <br /></td></tr>
<tr class="separator:a9cf529e9c3301c71809b7cb41b052dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccac78b964e3c85cf054082e6e2b885"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccac78b964e3c85cf054082e6e2b885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a6ccac78b964e3c85cf054082e6e2b885">setSteroViewports</a> (const <a class="el" href="class_rect_i.html">RectI</a> *ports)</td></tr>
<tr class="memdesc:a6ccac78b964e3c85cf054082e6e2b885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stereo viewports. <br /></td></tr>
<tr class="separator:a6ccac78b964e3c85cf054082e6e2b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf86e581a626ae46b2e436c44d647de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf86e581a626ae46b2e436c44d647de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a2cf86e581a626ae46b2e436c44d647de">setStereoTargets</a> (<a class="el" href="class_g_f_x_texture_target.html">GFXTextureTarget</a> **targets)</td></tr>
<tr class="memdesc:a2cf86e581a626ae46b2e436c44d647de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stereo render targets. <br /></td></tr>
<tr class="separator:a2cf86e581a626ae46b2e436c44d647de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02192f0d2b16306a5660e4f7c7d7d7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02192f0d2b16306a5660e4f7c7d7d7d6"></a>
<a class="el" href="class_rect_i.html">RectI</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getStereoViewports</b> ()</td></tr>
<tr class="separator:a02192f0d2b16306a5660e4f7c7d7d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828dc9eb9b8cd4eec6daf8090cc4639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac828dc9eb9b8cd4eec6daf8090cc4639">activateStereoTarget</a> (S32 eyeId)</td></tr>
<tr class="separator:ac828dc9eb9b8cd4eec6daf8090cc4639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f1cf6b3214e266d5fa63cc2b97539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5f1cf6b3214e266d5fa63cc2b97539"></a>
<a class="el" href="class_g_f_x_card_profiler.html">GFXCardProfiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCardProfiler</b> () const </td></tr>
<tr class="separator:a3c5f1cf6b3214e266d5fa63cc2b97539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b07c823a86a49eb070bfcf24ee98cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b07c823a86a49eb070bfcf24ee98cc"></a>
virtual GFXAdapterType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a16b07c823a86a49eb070bfcf24ee98cc">getAdapterType</a> ()=0</td></tr>
<tr class="memdesc:a16b07c823a86a49eb070bfcf24ee98cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns active graphics adapter type. <br /></td></tr>
<tr class="separator:a16b07c823a86a49eb070bfcf24ee98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bf19f579f4342e471b8d951963298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0bf19f579f4342e471b8d951963298"></a>
virtual const <a class="el" href="struct_g_f_x_adapter.html">GFXAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9c0bf19f579f4342e471b8d951963298">getAdapter</a> ()</td></tr>
<tr class="memdesc:a9c0bf19f579f4342e471b8d951963298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Adapter that was used to create this device. <br /></td></tr>
<tr class="separator:a9c0bf19f579f4342e471b8d951963298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fdbb77883a6fcca9ae65fabae68c2ea"></a>
const <a class="el" href="class_swizzle.html">Swizzle</a>&lt; U8, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a6fdbb77883a6fcca9ae65fabae68c2ea">getDeviceSwizzle32</a> () const </td></tr>
<tr class="memdesc:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_swizzle.html">Swizzle</a> to convert 32bpp bitmaps from RGBA to the native device format. <br /></td></tr>
<tr class="separator:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a936a62a3dd886a1ec053b8cc42bf0d12"></a>
const <a class="el" href="class_swizzle.html">Swizzle</a>&lt; U8, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24</a> () const </td></tr>
<tr class="memdesc:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_swizzle.html">Swizzle</a> to convert 24bpp bitmaps from RGB to the native device format. <br /></td></tr>
<tr class="separator:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e618ec59bd3af2c80feebc76bcf9c4f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_fence.html">GFXFence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a4e618ec59bd3af2c80feebc76bcf9c4f">createFence</a> ()=0</td></tr>
<tr class="separator:a4e618ec59bd3af2c80feebc76bcf9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a363725d0a5402fc0b4889749371ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_occlusion_query.html">GFXOcclusionQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery</a> ()</td></tr>
<tr class="separator:ae0a363725d0a5402fc0b4889749371ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb03342ccba47508daf1c98f08f08af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point2_f.html">Point2F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#accb03342ccba47508daf1c98f08f08af">getWorldToScreenScale</a> () const </td></tr>
<tr class="separator:accb03342ccba47508daf1c98f08f08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a4b0ac3141200a820922b58da5107"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ab07a4b0ac3141200a820922b58da5107">setupGenericShaders</a> (GenericShaderType type=GSColor)</td></tr>
<tr class="separator:ab07a4b0ac3141200a820922b58da5107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a5ad5aff2a286e12b8396e024d8e33"></a>
virtual F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad1a5ad5aff2a286e12b8396e024d8e33">getFillConventionOffset</a> () const  =0</td></tr>
<tr class="memdesc:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fill convention for this device. <br /></td></tr>
<tr class="separator:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d2bcf9c0c38f90bfbd3c01af125a96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d2bcf9c0c38f90bfbd3c01af125a96"></a>
virtual U32&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxDynamicVerts</b> ()=0</td></tr>
<tr class="separator:a53d2bcf9c0c38f90bfbd3c01af125a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab91faf2269e73d98e8c3b9a79c0af5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab91faf2269e73d98e8c3b9a79c0af5a"></a>
virtual U32&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxDynamicIndices</b> ()=0</td></tr>
<tr class="separator:aab91faf2269e73d98e8c3b9a79c0af5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38d3e939c2395566a6dddd70f2e42d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad38d3e939c2395566a6dddd70f2e42d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>doParanoidStateCheck</b> ()</td></tr>
<tr class="separator:ad38d3e939c2395566a6dddd70f2e42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26452bf9ee5dfec2a927c9a2fd8ede7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26452bf9ee5dfec2a927c9a2fd8ede7"></a>
<a class="el" href="class_g_f_x_draw_util.html">GFXDrawUtil</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae26452bf9ee5dfec2a927c9a2fd8ede7">getDrawUtil</a> ()</td></tr>
<tr class="memdesc:ae26452bf9ee5dfec2a927c9a2fd8ede7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this device's drawing utility class. <br /></td></tr>
<tr class="separator:ae26452bf9ee5dfec2a927c9a2fd8ede7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d70d5cb8bdbb63f3d56c3295fa794f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a8d70d5cb8bdbb63f3d56c3295fa794f7">dumpStates</a> (const char *fileName) const </td></tr>
<tr class="separator:a8d70d5cb8bdbb63f3d56c3295fa794f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug Methods</div></td></tr>
<tr class="memitem:a36fbc0a8a18c83bee5aa3c4984905e94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36fbc0a8a18c83bee5aa3c4984905e94"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>enterDebugEvent</b> (<a class="el" href="class_color_i.html">ColorI</a> color, const char *name)=0</td></tr>
<tr class="separator:a36fbc0a8a18c83bee5aa3c4984905e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c1dadf2039bf1441d26e8342388a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2c1dadf2039bf1441d26e8342388a5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>leaveDebugEvent</b> ()=0</td></tr>
<tr class="separator:aca2c1dadf2039bf1441d26e8342388a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc83e217ed0133cb9b9267683b03475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc83e217ed0133cb9b9267683b03475"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setDebugMarker</b> (<a class="el" href="class_color_i.html">ColorI</a> color, const char *name)=0</td></tr>
<tr class="separator:a3bc83e217ed0133cb9b9267683b03475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Video Mode Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Enumerates the supported video modes of the device </p>
</div></td></tr>
<tr class="memitem:a205d1b053188b4fb95aea848e3302dc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205d1b053188b4fb95aea848e3302dc5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>enumerateVideoModes</b> ()=0</td></tr>
<tr class="separator:a205d1b053188b4fb95aea848e3302dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcfdaaf73855c6ba53e472eb1d700b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a> &gt; *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a1bcfdaaf73855c6ba53e472eb1d700b3">getVideoModeList</a> () const </td></tr>
<tr class="separator:a1bcfdaaf73855c6ba53e472eb1d700b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584fb79c33de9df4ebdbe8531b17b865"><td class="memItemLeft" align="right" valign="top">virtual GFXFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a584fb79c33de9df4ebdbe8531b17b865">selectSupportedFormat</a> (<a class="el" href="class_g_f_x_texture_profile.html">GFXTextureProfile</a> *profile, const <a class="el" href="class_vector.html">Vector</a>&lt; GFXFormat &gt; &amp;formats, bool texture, bool mustblend, bool mustfilter)=0</td></tr>
<tr class="separator:a584fb79c33de9df4ebdbe8531b17b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Render Target functions</div></td></tr>
<tr class="memitem:ad993db38e2a55452481cca1522a28d38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_texture_target.html">GFXTextureTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad993db38e2a55452481cca1522a28d38">allocRenderToTextureTarget</a> ()=0</td></tr>
<tr class="separator:ad993db38e2a55452481cca1522a28d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4da4638b532dd340bab16f22e00bb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c4da4638b532dd340bab16f22e00bb1"></a>
virtual <a class="el" href="class_g_f_x_window_target.html">GFXWindowTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a3c4da4638b532dd340bab16f22e00bb1">allocWindowTarget</a> (<a class="el" href="class_platform_window.html">PlatformWindow</a> *window)=0</td></tr>
<tr class="memdesc:a3c4da4638b532dd340bab16f22e00bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a target for a given window. <br /></td></tr>
<tr class="separator:a3c4da4638b532dd340bab16f22e00bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e7907ef7d8a23c57f74ccdc0ac4339"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac6e7907ef7d8a23c57f74ccdc0ac4339">pushActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the current render target to restore later. <br /></td></tr>
<tr class="separator:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0397a347c5f3211860979b0a107e3203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0397a347c5f3211860979b0a107e3203"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a0397a347c5f3211860979b0a107e3203">popActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:a0397a347c5f3211860979b0a107e3203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previous render target. <br /></td></tr>
<tr class="separator:a0397a347c5f3211860979b0a107e3203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7270b308ee6cb8dc7d44faccf67cad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7270b308ee6cb8dc7d44faccf67cad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aec7270b308ee6cb8dc7d44faccf67cad">setActiveRenderTarget</a> (<a class="el" href="class_g_f_x_target.html">GFXTarget</a> *target, bool updateViewport=true)</td></tr>
<tr class="memdesc:aec7270b308ee6cb8dc7d44faccf67cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new active render target. <br /></td></tr>
<tr class="separator:aec7270b308ee6cb8dc7d44faccf67cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56964c4831dd3a1f6c1819be6bf7ad9"></a>
<a class="el" href="class_g_f_x_target.html">GFXTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current active render target. <br /></td></tr>
<tr class="separator:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shader functions</div></td></tr>
<tr class="memitem:a3a72024c21bc9f43c11e90e15fe86343"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a72024c21bc9f43c11e90e15fe86343"></a>
virtual F32&#160;</td><td class="memItemRight" valign="bottom"><b>getPixelShaderVersion</b> () const  =0</td></tr>
<tr class="separator:a3a72024c21bc9f43c11e90e15fe86343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02b6f74b519b52757c71f744df7f092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa02b6f74b519b52757c71f744df7f092"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setPixelShaderVersion</b> (F32 version)=0</td></tr>
<tr class="separator:aa02b6f74b519b52757c71f744df7f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54209fc4a4c1bef924d7bfa13d615ca3"></a>
virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a54209fc4a4c1bef924d7bfa13d615ca3">getNumSamplers</a> () const  =0</td></tr>
<tr class="memdesc:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of texture samplers that can be used in a shader rendering pass. <br /></td></tr>
<tr class="separator:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1305c77b9071c68c7e72f267f40946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f1305c77b9071c68c7e72f267f40946"></a>
virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a4f1305c77b9071c68c7e72f267f40946">getNumRenderTargets</a> () const  =0</td></tr>
<tr class="memdesc:a4f1305c77b9071c68c7e72f267f40946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simultaneous render targets supported by the device. <br /></td></tr>
<tr class="separator:a4f1305c77b9071c68c7e72f267f40946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e3d37b0ca3d5ff1fe20d8778c27412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e3d37b0ca3d5ff1fe20d8778c27412"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setShader</b> (<a class="el" href="class_g_f_x_shader.html">GFXShader</a> *shader, bool force=false)</td></tr>
<tr class="separator:ae0e3d37b0ca3d5ff1fe20d8778c27412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a2ba572ca80f0023c0ccdbce2ba8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a175a2ba572ca80f0023c0ccdbce2ba8e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>disableShaders</b> (bool force=false)</td></tr>
<tr class="separator:a175a2ba572ca80f0023c0ccdbce2ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbeeb26e49406db965dd8da7c3cf778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fbeeb26e49406db965dd8da7c3cf778"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a1fbeeb26e49406db965dd8da7c3cf778">setShaderConstBuffer</a> (<a class="el" href="class_g_f_x_shader_const_buffer.html">GFXShaderConstBuffer</a> *buffer)</td></tr>
<tr class="memdesc:a1fbeeb26e49406db965dd8da7c3cf778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer! (Actual set happens on the next draw call, just like textures, state blocks, etc) <br /></td></tr>
<tr class="separator:a1fbeeb26e49406db965dd8da7c3cf778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1782edd3fa1bfb70fe6e2477139a450"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_shader.html">GFXShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac1782edd3fa1bfb70fe6e2477139a450">createShader</a> ()=0</td></tr>
<tr class="separator:ac1782edd3fa1bfb70fe6e2477139a450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Settings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>NONE of these should be overridden by API implementations because of the state caching stuff. </p>
</div></td></tr>
<tr class="memitem:a96b201f929f4c7c5bbcd723d32f132a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b201f929f4c7c5bbcd723d32f132a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLight</b> (U32 stage, <a class="el" href="class_g_f_x_light_info.html">GFXLightInfo</a> *light)</td></tr>
<tr class="separator:a96b201f929f4c7c5bbcd723d32f132a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287e5cd40c9b2944b9e6d51b1550fc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9287e5cd40c9b2944b9e6d51b1550fc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightMaterial</b> (const <a class="el" href="struct_g_f_x_light_material.html">GFXLightMaterial</a> &amp;mat)</td></tr>
<tr class="separator:a9287e5cd40c9b2944b9e6d51b1550fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fbe071e88c846217db2a430630bd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748fbe071e88c846217db2a430630bd9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setGlobalAmbientColor</b> (const <a class="el" href="class_linear_color_f.html">LinearColorF</a> &amp;color)</td></tr>
<tr class="separator:a748fbe071e88c846217db2a430630bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture State Settings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>NONE of these should be overridden by API implementations because of the state caching stuff. </p>
</div></td></tr>
<tr class="memitem:a25fd4143c2a3a02865b4d39b5a8b691d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25fd4143c2a3a02865b4d39b5a8b691d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTexture</b> (U32 stage, <a class="el" href="class_g_f_x_texture_object.html">GFXTextureObject</a> *texture)</td></tr>
<tr class="separator:a25fd4143c2a3a02865b4d39b5a8b691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb2a85886f21b71656409abd3a8ffbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cb2a85886f21b71656409abd3a8ffbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCubeTexture</b> (U32 stage, <a class="el" href="class_g_f_x_cubemap.html">GFXCubemap</a> *cubemap)</td></tr>
<tr class="separator:a0cb2a85886f21b71656409abd3a8ffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba3582c1126a073cee6627539e7020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ba3582c1126a073cee6627539e7020"></a>
<a class="el" href="class_g_f_x_texture_object.html">GFXTextureObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentTexture</b> (U32 stage)</td></tr>
<tr class="separator:a63ba3582c1126a073cee6627539e7020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Block Interface</div></td></tr>
<tr class="memitem:a9be8e70679d4df73d44b2315d8f77d5c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9be8e70679d4df73d44b2315d8f77d5c">createStateBlock</a> (const <a class="el" href="struct_g_f_x_state_block_desc.html">GFXStateBlockDesc</a> &amp;desc)</td></tr>
<tr class="separator:a9be8e70679d4df73d44b2315d8f77d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7768a3af13a94de22e45bdfc16e15dbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7768a3af13a94de22e45bdfc16e15dbd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a7768a3af13a94de22e45bdfc16e15dbd">setStateBlock</a> (<a class="el" href="class_g_f_x_state_block.html">GFXStateBlock</a> *block)</td></tr>
<tr class="memdesc:a7768a3af13a94de22e45bdfc16e15dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current stateblock (actually activated in ::updateStates) <br /></td></tr>
<tr class="separator:a7768a3af13a94de22e45bdfc16e15dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a86920cddd637f7bb2e33c16de9cd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a86920cddd637f7bb2e33c16de9cd4"></a>
<a class="el" href="class_g_f_x_state_block.html">GFXStateBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getStateBlock</b> ()</td></tr>
<tr class="separator:ae2a86920cddd637f7bb2e33c16de9cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58ebf2102c1fdb1ab5a3272cc6b8575"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aa58ebf2102c1fdb1ab5a3272cc6b8575">setStateBlockByDesc</a> (const <a class="el" href="struct_g_f_x_state_block_desc.html">GFXStateBlockDesc</a> &amp;desc)</td></tr>
<tr class="separator:aa58ebf2102c1fdb1ab5a3272cc6b8575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix interface</div></td></tr>
<tr class="memitem:ae8964ddd37f4be2361cb346b1e132fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;newWorld)</td></tr>
<tr class="separator:ae8964ddd37f4be2361cb346b1e132fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f27a6b462aa7d9b393ae9b528b00e00"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix</a> () const </td></tr>
<tr class="memdesc:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the matrix on the top of the world matrix stack. <br /></td></tr>
<tr class="separator:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b012283186cb887f4bda73b35fad1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix</a> ()</td></tr>
<tr class="separator:ab1b012283186cb887f4bda73b35fad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a2651759c03f2c039fb775961a09c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b3a2651759c03f2c039fb775961a09c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix</a> ()</td></tr>
<tr class="memdesc:a2b3a2651759c03f2c039fb775961a09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the world matrix stack. <br /></td></tr>
<tr class="separator:a2b3a2651759c03f2c039fb775961a09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e383532f8a7db58b99310ab9a9dd2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;newProj)</td></tr>
<tr class="separator:a1e383532f8a7db58b99310ab9a9dd2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8491b8ad4fbe1c529c13886d48ac419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8491b8ad4fbe1c529c13886d48ac419"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad8491b8ad4fbe1c529c13886d48ac419">getProjectionMatrix</a> () const </td></tr>
<tr class="memdesc:ad8491b8ad4fbe1c529c13886d48ac419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the projection matrix. <br /></td></tr>
<tr class="separator:ad8491b8ad4fbe1c529c13886d48ac419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f00a3b21b5ec5d071fd9a409891a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;newView)</td></tr>
<tr class="separator:a612f00a3b21b5ec5d071fd9a409891a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb96149889ba6465948deec8f1646bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bb96149889ba6465948deec8f1646bd"></a>
const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix</a> () const </td></tr>
<tr class="memdesc:a8bb96149889ba6465948deec8f1646bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the view matrix. <br /></td></tr>
<tr class="separator:a8bb96149889ba6465948deec8f1646bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd2cb45f6c371e03b065b02b4a648b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;mat)</td></tr>
<tr class="separator:aa2dd2cb45f6c371e03b065b02b4a648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae41b6b0d8ce7f82a67f82f5045837efc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix</a> (const U32 stage, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;texMat)</td></tr>
<tr class="memdesc:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set texture matrix for a sampler. <br /></td></tr>
<tr class="separator:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff095cc01fc3319d229996a16791b919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff095cc01fc3319d229996a16791b919"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aff095cc01fc3319d229996a16791b919">setViewport</a> (const <a class="el" href="class_rect_i.html">RectI</a> &amp;rect)</td></tr>
<tr class="memdesc:aff095cc01fc3319d229996a16791b919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an area of the target to render to. <br /></td></tr>
<tr class="separator:aff095cc01fc3319d229996a16791b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438a05795dc86bad94a7a1e9dffdd1e4"></a>
const <a class="el" href="class_rect_i.html">RectI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport</a> () const </td></tr>
<tr class="memdesc:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current area of the target we will render to. <br /></td></tr>
<tr class="separator:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6babdb0e6e95db55663e506a55d6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca6babdb0e6e95db55663e506a55d6a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setClipRect</b> (const <a class="el" href="class_rect_i.html">RectI</a> &amp;rect)=0</td></tr>
<tr class="separator:afca6babdb0e6e95db55663e506a55d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b3fbc6868e209a0ecec65c68b856b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80b3fbc6868e209a0ecec65c68b856b9"></a>
virtual const <a class="el" href="class_rect_i.html">RectI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getClipRect</b> () const  =0</td></tr>
<tr class="separator:a80b3fbc6868e209a0ecec65c68b856b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90bd19adb63e362d02fc2fcc6d67bb5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad90bd19adb63e362d02fc2fcc6d67bb5">setFrustum</a> (F32 left, F32 right, F32 bottom, F32 top, F32 nearPlane, F32 farPlane, bool bRotate=true)</td></tr>
<tr class="separator:ad90bd19adb63e362d02fc2fcc6d67bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22bed6a34a1e7034c6db42729655e0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae22bed6a34a1e7034c6db42729655e0b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFrustum</b> (const <a class="el" href="class_frustum.html">Frustum</a> &amp;frust, bool bRotate=true)</td></tr>
<tr class="separator:ae22bed6a34a1e7034c6db42729655e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6682a478e5ec9ab1bdced5f6c3674d85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a6682a478e5ec9ab1bdced5f6c3674d85">getFrustum</a> (F32 *left, F32 *right, F32 *bottom, F32 *top, F32 *nearPlane, F32 *farPlane, bool *isOrtho) const </td></tr>
<tr class="memdesc:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection frustum. <br /></td></tr>
<tr class="separator:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20267e71efa9d22e5effe9632a7fd736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20267e71efa9d22e5effe9632a7fd736"></a>
const <a class="el" href="class_frustum.html">Frustum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a20267e71efa9d22e5effe9632a7fd736">getFrustum</a> () const </td></tr>
<tr class="memdesc:a20267e71efa9d22e5effe9632a7fd736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection frustum. <br /></td></tr>
<tr class="separator:a20267e71efa9d22e5effe9632a7fd736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919f3f4e11d349b3919f851a40c7f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac919f3f4e11d349b3919f851a40c7f4d">setOrtho</a> (F32 left, F32 right, F32 bottom, F32 top, F32 nearPlane, F32 farPlane, bool doRotate=false)</td></tr>
<tr class="separator:ac919f3f4e11d349b3919f851a40c7f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb441df9be45731b1bd4ee66d83f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05cb441df9be45731b1bd4ee66d83f81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a05cb441df9be45731b1bd4ee66d83f81">isFrustumOrtho</a> () const </td></tr>
<tr class="memdesc:a05cb441df9be45731b1bd4ee66d83f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the current frustum uses orthographic projection rather than perspective projection. <br /></td></tr>
<tr class="separator:a05cb441df9be45731b1bd4ee66d83f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a120a932b7c47a2694c1efbeaa133711b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120a932b7c47a2694c1efbeaa133711b"></a>
static <a class="el" href="class_signal.html">DeviceEventSignal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDeviceEventSignal</b> ()</td></tr>
<tr class="separator:a120a932b7c47a2694c1efbeaa133711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69076c283dcd2631fd01f9ac8e9b750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69076c283dcd2631fd01f9ac8e9b750"></a>
static <a class="el" href="class_g_f_x_device.html">GFXDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> ()</td></tr>
<tr class="separator:af69076c283dcd2631fd01f9ac8e9b750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52be9a038569aa47f4c0e02ccfe639c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52be9a038569aa47f4c0e02ccfe639c7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>initConsole</b> ()</td></tr>
<tr class="separator:a52be9a038569aa47f4c0e02ccfe639c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae698c74b14b0491329477387bcae6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae698c74b14b0491329477387bcae6d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> ()</td></tr>
<tr class="separator:afae698c74b14b0491329477387bcae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca769dd2c67d56ae1b19f4f9212d47f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ca769dd2c67d56ae1b19f4f9212d47f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>devicePresent</b> ()</td></tr>
<tr class="separator:a1ca769dd2c67d56ae1b19f4f9212d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad39a1f6ba3cf89fdbfe9f1b5c2a4401b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad39a1f6ba3cf89fdbfe9f1b5c2a4401b">preDestroy</a> ()</td></tr>
<tr class="separator:ad39a1f6ba3cf89fdbfe9f1b5c2a4401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dfb10ddda5a685595ebdbe6c939eba4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter</a> (const <a class="el" href="struct_g_f_x_adapter.html">GFXAdapter</a> &amp;adapter)</td></tr>
<tr class="memdesc:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the adapter that this device is using. For use by <a class="el" href="class_g_f_x_init.html#a504022fc2d9c0ca20569f8126238a332">GFXInit::createDevice</a> only. <br /></td></tr>
<tr class="separator:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4f45f8166b8b07a4ec906f2cc9afe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef4f45f8166b8b07a4ec906f2cc9afe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#afef4f45f8166b8b07a4ec906f2cc9afe">deviceInited</a> ()</td></tr>
<tr class="memdesc:afef4f45f8166b8b07a4ec906f2cc9afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify <a class="el" href="class_g_f_x_device.html">GFXDevice</a> that we are initialized. <br /></td></tr>
<tr class="separator:afef4f45f8166b8b07a4ec906f2cc9afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092d8361c678b9aeb930213be271f55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac092d8361c678b9aeb930213be271f55"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac092d8361c678b9aeb930213be271f55">setShaderConstBufferInternal</a> (<a class="el" href="class_g_f_x_shader_const_buffer.html">GFXShaderConstBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:ac092d8361c678b9aeb930213be271f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by base <a class="el" href="class_g_f_x_device.html">GFXDevice</a> to actually set a const buffer. <br /></td></tr>
<tr class="separator:ac092d8361c678b9aeb930213be271f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e6777ac71f79797458ce28b1b6fffa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e6777ac71f79797458ce28b1b6fffa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setTextureInternal</b> (U32 textureUnit, const <a class="el" href="class_g_f_x_texture_object.html">GFXTextureObject</a> *texture)=0</td></tr>
<tr class="separator:a58e6777ac71f79797458ce28b1b6fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf4953b9d3aabc2797b923d0395e9f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf4953b9d3aabc2797b923d0395e9f8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightInternal</b> (U32 lightStage, const <a class="el" href="class_g_f_x_light_info.html">GFXLightInfo</a> light, bool lightEnable)=0</td></tr>
<tr class="separator:a7bf4953b9d3aabc2797b923d0395e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a36abd450bddf0f187f0ce1fcc87f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a36abd450bddf0f187f0ce1fcc87f2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setGlobalAmbientInternal</b> (<a class="el" href="class_linear_color_f.html">LinearColorF</a> color)=0</td></tr>
<tr class="separator:ae2a36abd450bddf0f187f0ce1fcc87f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b380dd09d07a7b5c048c4ff9a28b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c8b380dd09d07a7b5c048c4ff9a28b4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightMaterialInternal</b> (const <a class="el" href="struct_g_f_x_light_material.html">GFXLightMaterial</a> mat)=0</td></tr>
<tr class="separator:a7c8b380dd09d07a7b5c048c4ff9a28b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf399c09070ac19e3f3c45bc9f8cfea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf399c09070ac19e3f3c45bc9f8cfea4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>beginSceneInternal</b> ()=0</td></tr>
<tr class="separator:acf399c09070ac19e3f3c45bc9f8cfea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b636000d55dc81bded299d5fe47b65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9b636000d55dc81bded299d5fe47b65"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>endSceneInternal</b> ()=0</td></tr>
<tr class="separator:ab9b636000d55dc81bded299d5fe47b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69948ce316fd8bd1979d6477100c341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae69948ce316fd8bd1979d6477100c341">setMatrix</a> (GFXMatrixType mtype, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;mat)=0</td></tr>
<tr class="separator:ae69948ce316fd8bd1979d6477100c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a7f704e1cc95a7340365561a92e9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a051a7f704e1cc95a7340365561a92e9a">_updateRenderTargets</a> ()=0</td></tr>
<tr class="separator:a051a7f704e1cc95a7340365561a92e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stateblock functions</div></td></tr>
<tr class="memitem:a984f77b6e3ae50d8149d7e09b90035d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a984f77b6e3ae50d8149d7e09b90035d0"></a>
virtual <a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a984f77b6e3ae50d8149d7e09b90035d0">createStateBlockInternal</a> (const <a class="el" href="struct_g_f_x_state_block_desc.html">GFXStateBlockDesc</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a984f77b6e3ae50d8149d7e09b90035d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="class_g_f_x_device.html">GFXDevice</a> to create a device specific stateblock. <br /></td></tr>
<tr class="separator:a984f77b6e3ae50d8149d7e09b90035d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ceb04e1a40cab3bfd42d0f53721e41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad2ceb04e1a40cab3bfd42d0f53721e41">setStateBlockInternal</a> (<a class="el" href="class_g_f_x_state_block.html">GFXStateBlock</a> *block, bool force)=0</td></tr>
<tr class="separator:ad2ceb04e1a40cab3bfd42d0f53721e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Initialization.</div></td></tr>
<tr class="memitem:aa22f5f747e2aefd7912edb2f85521cf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aa22f5f747e2aefd7912edb2f85521cf1">initStates</a> ()=0</td></tr>
<tr class="separator:aa22f5f747e2aefd7912edb2f85521cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9a99c283f886c8f2b009c5d981e27ad1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a99c283f886c8f2b009c5d981e27ad1"></a>
<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9a99c283f886c8f2b009c5d981e27ad1">mVideoModes</a></td></tr>
<tr class="memdesc:a9a99c283f886c8f2b009c5d981e27ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of valid video modes for this device. <br /></td></tr>
<tr class="separator:a9a99c283f886c8f2b009c5d981e27ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42308d582bcfd5bcfc4be84ad5b74b36"></a>
<a class="el" href="class_g_f_x_card_profiler.html">GFXCardProfiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a42308d582bcfd5bcfc4be84ad5b74b36">mCardProfiler</a></td></tr>
<tr class="memdesc:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CardProfiler for this device. <br /></td></tr>
<tr class="separator:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bccb6833d494e75ebd17a3481187b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_f_x_resource.html">GFXResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a434bccb6833d494e75ebd17a3481187b">mResourceListHead</a></td></tr>
<tr class="separator:a434bccb6833d494e75ebd17a3481187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0640c509f516369ded3ab66d8d033af4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0640c509f516369ded3ab66d8d033af4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a0640c509f516369ded3ab66d8d033af4">mCanCurrentlyRender</a></td></tr>
<tr class="memdesc:a0640c509f516369ded3ab66d8d033af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set once the device is active. <br /></td></tr>
<tr class="separator:a0640c509f516369ded3ab66d8d033af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b997ba465a5c7481616b57cc496ea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b997ba465a5c7481616b57cc496ea9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ab3b997ba465a5c7481616b57cc496ea9">mAllowRender</a></td></tr>
<tr class="memdesc:ab3b997ba465a5c7481616b57cc496ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if we're in a mode where we want rendering to occur. <br /></td></tr>
<tr class="separator:ab3b997ba465a5c7481616b57cc496ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512cbf498248d8312d4403e5992f58bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a512cbf498248d8312d4403e5992f58bd"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a512cbf498248d8312d4403e5992f58bd">mCurrentRenderStyle</a></td></tr>
<tr class="memdesc:a512cbf498248d8312d4403e5992f58bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style of rendering that is to be performed, based on GFXDeviceRenderStyles. <br /></td></tr>
<tr class="separator:a512cbf498248d8312d4403e5992f58bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee3c4c42b4d22530a1a69fc7de1334ec"></a>
S32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aee3c4c42b4d22530a1a69fc7de1334ec">mCurrentStereoTarget</a></td></tr>
<tr class="memdesc:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current stereo target being rendered to. <br /></td></tr>
<tr class="separator:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c85d356eebe4d5c9e13938073f0b2e4"></a>
<a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a7c85d356eebe4d5c9e13938073f0b2e4">mStereoEyeOffset</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eye offset used when using a stereo rendering style. <br /></td></tr>
<tr class="separator:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acce4a751019055aaf5e767203427dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8acce4a751019055aaf5e767203427dd"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a8acce4a751019055aaf5e767203427dd">mStereoHeadTransform</a></td></tr>
<tr class="memdesc:a8acce4a751019055aaf5e767203427dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center matrix for head. <br /></td></tr>
<tr class="separator:a8acce4a751019055aaf5e767203427dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9719978834b18a8591dbb2b9b8bd35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a9719978834b18a8591dbb2b9b8bd35"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a0a9719978834b18a8591dbb2b9b8bd35">mStereoEyeTransforms</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:a0a9719978834b18a8591dbb2b9b8bd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left and right matrix for eyes. <br /></td></tr>
<tr class="separator:a0a9719978834b18a8591dbb2b9b8bd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b3396082a57edce8055de839fc3f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28b3396082a57edce8055de839fc3f3"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ab28b3396082a57edce8055de839fc3f3">mInverseStereoEyeTransforms</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:ab28b3396082a57edce8055de839fc3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of mStereoEyeTransforms. <br /></td></tr>
<tr class="separator:ab28b3396082a57edce8055de839fc3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b9da8251f994a5b89a8999b865148c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51b9da8251f994a5b89a8999b865148c"></a>
<a class="el" href="struct_fov_port.html">FovPort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a51b9da8251f994a5b89a8999b865148c">mFovPorts</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:a51b9da8251f994a5b89a8999b865148c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fov port settings. <br /></td></tr>
<tr class="separator:a51b9da8251f994a5b89a8999b865148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b078eeae79f9883a8ca2c5474819e65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b078eeae79f9883a8ca2c5474819e65"></a>
<a class="el" href="class_rect_i.html">RectI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a5b078eeae79f9883a8ca2c5474819e65">mStereoViewports</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:a5b078eeae79f9883a8ca2c5474819e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination viewports for stereo rendering. <br /></td></tr>
<tr class="separator:a5b078eeae79f9883a8ca2c5474819e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b294ea6b6557a29bece47901d049bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b294ea6b6557a29bece47901d049bce"></a>
<a class="el" href="class_g_f_x_texture_target.html">GFXTextureTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a5b294ea6b6557a29bece47901d049bce">mStereoTargets</a> [NumStereoPorts]</td></tr>
<tr class="memdesc:a5b294ea6b6557a29bece47901d049bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination targets for stereo rendering. <br /></td></tr>
<tr class="separator:a5b294ea6b6557a29bece47901d049bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383de7991bfb38654381ac35bee51974"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a383de7991bfb38654381ac35bee51974">mInitialized</a></td></tr>
<tr class="separator:a383de7991bfb38654381ac35bee51974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c4a54be462dcd9aa41ed9c9bfe88c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a355c4a54be462dcd9aa41ed9c9bfe88c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mReset</b></td></tr>
<tr class="separator:a355c4a54be462dcd9aa41ed9c9bfe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa819b68c170b3ed9540dabc2d631090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_swizzle.html">Swizzle</a>&lt; U8, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#afa819b68c170b3ed9540dabc2d631090">mDeviceSwizzle32</a></td></tr>
<tr class="separator:afa819b68c170b3ed9540dabc2d631090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c873557881c5019fbe8671a18a05bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_swizzle.html">Swizzle</a>&lt; U8, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a43c873557881c5019fbe8671a18a05bb">mDeviceSwizzle24</a></td></tr>
<tr class="separator:a43c873557881c5019fbe8671a18a05bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac4dc34bd6e229397547b5126ab074a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaac4dc34bd6e229397547b5126ab074a"></a>
<a class="el" href="class_g_f_x_tex_handle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mFrontBuffer</b> [2]</td></tr>
<tr class="separator:aaac4dc34bd6e229397547b5126ab074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe369bc897df355de806d52a3aeafe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe369bc897df355de806d52a3aeafe3"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentFrontBufferIdx</b></td></tr>
<tr class="separator:adbe369bc897df355de806d52a3aeafe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9661b2d8db8a749d77ceaa193b125fe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9661b2d8db8a749d77ceaa193b125fe9"></a>
<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_strong_ref_ptr.html">GFXTargetRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9661b2d8db8a749d77ceaa193b125fe9">mRTStack</a></td></tr>
<tr class="memdesc:a9661b2d8db8a749d77ceaa193b125fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack of previously active render targets. <br /></td></tr>
<tr class="separator:a9661b2d8db8a749d77ceaa193b125fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34099197db5b16c78de828ad781ef30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_strong_ref_ptr.html">GFXTargetRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#af34099197db5b16c78de828ad781ef30">mCurrentRT</a></td></tr>
<tr class="separator:af34099197db5b16c78de828ad781ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff41a4cae195f1eaf108370e450b9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_strong_ref_ptr.html">GFXTargetRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#acff41a4cae195f1eaf108370e450b9b7">mRTDeactivate</a></td></tr>
<tr class="separator:acff41a4cae195f1eaf108370e450b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7559e13ed0b83f00855d96b58951dba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a7559e13ed0b83f00855d96b58951dba4">mRTDirty</a></td></tr>
<tr class="separator:a7559e13ed0b83f00855d96b58951dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e47fe86d99aed8172572a044bc4aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad43e47fe86d99aed8172572a044bc4aa"></a>
<a class="el" href="class_rect_i.html">RectI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad43e47fe86d99aed8172572a044bc4aa">mViewport</a></td></tr>
<tr class="memdesc:ad43e47fe86d99aed8172572a044bc4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current viewport rect. <br /></td></tr>
<tr class="separator:ad43e47fe86d99aed8172572a044bc4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b127b09986479d663abb4b75745e96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a51b127b09986479d663abb4b75745e96">mViewportDirty</a></td></tr>
<tr class="separator:a51b127b09986479d663abb4b75745e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6c20eed5ba81d25036e9b650110e4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e6c20eed5ba81d25036e9b650110e4e"></a>
<a class="el" href="class_g_f_x_draw_util.html">GFXDrawUtil</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mDrawer</b></td></tr>
<tr class="separator:a7e6c20eed5ba81d25036e9b650110e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Tracking</div></td></tr>
<tr class="memitem:a2d6a137fa62660913b15f387f84a6d4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d6a137fa62660913b15f387f84a6d4d"></a>
<a class="el" href="class_g_f_x_light_info.html">GFXLightInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentLight</b> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a2d6a137fa62660913b15f387f84a6d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604ab7c118abd8b5d9e2ccc8fb7dd72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a604ab7c118abd8b5d9e2ccc8fb7dd72a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentLightEnable</b> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a604ab7c118abd8b5d9e2ccc8fb7dd72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a527d0548f69341ce5090babb6cc03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85a527d0548f69341ce5090babb6cc03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mLightDirty</b> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a85a527d0548f69341ce5090babb6cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ee4a2c9a16284f82db47a19f91bc34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ee4a2c9a16284f82db47a19f91bc34"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mLightsDirty</b></td></tr>
<tr class="separator:a78ee4a2c9a16284f82db47a19f91bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b06f263956adda5bf65eee480ef5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a241b06f263956adda5bf65eee480ef5e"></a>
<a class="el" href="class_linear_color_f.html">LinearColorF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mGlobalAmbientColor</b></td></tr>
<tr class="separator:a241b06f263956adda5bf65eee480ef5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c56b555a16db1bb8c5a0e4b5c60c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab44c56b555a16db1bb8c5a0e4b5c60c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mGlobalAmbientColorDirty</b></td></tr>
<tr class="separator:ab44c56b555a16db1bb8c5a0e4b5c60c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fixed function material tracking</div></td></tr>
<tr class="memitem:a2122cca014575c1a80262b10b53091a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2122cca014575c1a80262b10b53091a1"></a>
<a class="el" href="struct_g_f_x_light_material.html">GFXLightMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentLightMaterial</b></td></tr>
<tr class="separator:a2122cca014575c1a80262b10b53091a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c105b7501fa0ac0303870e650174f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c105b7501fa0ac0303870e650174f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mLightMaterialDirty</b></td></tr>
<tr class="separator:af8c105b7501fa0ac0303870e650174f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix managing variables</div></td></tr>
<tr class="memitem:aff5d637cc039b275af5f1c121f329dc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff5d637cc039b275af5f1c121f329dc3"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mWorldMatrix</b> [WORLD_STACK_MAX]</td></tr>
<tr class="separator:aff5d637cc039b275af5f1c121f329dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92eb4b02fb61b330b3ee5ddbfcd29ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab92eb4b02fb61b330b3ee5ddbfcd29ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mWorldMatrixDirty</b></td></tr>
<tr class="separator:ab92eb4b02fb61b330b3ee5ddbfcd29ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d1a7c773d0de6d78d46e7235a5107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948d1a7c773d0de6d78d46e7235a5107"></a>
S32&#160;</td><td class="memItemRight" valign="bottom"><b>mWorldStackSize</b></td></tr>
<tr class="separator:a948d1a7c773d0de6d78d46e7235a5107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3258f45fb86b003b11c54e91e5ade8a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3258f45fb86b003b11c54e91e5ade8a5"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mProjectionMatrix</b></td></tr>
<tr class="separator:a3258f45fb86b003b11c54e91e5ade8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc6a2e2c64ed6ff7df1f9558e1cefb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fc6a2e2c64ed6ff7df1f9558e1cefb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mProjectionMatrixDirty</b></td></tr>
<tr class="separator:a3fc6a2e2c64ed6ff7df1f9558e1cefb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914b619a373d5c753a7bae8b40140e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8914b619a373d5c753a7bae8b40140e9"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mViewMatrix</b></td></tr>
<tr class="separator:a8914b619a373d5c753a7bae8b40140e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4468a18976dcf128855c0bc5d0caf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add4468a18976dcf128855c0bc5d0caf8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mViewMatrixDirty</b></td></tr>
<tr class="separator:add4468a18976dcf128855c0bc5d0caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a85de42022a63022dc4adc1552200d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6a85de42022a63022dc4adc1552200d"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mTextureMatrix</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:aa6a85de42022a63022dc4adc1552200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07c95c8f756a971eaf77e38cea070a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d07c95c8f756a971eaf77e38cea070a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mTextureMatrixDirty</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a7d07c95c8f756a971eaf77e38cea070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51de21268634908ec665e228138be0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d51de21268634908ec665e228138be0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mTextureMatrixCheckDirty</b></td></tr>
<tr class="separator:a8d51de21268634908ec665e228138be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Current frustum planes</div></td></tr>
<tr class="memitem:a35f71a1fbf81f4866c8916078e5e3f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f71a1fbf81f4866c8916078e5e3f0a"></a>
<a class="el" href="class_frustum.html">Frustum</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mFrustum</b></td></tr>
<tr class="separator:a35f71a1fbf81f4866c8916078e5e3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a33e8d2d93e657b79a94ed4f0fc527acc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e8d2d93e657b79a94ed4f0fc527acc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXInit</b></td></tr>
<tr class="separator:a33e8d2d93e657b79a94ed4f0fc527acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe984583f0c8b301f7cc6c96c5d479b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe984583f0c8b301f7cc6c96c5d479b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXPrimitiveBufferHandle</b></td></tr>
<tr class="separator:a7fe984583f0c8b301f7cc6c96c5d479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af5ed4d0b3cd3f7815b99dd49c1051"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38af5ed4d0b3cd3f7815b99dd49c1051"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXVertexBufferHandleBase</b></td></tr>
<tr class="separator:a38af5ed4d0b3cd3f7815b99dd49c1051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df5fb0e6a4333320e8b1cac7e3f0ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57df5fb0e6a4333320e8b1cac7e3f0ec"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXTextureObject</b></td></tr>
<tr class="separator:a57df5fb0e6a4333320e8b1cac7e3f0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e3d8c358d0c659db1d31232e94f4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe9e3d8c358d0c659db1d31232e94f4d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXTexHandle</b></td></tr>
<tr class="separator:afe9e3d8c358d0c659db1d31232e94f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a3d07809f71ccadcb3c3c033d7752d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a3d07809f71ccadcb3c3c033d7752d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXVertexFormat</b></td></tr>
<tr class="separator:ae8a3d07809f71ccadcb3c3c033d7752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e1012a070739438e3af052919e661e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e1012a070739438e3af052919e661e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXTestFullscreenToggle</b></td></tr>
<tr class="separator:a32e1012a070739438e3af052919e661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac952b431e2eb35e206f4c4e5a12f5fed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac952b431e2eb35e206f4c4e5a12f5fed"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TestGFXTextureCube</b></td></tr>
<tr class="separator:ac952b431e2eb35e206f4c4e5a12f5fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01820b17c74336f0f7435ea210734352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01820b17c74336f0f7435ea210734352"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TestGFXRenderTargetCube</b></td></tr>
<tr class="separator:a01820b17c74336f0f7435ea210734352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad952d2a155af37b31ef1fc73d2c0e232"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad952d2a155af37b31ef1fc73d2c0e232"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TestGFXRenderTargetStack</b></td></tr>
<tr class="separator:ad952d2a155af37b31ef1fc73d2c0e232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0228231993de75c3ee3adea94019dd27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0228231993de75c3ee3adea94019dd27"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GFXResource</b></td></tr>
<tr class="separator:a0228231993de75c3ee3adea94019dd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3164cb2ca0a8b55527e81c8e4a5b4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a3164cb2ca0a8b55527e81c8e4a5b4d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LightMatInstance</b></td></tr>
<tr class="separator:a3a3164cb2ca0a8b55527e81c8e4a5b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Resource debug methods</h2></td></tr>
<tr class="memitem:aef70d216314854ef1cdd7f601c17f38e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef70d216314854ef1cdd7f601c17f38e"></a>
<a class="el" href="class_g_f_x_device_statistics.html">GFXDeviceStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mDeviceStatistics</b></td></tr>
<tr class="separator:aef70d216314854ef1cdd7f601c17f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b5c482eb5604583c1e98b160a93d95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ae7b5c482eb5604583c1e98b160a93d95">fillResourceVectors</a> (const char *resNames, bool unflaggedOnly, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;textureObjects, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;textureTargets, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;windowTargets, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;vertexBuffers, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;primitiveBuffers, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;fences, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;cubemaps, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;shaders, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;stateblocks)</td></tr>
<tr class="separator:ae7b5c482eb5604583c1e98b160a93d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fda5a36e31da1fc118d981ff812588"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a15fda5a36e31da1fc118d981ff812588">listResources</a> (bool unflaggedOnly)</td></tr>
<tr class="separator:a15fda5a36e31da1fc118d981ff812588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c4a07f39e736e9761ad5b2fb789fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2c4a07f39e736e9761ad5b2fb789fe4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ab2c4a07f39e736e9761ad5b2fb789fe4">flagCurrentResources</a> ()</td></tr>
<tr class="memdesc:ab2c4a07f39e736e9761ad5b2fb789fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags all resources GFX is currently aware of. <br /></td></tr>
<tr class="separator:ab2c4a07f39e736e9761ad5b2fb789fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81409f3467c6b87f824c88352ff01c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d81409f3467c6b87f824c88352ff01c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9d81409f3467c6b87f824c88352ff01c">clearResourceFlags</a> ()</td></tr>
<tr class="memdesc:a9d81409f3467c6b87f824c88352ff01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the flag on all resources GFX is currently aware of. <br /></td></tr>
<tr class="separator:a9d81409f3467c6b87f824c88352ff01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f80d3480eea502cf74847e5724bf7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a10f80d3480eea502cf74847e5724bf7f">describeResources</a> (const char *resName, const char *file, bool unflaggedOnly)</td></tr>
<tr class="separator:a10f80d3480eea502cf74847e5724bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707344e1c602854a433551c379c432d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707344e1c602854a433551c379c432d1"></a>
<a class="el" href="class_g_f_x_device_statistics.html">GFXDeviceStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a707344e1c602854a433551c379c432d1">getDeviceStatistics</a> ()</td></tr>
<tr class="memdesc:a707344e1c602854a433551c379c432d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current <a class="el" href="class_g_f_x_device_statistics.html">GFXDeviceStatistics</a>, stats are cleared every ::beginScene call. <br /></td></tr>
<tr class="separator:a707344e1c602854a433551c379c432d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
State tracking variables</h2></td></tr>
<tr class="memitem:a2f57e2c8b460f93b5b38d9b28e788858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f57e2c8b460f93b5b38d9b28e788858"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TexDirtyType</b> { <b>GFXTDT_Normal</b>, 
<b>GFXTDT_Cube</b>
 }</td></tr>
<tr class="separator:a2f57e2c8b460f93b5b38d9b28e788858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9abcb3e6bdf6b3b0fc87782b86b3c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9abcb3e6bdf6b3b0fc87782b86b3c7"></a>
typedef <a class="el" href="class_map.html">Map</a>&lt; U32, <a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StateBlockMap</b></td></tr>
<tr class="separator:a8b9abcb3e6bdf6b3b0fc87782b86b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af56a682e13bfc1054bc7b676034e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3af56a682e13bfc1054bc7b676034e08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a></td></tr>
<tr class="memdesc:a3af56a682e13bfc1054bc7b676034e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if ANY state is dirty, including matrices or primitive buffers. <br /></td></tr>
<tr class="separator:a3af56a682e13bfc1054bc7b676034e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2621a5027fb59956868f32f4e0386553"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2621a5027fb59956868f32f4e0386553"></a>
<a class="el" href="class_g_f_x_tex_handle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentTexture</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a2621a5027fb59956868f32f4e0386553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb88935753509005512018446598043"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb88935753509005512018446598043"></a>
<a class="el" href="class_g_f_x_tex_handle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mNewTexture</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:aeeb88935753509005512018446598043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873f2e2daf84075fa8f09b177cd04d29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873f2e2daf84075fa8f09b177cd04d29"></a>
<a class="el" href="class_g_f_x_cubemap_handle.html">GFXCubemapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentCubemap</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a873f2e2daf84075fa8f09b177cd04d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ac98966a4c9149cd735d3a3b5eaa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684ac98966a4c9149cd735d3a3b5eaa8"></a>
<a class="el" href="class_g_f_x_cubemap_handle.html">GFXCubemapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mNewCubemap</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a684ac98966a4c9149cd735d3a3b5eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddd6afe745204f748a5ab2a13a778a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ddd6afe745204f748a5ab2a13a778a2"></a>
TexDirtyType&#160;</td><td class="memItemRight" valign="bottom"><b>mTexType</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a9ddd6afe745204f748a5ab2a13a778a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10f10df402ae33f15136e09419521a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c10f10df402ae33f15136e09419521a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mTextureDirty</b> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a0c10f10df402ae33f15136e09419521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981107f9ba92cb7f876957e55b19de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8981107f9ba92cb7f876957e55b19de3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mTexturesDirty</b></td></tr>
<tr class="separator:a8981107f9ba92cb7f876957e55b19de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3275b8253694e118dce2bde8536c15cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3275b8253694e118dce2bde8536c15cc"></a>
<a class="el" href="class_map.html">StateBlockMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentStateBlocks</b></td></tr>
<tr class="separator:a3275b8253694e118dce2bde8536c15cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec0cd5b93e1f3eba2903c0bd4a551b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afec0cd5b93e1f3eba2903c0bd4a551b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mStateBlockDirty</b></td></tr>
<tr class="separator:afec0cd5b93e1f3eba2903c0bd4a551b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5978aeb64309fdd50ed5bbb638363be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5978aeb64309fdd50ed5bbb638363be"></a>
<a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentStateBlock</b></td></tr>
<tr class="separator:af5978aeb64309fdd50ed5bbb638363be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35efe65723aa02af5fd8a16444a4d1fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35efe65723aa02af5fd8a16444a4d1fb"></a>
<a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mNewStateBlock</b></td></tr>
<tr class="separator:a35efe65723aa02af5fd8a16444a4d1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6f0f57053db7faddd214efe2c05b04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb6f0f57053db7faddd214efe2c05b04"></a>
<a class="el" href="class_g_f_x_shader_const_buffer.html">GFXShaderConstBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentShaderConstBuffer</b></td></tr>
<tr class="separator:aeb6f0f57053db7faddd214efe2c05b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad06dc744102faf1f4098114920931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ad06dc744102faf1f4098114920931"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a29ad06dc744102faf1f4098114920931">smWireframe</a> = false</td></tr>
<tr class="memdesc:a29ad06dc744102faf1f4098114920931"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global forced wireframe mode. <br /></td></tr>
<tr class="separator:a29ad06dc744102faf1f4098114920931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e38378deb803d3c18b5e0c572d75b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e38378deb803d3c18b5e0c572d75b6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a58e38378deb803d3c18b5e0c572d75b6">smDisableVSync</a> = true</td></tr>
<tr class="memdesc:a58e38378deb803d3c18b5e0c572d75b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global vsync state. <br /></td></tr>
<tr class="separator:a58e38378deb803d3c18b5e0c572d75b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df2c70b6334aeeb9cbcd7dab1630ade"></a>
static F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a6df2c70b6334aeeb9cbcd7dab1630ade">smForcedPixVersion</a> = -1.0f</td></tr>
<tr class="memdesc:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">The forced shader model version if non-zero. <br /></td></tr>
<tr class="separator:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa3220067accab7a93c8b3149b50c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a01aa3220067accab7a93c8b3149b50c1">smDisableOcclusionQuery</a> = false</td></tr>
<tr class="separator:a01aa3220067accab7a93c8b3149b50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buffer Allocation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4de9b7b58f57a53063a29ddcfec79493"></a>These methods are implemented per-device and are called by the GFX layer when a user calls an alloc</p>
<dl class="section note"><dt>Note</dt><dd>Primitive Buffers are NOT implemented per device, they wrap index buffers </dd></dl>
</td></tr>
<tr class="memitem:ade79ea252d77700f99fdbd624182b79f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade79ea252d77700f99fdbd624182b79f"></a>
<a class="el" href="class_strong_ref_ptr.html">StrongRefPtr</a>&lt; <a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentVertexBuffer</b> [<a class="el" href="class_g_f_x_device.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:ade79ea252d77700f99fdbd624182b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da647fc184d78513d169e6b9b401ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da647fc184d78513d169e6b9b401ae7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mVertexBufferDirty</b> [<a class="el" href="class_g_f_x_device.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a8da647fc184d78513d169e6b9b401ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf14d72cee6a4eee5d2e946e2b8ab79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf14d72cee6a4eee5d2e946e2b8ab79"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><b>mVertexBufferFrequency</b> [<a class="el" href="class_g_f_x_device.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a8cf14d72cee6a4eee5d2e946e2b8ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e59790ca5758de9492a9983220cfe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e59790ca5758de9492a9983220cfe6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mVertexBufferFrequencyDirty</b> [<a class="el" href="class_g_f_x_device.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a49e59790ca5758de9492a9983220cfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5e09e4d66089c8359624494326a8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5e09e4d66089c8359624494326a8a0"></a>
const <a class="el" href="class_g_f_x_vertex_decl.html">GFXVertexDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrVertexDecl</b></td></tr>
<tr class="separator:a5c5e09e4d66089c8359624494326a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1d89f66d7436373e11a2de109541c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1d89f66d7436373e11a2de109541c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mVertexDeclDirty</b></td></tr>
<tr class="separator:a7e1d89f66d7436373e11a2de109541c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6843bc771a1a79fe956ed982ad82986e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6843bc771a1a79fe956ed982ad82986e"></a>
<a class="el" href="class_strong_ref_ptr.html">StrongRefPtr</a>&lt; <a class="el" href="class_g_f_x_primitive_buffer.html">GFXPrimitiveBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mCurrentPrimitiveBuffer</b></td></tr>
<tr class="separator:a6843bc771a1a79fe956ed982ad82986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a46bbe9ca9f07165ac1b5e15a7191d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90a46bbe9ca9f07165ac1b5e15a7191d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mPrimitiveBufferDirty</b></td></tr>
<tr class="separator:a90a46bbe9ca9f07165ac1b5e15a7191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5598dda8b6efbce870cb3580d3bed88"><td class="memItemLeft" align="right" valign="top">static const U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a> = 4</td></tr>
<tr class="separator:ac5598dda8b6efbce870cb3580d3bed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b296b835980733311084858243c676"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a43b296b835980733311084858243c676">allocVertexBuffer</a> (U32 numVerts, const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *vertexFormat, U32 vertSize, GFXBufferType bufferType, void *data=NULL)=0</td></tr>
<tr class="separator:a43b296b835980733311084858243c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38052299c52e6f333cf4b038e709520d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_vertex_decl.html">GFXVertexDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a38052299c52e6f333cf4b038e709520d">allocVertexDecl</a> (const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *vertexFormat)=0</td></tr>
<tr class="separator:a38052299c52e6f333cf4b038e709520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513eafd27cec212b0f4a227c0e980f1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513eafd27cec212b0f4a227c0e980f1b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a513eafd27cec212b0f4a227c0e980f1b">setVertexDecl</a> (const <a class="el" href="class_g_f_x_vertex_decl.html">GFXVertexDecl</a> *decl)=0</td></tr>
<tr class="memdesc:a513eafd27cec212b0f4a227c0e980f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current vertex declaration on the device. <br /></td></tr>
<tr class="separator:a513eafd27cec212b0f4a227c0e980f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40df8472f8ce595b8081e26d595da57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad40df8472f8ce595b8081e26d595da57"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#ad40df8472f8ce595b8081e26d595da57">setVertexStream</a> (U32 stream, <a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:ad40df8472f8ce595b8081e26d595da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex buffer on the device. <br /></td></tr>
<tr class="separator:ad40df8472f8ce595b8081e26d595da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d4fe702476a93273750e994b122baf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d4fe702476a93273750e994b122baf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a83d4fe702476a93273750e994b122baf">setVertexStreamFrequency</a> (U32 stream, U32 frequency)=0</td></tr>
<tr class="memdesc:a83d4fe702476a93273750e994b122baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex stream frequency on the device. <br /></td></tr>
<tr class="separator:a83d4fe702476a93273750e994b122baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f670d81f44d389c0b4c237244c0d8dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_f_x_primitive_buffer.html">GFXPrimitiveBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a3f670d81f44d389c0b4c237244c0d8dc">allocPrimitiveBuffer</a> (U32 numIndices, U32 numPrimitives, GFXBufferType bufferType, void *data=NULL)=0</td></tr>
<tr class="separator:a3f670d81f44d389c0b4c237244c0d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Texture functions</h2></td></tr>
<tr class="memitem:a42dbd3cae371b904e59d669b6e44382e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42dbd3cae371b904e59d669b6e44382e"></a>
<a class="el" href="class_g_f_x_texture_manager.html">GFXTextureManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mTextureManager</b></td></tr>
<tr class="separator:a42dbd3cae371b904e59d669b6e44382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2845d65759a6c57ee430ac522baa0591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2845d65759a6c57ee430ac522baa0591"></a>
virtual <a class="el" href="class_g_f_x_cubemap.html">GFXCubemap</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createCubemap</b> ()=0</td></tr>
<tr class="separator:a2845d65759a6c57ee430ac522baa0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae530441812a0b904302c77c30d6bc6ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae530441812a0b904302c77c30d6bc6ca"></a>
<a class="el" href="class_g_f_x_texture_manager.html">GFXTextureManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTextureManager</b> ()</td></tr>
<tr class="separator:ae530441812a0b904302c77c30d6bc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Rendering methods</h2></td></tr>
<tr class="memitem:a998ce4a95beabc46cc1dabd7514742bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a998ce4a95beabc46cc1dabd7514742bd"></a>
<a class="el" href="class_platform_timer.html">PlatformTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mFrameTime</b></td></tr>
<tr class="separator:a998ce4a95beabc46cc1dabd7514742bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13868c9a2ea1b9d7accaef50d0c1bb61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13868c9a2ea1b9d7accaef50d0c1bb61"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (U32 flags, const <a class="el" href="class_linear_color_f.html">LinearColorF</a> &amp;color, F32 z, U32 stencil)=0</td></tr>
<tr class="separator:a13868c9a2ea1b9d7accaef50d0c1bb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6203aa0aa3c085ea3e579878e853b7e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6203aa0aa3c085ea3e579878e853b7e6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>beginScene</b> ()</td></tr>
<tr class="separator:a6203aa0aa3c085ea3e579878e853b7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3313b770f266b016589e3d2e7929e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3313b770f266b016589e3d2e7929e7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>endScene</b> ()</td></tr>
<tr class="separator:a2a3313b770f266b016589e3d2e7929e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a6066267fda77578f44c25538017c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a266a6066267fda77578f44c25538017c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>beginField</b> ()</td></tr>
<tr class="separator:a266a6066267fda77578f44c25538017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302842b26f085217160ad81d0446781f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a302842b26f085217160ad81d0446781f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>endField</b> ()</td></tr>
<tr class="separator:a302842b26f085217160ad81d0446781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f42c65529f7db671b731bd38d2492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac0f42c65529f7db671b731bd38d2492"></a>
virtual <a class="el" href="class_g_f_x_tex_handle.html">GFXTexHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFrontBuffer</b> ()</td></tr>
<tr class="separator:aac0f42c65529f7db671b731bd38d2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5f906b6757e53a837df0fd90b0b51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f5f906b6757e53a837df0fd90b0b51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPrimitiveBuffer</b> (<a class="el" href="class_g_f_x_primitive_buffer.html">GFXPrimitiveBuffer</a> *buffer)</td></tr>
<tr class="separator:a27f5f906b6757e53a837df0fd90b0b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ddf97417de82295f859773420f3cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer</a> (<a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a> *buffer, U32 stream=0, U32 frequency=0)</td></tr>
<tr class="separator:a71ddf97417de82295f859773420f3cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee483ec4b229f6b4983a4f9bb5947fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat</a> (const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *vertexFormat)</td></tr>
<tr class="separator:aee483ec4b229f6b4983a4f9bb5947fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73fd289201b74cad6f80c5bbd82fc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd73fd289201b74cad6f80c5bbd82fc3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPrimitive</b> (GFXPrimitiveType primType, U32 vertexStart, U32 primitiveCount)=0</td></tr>
<tr class="separator:acd73fd289201b74cad6f80c5bbd82fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9e832fd0c3cf2946e9bbb1c1a7544"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#a9fd9e832fd0c3cf2946e9bbb1c1a7544">drawIndexedPrimitive</a> (GFXPrimitiveType primType, U32 startVertex, U32 minIndex, U32 numVerts, U32 startIndex, U32 primitiveCount)=0</td></tr>
<tr class="separator:a9fd9e832fd0c3cf2946e9bbb1c1a7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38816c438c3a1caa45e3e7cd8f337b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab38816c438c3a1caa45e3e7cd8f337b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPrimitive</b> (const <a class="el" href="struct_g_f_x_primitive.html">GFXPrimitive</a> &amp;prim)</td></tr>
<tr class="separator:ab38816c438c3a1caa45e3e7cd8f337b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6040e00f4c6cd5cbef7fececa692a5aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6040e00f4c6cd5cbef7fececa692a5aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPrimitive</b> (U32 primitiveIndex)</td></tr>
<tr class="separator:a6040e00f4c6cd5cbef7fececa692a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5368f06eef65c7cc370292d3b060b532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5368f06eef65c7cc370292d3b060b532"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPrimitives</b> ()</td></tr>
<tr class="separator:a5368f06eef65c7cc370292d3b060b532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25998cf14ca686f28529dda2cb6c50ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25998cf14ca686f28529dda2cb6c50ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPrimitiveBuffer</b> (<a class="el" href="class_g_f_x_primitive_buffer.html">GFXPrimitiveBuffer</a> *buffer)</td></tr>
<tr class="separator:a25998cf14ca686f28529dda2cb6c50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General state interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7d6af627d589f83f39d5ef2a3ebf815b"></a>Sets the dirty Render/Texture/Sampler states from the caching system </p>
</td></tr>
<tr class="memitem:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc04807e3c0888dc6ccce3fc4f5a4343"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#adc04807e3c0888dc6ccce3fc4f5a4343">getWireframe</a> ()</td></tr>
<tr class="memdesc:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the forced global wireframe state. <br /></td></tr>
<tr class="separator:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfc90cf657e9a85cb3189c3452f5479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdfc90cf657e9a85cb3189c3452f5479"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#acdfc90cf657e9a85cb3189c3452f5479">getDisableOcclusionQuery</a> ()</td></tr>
<tr class="memdesc:acdfc90cf657e9a85cb3189c3452f5479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occlusion query is disabled. <br /></td></tr>
<tr class="separator:acdfc90cf657e9a85cb3189c3452f5479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5f9b69134353c0a6f3663ca2feece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_f_x_device.html#af2c5f9b69134353c0a6f3663ca2feece">updateStates</a> (bool forceSetAll=false)</td></tr>
<tr class="separator:af2c5f9b69134353c0a6f3663ca2feece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7db06f371a83220987e4190eb6a646b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7db06f371a83220987e4190eb6a646b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearTextureStateImmediate</b> (U32 stage)</td></tr>
<tr class="separator:ab7db06f371a83220987e4190eb6a646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_g_f_x_device.html">GFXDevice</a> is the TSE graphics interface layer. This allows the TSE to do many things, such as use multiple render devices for multi-head systems, and allow a game to render in DirectX 9, OpenGL or any other API which has a GFX implementation seamlessly. There are many concepts in GFX device which may not be familiar to you, especially if you have not used DirectX. <br />
<b>Buffers</b> There are three types of buffers in GFX: vertex, index and primitive. Please note that index buffers are not accessable outside the GFX layer, they are wrapped by primitive buffers. Primitive buffers will be explained in detail later. Buffers are allocated and deallocated using their associated allocXBuffer and freeXBuffer methods on the device. When a buffer is allocated you pass in a pointer to, depending on the buffer, a vertex type pointer or a U16 pointer. During allocation, this pointer is set to the address of where you should copy in the information for this buffer. You must the tell the <a class="el" href="class_g_f_x_device.html">GFXDevice</a> that the information is in, and it should prepare the buffer for use by calling the prepare method on it. Dynamic vertex buffer example: </p><div class="fragment"><div class="line">GFXVertexP *verts;        <span class="comment">// Making a buffer containing verticies with only position</span></div><div class="line"></div><div class="line"><span class="comment">// Allocate a dynamic vertex buffer to hold 3 vertices and use *verts as the location to copy information into</span></div><div class="line"><a class="code" href="class_g_f_x_vertex_buffer_handle.html">GFXVertexBufferHandle</a> vb = GFX-&gt;allocVertexBuffer( 3, &amp;verts, <span class="keyword">true</span> ); </div><div class="line"></div><div class="line"><span class="comment">// Now set the information, we&#39;re making a triangle</span></div><div class="line">verts[0].point = <a class="code" href="class_point3_f.html">Point3F</a>( 200.f, 200.f, 0.f );</div><div class="line">verts[1].point = <a class="code" href="class_point3_f.html">Point3F</a>( 200.f, 400.f, 0.f );</div><div class="line">verts[2].point = <a class="code" href="class_point3_f.html">Point3F</a>( 400.f, 200.f, 0.f );</div><div class="line"></div><div class="line"><span class="comment">// Tell GFX that the information is in and it should be made ready for use</span></div><div class="line"><span class="comment">// Note that nothing is done with verts, this should not and MUST NOT be deleted</span></div><div class="line"><span class="comment">// stored, or otherwise used after prepare is called.</span></div><div class="line">GFX-&gt;prepare( vb );</div><div class="line"></div><div class="line"><span class="comment">// Because this is a dynamic vertex buffer, it is only assured to be valid until someone </span></div><div class="line"><span class="comment">// else allocates a dynamic vertex buffer, so we will render it now</span></div><div class="line">GFX-&gt;setVertexBuffer( vb );</div><div class="line">GFX-&gt;drawPrimitive( GFXTriangleStrip, 0, 1 );</div><div class="line"></div><div class="line"><span class="comment">// Now because this is a dynamic vertex buffer it MUST NOT BE FREED you are only</span></div><div class="line"><span class="comment">// given a handle to a vertex buffer which belongs to the device</span></div></div><!-- fragment --><p>To use a static vertex buffer, it is very similar, this is an example using a static primitive buffer: <br />
This takes place inside a constructor for a class which has a member variable called mPB which is the primitive buffer for the class instance. </p><div class="fragment"><div class="line">U16 *idx;                          <span class="comment">// This is going to be where to write indices</span></div><div class="line">GFXPrimitiveInfo *primitiveInfo;   <span class="comment">// This will be where to write primitive information</span></div><div class="line"></div><div class="line"><span class="comment">// Allocate a primitive buffer with 4 indices, and 1 primitive described for use</span></div><div class="line">mPB = GFX-&gt;allocPrimitiveBuffer( 4, &amp;idx, 1, &amp;primitiveInfo );</div><div class="line"></div><div class="line"><span class="comment">// Write the index information, this is going to be for the outline of a triangle using</span></div><div class="line"><span class="comment">// a line strip</span></div><div class="line">idx[0] = 0;</div><div class="line">idx[1] = 1;</div><div class="line">idx[2] = 2;</div><div class="line">idx[3] = 0;</div><div class="line"></div><div class="line"><span class="comment">// Write the information for the primitive</span></div><div class="line">primitiveInfo-&gt;indexStart = 0;            <span class="comment">// Starting with index 0</span></div><div class="line">primitiveInfo-&gt;minVertex = 0;             <span class="comment">// The minimum vertex index is 0</span></div><div class="line">primitiveInfo-&gt;maxVertex = 3;             <span class="comment">// The maximum vertex index is 3</span></div><div class="line">primitiveInfo-&gt;primitiveCount = 3;        <span class="comment">// There are 3 lines we are drawing</span></div><div class="line">primitiveInfo-&gt;type = GFXLineStrip;       <span class="comment">// This primitive info describes a line strip</span></div></div><!-- fragment --><p> The following code takes place in the destructor for the same class </p><div class="fragment"><div class="line"><span class="comment">// Because this is a static buffer it&#39;s our responsibility to free it when we are done</span></div><div class="line">GFX-&gt;freePrimitiveBuffer( mPB );</div></div><!-- fragment --><p> This last bit takes place in the rendering function for the class </p><div class="fragment"><div class="line"><span class="comment">// You need to set a vertex buffer as well, primitive buffers contain indexing</span></div><div class="line"><span class="comment">// information, not vertex information. This is so you could have, say, a static</span></div><div class="line"><span class="comment">// vertex buffer, and a dynamic primitive buffer.</span></div><div class="line"></div><div class="line"><span class="comment">// This sets the primitive buffer to the static buffer we allocated in the constructor</span></div><div class="line">GFX-&gt;setPrimitiveBuffer( mPB );</div><div class="line"></div><div class="line"><span class="comment">// Draw the first primitive contained in the set primitive buffer, our primitive buffer</span></div><div class="line"><span class="comment">// has only one primitive, so we could also technically call GFX-&gt;drawPrimitives(); and</span></div><div class="line"><span class="comment">// get the same result. </span></div><div class="line">GFX-&gt;drawPrimitive( 0 );</div></div><!-- fragment --><p> If you need any more examples on how to use these buffers please see the rest of the engine. <br />
<b>Primitive Buffers</b> <br />
Primitive buffers wrap and extend the concept of index buffers. The purpose of a primitive buffer is to let objects store all information they have to render their primitives in a central place. Say that a shape is made up of triangle strips and triangle fans, it would still have only one primitive buffer which contained primitive information for each strip and fan. It could then draw itself with one call.</p>
<p>TO BE FINISHED LATER </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_g_f_x_device.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDevice::GFXDeviceEventType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a531f9b88d21ccaa4780797716753d0ce"></a>deCreate&#160;</td><td class="fielddoc">
<p>The device has been created, but not initialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a51ab624fd7dd399629f1e45d898ecaae"></a>deInit&#160;</td><td class="fielddoc">
<p>The device has been initialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a4f3b136d74fbcdfdf1aa8e488e13899e"></a>deDestroy&#160;</td><td class="fielddoc">
<p>The device is about to be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a05c1fa3c4a024c0978fc60a85c2999c1"></a>deStartOfFrame&#160;</td><td class="fielddoc">
<p>The device has started rendering a frame. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a83e2494cae3a09d7a22e515fcb449cd6"></a>deEndOfFrame&#160;</td><td class="fielddoc">
<p>The device is about to finish rendering a frame. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a7a077ed6b615369c276ab5bbc6a042a7"></a>dePostFrame&#160;</td><td class="fielddoc">
<p>The device has rendered a frame and ended the scene. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a2b34f47ff10868d4739a83017c69aff3"></a>deStartOfField&#160;</td><td class="fielddoc">
<p>The device has started rendering a frame's field (such as for side-by-side rendering) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a2b777ea4e88f4f030ec923d09b7748f4"></a>deLeftStereoFrameRendered&#160;</td><td class="fielddoc">
<p>left stereo frame has been rendered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a485c5070f709ecd02b8e7c4e2f8f2428"></a>deRightStereoFrameRendered&#160;</td><td class="fielddoc">
<p>right stereo frame has been rendered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a9e62077d15f8445dcac3a0eca6638ddb"></a>deEndOfField&#160;</td><td class="fielddoc">
<p>The device is about to finish rendering a frame's field. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0cbf75c122df59247deff17c794a932f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GFXDevice::~GFXDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End Block above BTR </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a051a7f704e1cc95a7340365561a92e9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::_updateRenderTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the render targets and viewport in a device specific manner when they are dirty. </p>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a03f7d846d53587474ccbe5c470f03310">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#a2698d44d55c6b165fe18f7acbb4a4fff">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#ad979e56b2a57b820ca886f9700e444fc">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac828dc9eb9b8cd4eec6daf8090cc4639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::activateStereoTarget </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>eyeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Activates a stereo render target, setting the correct viewport to render eye contents. If eyeId is -1, set a viewport encompassing the entire size of the render targets. </p>

</div>
</div>
<a class="anchor" id="a3f670d81f44d389c0b4c237244c0d8dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_primitive_buffer.html">GFXPrimitiveBuffer</a>* GFXDevice::allocPrimitiveBuffer </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GFXBufferType&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates a primitive buffer and returns a pointer to the allocated buffer. A primitive buffer's type argument refers to the index data - the primitive data will always be preserved from call to call.</p>
<dl class="section note"><dt>Note</dt><dd>All index buffers use unsigned 16-bit indices. </dd></dl>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#aefc930d565676cb87b6b0ac62393d49f">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_g_l_device.html#aa2b70abb587611b892392bca6445b54a">GFXGLDevice</a>, and <a class="el" href="class_g_f_x_null_device.html#af30a7dab71f177a36f18c6ac1894fee3">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad993db38e2a55452481cca1522a28d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_texture_target.html">GFXTextureTarget</a>* GFXDevice::allocRenderToTextureTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a target for doing render to texture operations, with no depth/stencil buffer. </p>

<p>Implemented in <a class="el" href="class_g_f_x_null_device.html#a1206f62cc7c8c3fb92b3d61f2fdff4c7">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#ac8a52035040ae40dd210e97fabc19220">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a43b296b835980733311084858243c676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a>* GFXDevice::allocVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GFXBufferType&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates a vertex buffer and returns a pointer to the allocated buffer. This function should not be called directly - rather it should be used by the <a class="el" href="class_g_f_x_vertex_buffer_handle.html" title="A handle object for allocating, filling, and reading a vertex buffer. ">GFXVertexBufferHandle</a> class. </p>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a3be4c18a999aeb5f5a1cc414149dbb82">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_g_l_device.html#a53fa3070b43712065897cfbaac1d75c5">GFXGLDevice</a>, and <a class="el" href="class_g_f_x_null_device.html#a5962a57a62dc4502030d584dd7550bc3">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a38052299c52e6f333cf4b038e709520d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_vertex_decl.html">GFXVertexDecl</a>* GFXDevice::allocVertexDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called from <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> to allocate the hardware specific vertex declaration for rendering. </p>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a51df562995ba64c740419641b9ccdc43">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_g_l_device.html#a303fa5ea72ce0152e370f612d959fc3b">GFXGLDevice</a>, and <a class="el" href="class_g_f_x_null_device.html#a07583e358063592af0c994d93790e304">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af6891dec318410ef94116b4ec950342c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::canCurrentlyRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the scene has begun and its safe to make rendering calls. </p><dl class="section see"><dt>See also</dt><dd>beginScene </dd>
<dd>
endScene </dd></dl>

</div>
</div>
<a class="anchor" id="a4e618ec59bd3af2c80feebc76bcf9c4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_fence.html">GFXFence</a>* GFXDevice::createFence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a fence. The API specific implementation of <a class="el" href="class_g_f_x_device.html">GFXDevice</a> is responsible to make sure that the proper type is used. <a class="el" href="class_g_f_x_general_fence.html">GFXGeneralFence</a> should work in all cases. </p>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a9a9fef4e2d9c65b981a9696c8f98bb88">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#a697a4cf3dd6a92fa4ca146c66e89509e">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#abfad9f7c080fec9b7feb9e65f8cdfbb9">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae0a363725d0a5402fc0b4889749371ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_occlusion_query.html">GFXOcclusionQuery</a>* GFXDevice::createOcclusionQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a hardware occlusion query object or NULL if this device does not support them. </p>

<p>Reimplemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a939310594c074cd81e252b32aa5adeb1">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#a2c2f97d34b471310c9f368ed13e59c69">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#a5693fdda49646b635eff8fecde3a4815">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac1782edd3fa1bfb70fe6e2477139a450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_f_x_shader.html">GFXShader</a>* GFXDevice::createShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new empty shader which must be initialized and deleted by the caller. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_shader.html#a70047f0ef7cff2dec32519f8664dfceb" title="Deprecated. Remove on T3D 4.0. ">GFXShader::init</a> </dd></dl>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a3b25d89e52d2c67b6d4ab01556b6e228">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#a790a8901c066c319a9fc9ccf0ccb491b">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#a4c56738b7a2d62901fadf0cc6697f4ec">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9be8e70679d4df73d44b2315d8f77d5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_strong_ref_ptr.html">GFXStateBlockRef</a> GFXDevice::createStateBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_g_f_x_state_block_desc.html">GFXStateBlockDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a state block object based on the desc passed in. This object represents an immutable state. </p>

</div>
</div>
<a class="anchor" id="a10f80d3480eea502cf74847e5724bf7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::describeResources </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>resName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dumps a description of the specified resource types to the console </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resNames</td><td>A string of space separated class names (e.g. "GFXTextureObject GFXTextureTarget GFXShader") to describe to the console </td></tr>
    <tr><td class="paramname">file</td><td>A path to the file to write the descriptions to. If it is NULL or "", descriptions are written to the console. </td></tr>
    <tr><td class="paramname">unflaggedOnly</td><td>If true, this method only counts unflagged resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>resNames is case sensitive because there is no dStristr function. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fd9e832fd0c3cf2946e9bbb1c1a7544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::drawIndexedPrimitive </td>
          <td>(</td>
          <td class="paramtype">GFXPrimitiveType&#160;</td>
          <td class="paramname"><em>primType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>startVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>minIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>primitiveCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The parameters to drawIndexedPrimitive are somewhat complicated. From a raw-data stand point they evaluate to something like the following: </p><div class="fragment"><div class="line">U16 indicies[] = { 0, 1, 2, 1, 0, 0, 2 }; </div><div class="line"><a class="code" href="class_point3_f.html">Point3F</a> verts[] = { <a class="code" href="class_point3_f.html">Point3F</a>( 0.0f, 0.0f, 0.0f ), <a class="code" href="class_point3_f.html">Point3F</a>( 0.0f, 1.0f, 0.0f ), <a class="code" href="class_point3_f.html">Point3F</a>( 0.0f, 0.0f, 1.0f ) };</div><div class="line"></div><div class="line">GFX-&gt;drawIndexedPrimitive( GFXLineList, <span class="comment">// Drawing a list of lines, each line is two verts</span></div><div class="line">                           0, <span class="comment">// vertex 0 will be referenced so minIndex = 0</span></div><div class="line">                           3, <span class="comment">// 3 verticies will be used for this draw call</span></div><div class="line">                           1, <span class="comment">// We want index 1 to be the first index used, so indicies 1-6 will be used</span></div><div class="line">                           3  <span class="comment">// Drawing 3 LineList primitives, meaning 6 verts will be drawn</span></div><div class="line">                            );</div><div class="line"></div><div class="line">U16 *idxPtr = &amp;indicies[1];  <span class="comment">// 1 = startIndex, so the pointer is offset such that:</span></div><div class="line">                             <span class="comment">//    idxPtr[0] is the same as indicies[1]</span></div><div class="line"></div><div class="line">U32 numVertsToDrawFromBuffer = primitiveCount * 2; <span class="comment">// 2 verts define a line in the GFXLineList primitive type (6)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primType</td><td>Type of primitive to draw</td></tr>
    <tr><td class="paramname">startVertex</td><td>This defines index zero. Its the offset from the start of the vertex buffer to the first vertex.</td></tr>
    <tr><td class="paramname">minIndex</td><td>The smallest index into the vertex stream which will be used for this draw call. This is a zero based index relative to startVertex. It is strictly a performance hint for implementations. No vertex below minIndex will be referenced by this draw call. For device implementors, this should <em>not</em> be used to offset the vertex buffer, or index buffer.</td></tr>
    <tr><td class="paramname">numVerts</td><td>The number of verticies which will be referenced in this draw call. This is not the number of verticies which will be drawn. That is a function of 'primType' and 'primitiveCount'.</td></tr>
    <tr><td class="paramname">startIndex</td><td>An offset from the start of the index buffer to specify where to start. If 'idxBuffer' is a pointer to an array of integers, this could be written as int *offsetIdx = idxBuffer + startIndex;</td></tr>
    <tr><td class="paramname">primitiveCount</td><td>The number of primitives of type 'primType' to draw. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#aad3fb57a250c1727e35ceb0af7eb772d">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#ac9f23e9fd95a363a4f7cbdf0877a2c88">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#a7806f1d78275ac70960d2916486d9d92">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a8d70d5cb8bdbb63f3d56c3295fa794f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::dumpStates </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a method designed for debugging. It will allow you to dump the states in the render manager out to a file so that it can be diffed and examined. </p>

</div>
</div>
<a class="anchor" id="ae7b5c482eb5604583c1e98b160a93d95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::fillResourceVectors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>resNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textureObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textureTargets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>windowTargets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>primitiveBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubemaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>shaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_g_f_x_resource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateblocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper method for describeResourcesToFile. It walks through the <a class="el" href="class_g_f_x_resource.html">GFXResource</a> list and sorts it by item type, putting the resources into the proper vector. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_device.html#a10f80d3480eea502cf74847e5724bf7f">describeResources</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bcfdaaf73855c6ba53e472eb1d700b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_vector.html">Vector</a>&lt;<a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a>&gt;* const GFXDevice::getVideoModeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the video mode list. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="accb03342ccba47508daf1c98f08f08af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point2_f.html">Point2F</a> GFXDevice::getWorldToScreenScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the scale for converting world space units to screen space units... aka pixels.</p>
<p>This is the true scale which is best used for GUI drawing. For doing lod calculations you should be using the functions in SceneState which is adjusted for special cases like shadows and reflections.</p>
<dl class="section see"><dt>See also</dt><dd>SceneState::getWorldToScreenScale() </dd>
<dd>
SceneState::projectRadius() </dd></dl>

</div>
</div>
<a class="anchor" id="a975e77604d95bf67bf892a6bc6ddf15a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_g_f_x_video_mode.html">GFXVideoMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_platform_window.html">PlatformWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize this <a class="el" href="class_g_f_x_device.html">GFXDevice</a>, optionally specifying a platform window to bind to. </p>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a35ca1017384ef4f117e719475669b964">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#ad138b51173d1a6f4717c4b6d4a2be619">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#a53146992f4ed450ffeede63749cb3d17">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aa22f5f747e2aefd7912edb2f85521cf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::initStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State initialization. This MUST BE CALLED in setVideoMode after the device is created. </p>

<p>Implemented in <a class="el" href="class_g_f_x_g_l_device.html#a9de7e0283f8eaae015bc9902074acdd9">GFXGLDevice</a>, <a class="el" href="class_g_f_x_null_device.html#ab55b0c52da394842b1f273890c13f3fc">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_d3_d11_device.html#a63644a620f40601b7efb5ac8ec93cc78">GFXD3D11Device</a>.</p>

</div>
</div>
<a class="anchor" id="a15fda5a36e31da1fc118d981ff812588"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::listResources </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lists how many of each GFX resource (e.g. textures, texture targets, shaders, etc.) GFX is aware of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unflaggedOnly</td><td>If true, this method only counts unflagged resources </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2dd2cb45f6c371e03b065b02b4a648b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::multWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the matrix at the top of the world matrix stack by a matrix and replaces the top of the matrix stack with the result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to multiply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad39a1f6ba3cf89fdbfe9f1b5c2a4401b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::preDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called before this, or any other device, is deleted in the global destroy() method. It allows the device to clean up anything while everything is still valid. </p>

<p>Reimplemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a498cf2682dc3c0206f59d6137782735f">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_null_device.html#a2c3b4185bdf26223296e6d60513db232">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#ad41086c6c8fe21c6848a4a0840487af7">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b012283186cb887f4bda73b35fad1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::pushWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pushes the world matrix stack and copies the current top matrix to the new top of the stack </p>

</div>
</div>
<a class="anchor" id="a584fb79c33de9df4ebdbe8531b17b865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GFXFormat GFXDevice::selectSupportedFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_f_x_texture_profile.html">GFXTextureProfile</a> *&#160;</td>
          <td class="paramname"><em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; GFXFormat &gt; &amp;&#160;</td>
          <td class="paramname"><em>formats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mustblend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mustfilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first format from the list which meets all the criteria of the texture profile and query options. </p>

<p>Implemented in <a class="el" href="class_g_f_x_null_device.html#ade7b1034df1985fd5d54dd8472fdf6bd">GFXNullDevice</a>, and <a class="el" href="class_g_f_x_g_l_device.html#a441eac72c6ac2888d07a4a1b41605098">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad90bd19adb63e362d02fc2fcc6d67bb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setFrustum </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRotate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the projection frustum.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_math_utils.html#ae65570815e13b8e2219a117820724ba7" title="Build the frustum near plane dimensions from the parameters. ">MathUtils::makeFrustum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae69948ce316fd8bd1979d6477100c341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setMatrix </td>
          <td>(</td>
          <td class="paramtype">GFXMatrixType&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be implemented differently per API and it should set ONLY the current matrix. For example, in OpenGL, there should be NO matrix stack activity, all the stack stuff is managed in the GFX layer.</p>
<p>OpenGL does not have separate world and view matrices. It has ModelView which is world * view. You must take this into consideration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtype</td><td>Which matrix to set, world/view/projection </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix to assign </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#ac1fdebbcdb52afa36ccc3741ac1b3627">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_g_l_device.html#a785c18e63d0d8ee1ab0923d2a64fe649">GFXGLDevice</a>, and <a class="el" href="class_g_f_x_null_device.html#aa4339a732d2dad314b6325eef96bb1c5">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac919f3f4e11d349b3919f851a40c7f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setOrtho </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doRotate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will construct and apply an orthographic projection matrix with the provided parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doRotate</td><td>If set to true, the resulting matrix will be rotated PI/2 around the X axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e383532f8a7db58b99310ab9a9dd2ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newProj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the projection matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newProj</td><td>New projection matrix to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa58ebf2102c1fdb1ab5a3272cc6b8575"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStateBlockByDesc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_g_f_x_state_block_desc.html">GFXStateBlockDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets a stateblock directly from the description structure. Its acceptable to use this for debug rendering and other low frequency rendering tasks. </p>

</div>
</div>
<a class="anchor" id="ad2ceb04e1a40cab3bfd42d0f53721e41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setStateBlockInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_f_x_state_block.html">GFXStateBlock</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by <a class="el" href="class_g_f_x_device.html">GFXDevice</a> to actually set a stateblock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, set all states </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_g_f_x_d3_d11_device.html#a730e2f82ba1fadb718fcd3c1335d12b6">GFXD3D11Device</a>, <a class="el" href="class_g_f_x_g_l_device.html#a45c4e6d9287fa5bf807af27a7b4de90c">GFXGLDevice</a>, and <a class="el" href="class_g_f_x_null_device.html#a6b49ff7c72c4251c1c06877f1009021a">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ab07a4b0ac3141200a820922b58da5107"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setupGenericShaders </td>
          <td>(</td>
          <td class="paramtype">GenericShaderType&#160;</td>
          <td class="paramname"><em>type</em> = <code>GSColor</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper function to set a default shader for rendering GUI elements on systems which do not support fixed-function operations as well as for things which need just generic position/texture/color shaders</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of generic shader, add your own if you need </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_g_f_x_d3_d11_device.html#af1bf2191b3fec09d0934bad11963d9f5">GFXD3D11Device</a>, and <a class="el" href="class_g_f_x_g_l_device.html#adb039ea491dfdce27fe14d869e324597">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a71ddf97417de82295f859773420f3cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_f_x_vertex_buffer.html">GFXVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>frequency</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the vertex buffer.</p>
<p>When setting the stream 0 vertex buffer it will automatically set its associated vertex format as the active format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer or NULL to clear the buffer. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream index of the vertex source stream to place the buffer. </td></tr>
    <tr><td class="paramname">frequency</td><td>The stream frequency of the vertex buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee483ec4b229f6b4983a4f9bb5947fee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setVertexFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_g_f_x_vertex_format.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current vertex format.</p>
<p>This should only be used if the vertex format of the stream 0 vertex buffer is different from the one associated to it. Typically this is used when rendering from multiple vertex streams. </p>

</div>
</div>
<a class="anchor" id="a612f00a3b21b5ec5d071fd9a409891a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newView</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the view matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newView</td><td>New view matrix to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8964ddd37f4be2361cb346b1e132fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newWorld</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the top of the world matrix stack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWorld</td><td>New world matrix to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2c5f9b69134353c0a6f3663ca2feece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::updateStates </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSetAll</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stateblocks </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af34099197db5b16c78de828ad781ef30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_strong_ref_ptr.html">GFXTargetRef</a> GFXDevice::mCurrentRT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current render target which may or may not not be yet activated. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_device.html#a7559e13ed0b83f00855d96b58951dba4">mRTDirty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43c873557881c5019fbe8671a18a05bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_swizzle.html">Swizzle</a>&lt;U8, 3&gt;* GFXDevice::mDeviceSwizzle24</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_device.html#a936a62a3dd886a1ec053b8cc42bf0d12" title="Swizzle to convert 24bpp bitmaps from RGB to the native device format. ">getDeviceSwizzle24</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa819b68c170b3ed9540dabc2d631090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_swizzle.html">Swizzle</a>&lt;U8, 4&gt;* GFXDevice::mDeviceSwizzle32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_device.html#a6fdbb77883a6fcca9ae65fabae68c2ea" title="Swizzle to convert 32bpp bitmaps from RGBA to the native device format. ">getDeviceSwizzle32</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a383de7991bfb38654381ac35bee51974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mInitialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will allow querying to see if a device is initialized and ready to have operations performed on it. </p>

</div>
</div>
<a class="anchor" id="a434bccb6833d494e75ebd17a3481187b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_f_x_resource.html">GFXResource</a>* GFXDevice::mResourceListHead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Head of the resource list.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_g_f_x_resource.html">GFXResource</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acff41a4cae195f1eaf108370e450b9b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_strong_ref_ptr.html">GFXTargetRef</a> GFXDevice::mRTDeactivate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This tracks a previously activated render target which need to be deactivated. </p>

</div>
</div>
<a class="anchor" id="a7559e13ed0b83f00855d96b58951dba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mRTDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is set when the current and/or deactivate render targets have changed and the device need to update its state on the next draw/clear. </p>

</div>
</div>
<a class="anchor" id="a51b127b09986479d663abb4b75745e96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mViewportDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If true the viewport has been changed and it must be updated on the next draw/clear. </p>

</div>
</div>
<a class="anchor" id="a01aa3220067accab7a93c8b3149b50c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::smDisableOcclusionQuery = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable all hardware occlusion queries causing them to return only the visibile state. </p>

</div>
</div>
<a class="anchor" id="ac5598dda8b6efbce870cb3580d3bed88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const U32 GFXDevice::VERTEX_STREAM_COUNT = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of supported vertex streams which may be more than the device supports. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/projects/torque3d-qw64q/Engine/source/gfx/<a class="el" href="gfx_device_8h_source.html">gfxDevice.h</a></li>
<li>C:/projects/torque3d-qw64q/Engine/source/gfx/gfxDevice.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
