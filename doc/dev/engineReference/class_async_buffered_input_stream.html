<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: AsyncBufferedInputStream&lt; T, Stream &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_async_buffered_input_stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AsyncBufferedInputStream&lt; T, Stream &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for AsyncBufferedInputStream&lt; T, Stream &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_async_buffered_input_stream__inherit__graph.png" border="0" usemap="#_async_buffered_input_stream_3_01_t_00_01_stream_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_async_buffered_input_stream_3_01_t_00_01_stream_01_4_inherit__map" id="_async_buffered_input_stream_3_01_t_00_01_stream_01_4_inherit__map">
<area shape="rect" id="node5" href="class_async_single_buffered_input_stream.html" title="AsyncSingleBufferedInput\lStream\&lt; T, Stream \&gt;" alt="" coords="640,43,811,84"/>
<area shape="rect" id="node2" href="class_i_input_stream_filter.html" title="IInputStreamFilter\l\&lt; T, Stream \&gt;" alt="" coords="212,5,336,47"/>
<area shape="rect" id="node3" href="class_i_input_stream.html" title="IInputStream\&lt; T \&gt;" alt="" coords="5,13,132,39"/>
<area shape="rect" id="node4" href="class_thread_safe_ref_count.html" title="ThreadSafeRefCount\l\&lt; AsyncBufferedInputStream\l\&lt; T, Stream \&gt; \&gt;" alt="" coords="180,71,368,127"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for AsyncBufferedInputStream&lt; T, Stream &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_async_buffered_input_stream__coll__graph.png" border="0" usemap="#_async_buffered_input_stream_3_01_t_00_01_stream_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_async_buffered_input_stream_3_01_t_00_01_stream_01_4_coll__map" id="_async_buffered_input_stream_3_01_t_00_01_stream_01_4_coll__map">
<area shape="rect" id="node2" href="class_i_input_stream_filter.html" title="IInputStreamFilter\l\&lt; T, Stream \&gt;" alt="" coords="1511,29,1635,70"/>
<area shape="rect" id="node3" href="class_i_input_stream.html" title="IInputStream\&lt; T \&gt;" alt="" coords="1128,5,1255,32"/>
<area shape="rect" id="node4" href="class_thread_safe_ref_count.html" title="ThreadSafeRefCount\l\&lt; AsyncBufferedInputStream\l\&lt; T, Stream \&gt; \&gt;" alt="" coords="1479,127,1667,183"/>
<area shape="rect" id="node5" href="class_thread_pool.html" title="ThreadPool" alt="" coords="1529,207,1616,233"/>
<area shape="rect" id="node6" href="class_string.html" title="The String class represents a 0&#45;terminated array of characters. " alt="" coords="1163,95,1219,121"/>
<area shape="rect" id="node7" href="class_semaphore.html" title="Semaphore" alt="" coords="263,163,351,189"/>
<area shape="rect" id="node15" href="class_platform_thread_data.html" title="PlatformThreadData" alt="" coords="511,196,647,223"/>
<area shape="rect" id="node8" href="class_platform_semaphore.html" title="PlatformSemaphore" alt="" coords="5,163,141,189"/>
<area shape="rect" id="node9" href="struct_thread_safe_priority_queue_with_update.html" title="ThreadSafePriorityQueueWith\lUpdate\&lt; WorkItemWrapper, F32 \&gt;" alt="" coords="1080,265,1303,306"/>
<area shape="rect" id="node10" href="struct_thread_safe_priority_queue.html" title="ThreadSafePriorityQueue\l\&lt; WorkItemWrapper, F32,\l false, 4, 50 \&gt;" alt="" coords="764,257,937,313"/>
<area shape="rect" id="node11" href="class_thread_safe_ref.html" title="ThreadSafeRef\&lt; Node \&gt;" alt="" coords="499,389,659,416"/>
<area shape="rect" id="node12" href="struct_thread_safe_priority_queue.html" title="ThreadSafePriorityQueue\l\&lt; ThreadSafeRef\&lt; Node\l \&gt;, TickType, true, 4, 50 \&gt;" alt="" coords="764,337,937,393"/>
<area shape="rect" id="node17" href="class_thread_safe_deque.html" title="ThreadSafeDeque\&lt; Element\lType \&gt;" alt="" coords="1481,334,1665,375"/>
<area shape="rect" id="node19" href="class_thread_safe_deque_1_1_node.html" title="List node. " alt="" coords="779,486,922,527"/>
<area shape="rect" id="node13" href="struct_thread_pool_1_1_worker_thread.html" title="ThreadPool::WorkerThread" alt="" coords="1103,207,1279,233"/>
<area shape="rect" id="node14" href="class_thread.html" title="Thread" alt="" coords="820,207,881,233"/>
<area shape="rect" id="node16" href="class_thread_pool_1_1_context.html" title="ThreadPool::Context" alt="" coords="1503,483,1643,509"/>
<area shape="rect" id="node18" href="class_thread_safe_free_list.html" title="ThreadSafeFreeList\l\&lt; ThreadSafeDeque::Node \&gt;" alt="" coords="1098,469,1285,510"/>
<area shape="rect" id="node20" href="class_thread_safe_free_list_node.html" title="ThreadSafeFreeListNode\l\&lt; Node, DeleteNode \&gt;" alt="" coords="497,503,661,545"/>
<area shape="rect" id="node21" href="class_thread_safe_ref_count.html" title="ThreadSafeRefCount\l\&lt; Node, DeleteNode \&gt;" alt="" coords="232,503,383,545"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a082b08e164f884c9970842e1efe17b43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_async_buffered_input_stream.html#a082b08e164f884c9970842e1efe17b43a8b844f8e4a553a9e6d347412fa1beb77">DEFAULT_STREAM_LOOKAHEAD</a> = 3
 }</td></tr>
<tr class="separator:a082b08e164f884c9970842e1efe17b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8791eb0690dd88623caeb588404a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e8791eb0690dd88623caeb588404a01"></a>
typedef <a class="el" href="class_i_input_stream_filter.html">IInputStreamFilter</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:a0e8791eb0690dd88623caeb588404a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2908ce78d534500c229949fe638ff95e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2908ce78d534500c229949fe638ff95e"></a>
typedef Parent::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a2908ce78d534500c229949fe638ff95e">ElementType</a></td></tr>
<tr class="memdesc:a2908ce78d534500c229949fe638ff95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of elements read, buffered, and returned by this stream. <br /></td></tr>
<tr class="separator:a2908ce78d534500c229949fe638ff95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ce6425a179fed9dd8f6e27a3cccbcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83ce6425a179fed9dd8f6e27a3cccbcb"></a>
typedef Parent::SourceStreamType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a83ce6425a179fed9dd8f6e27a3cccbcb">SourceStreamType</a></td></tr>
<tr class="memdesc:a83ce6425a179fed9dd8f6e27a3cccbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the source stream being read by this stream. <br /></td></tr>
<tr class="separator:a83ce6425a179fed9dd8f6e27a3cccbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11f322d098d4b5a17ad6b7478e2d0b"><td class="memItemLeft" align="right" valign="top">typedef Parent::SourceElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#abc11f322d098d4b5a17ad6b7478e2d0b">SourceElementType</a></td></tr>
<tr class="separator:abc11f322d098d4b5a17ad6b7478e2d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_i_input_stream_filter"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_i_input_stream_filter')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_i_input_stream_filter.html">IInputStreamFilter&lt; T, Stream &gt;</a></td></tr>
<tr class="memitem:a4fca46533a1cd80ec9d2378bb974cdad inherit pub_types_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fca46533a1cd80ec9d2378bb974cdad"></a>
typedef <a class="el" href="class_i_input_stream.html">IInputStream</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:a4fca46533a1cd80ec9d2378bb974cdad inherit pub_types_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2414293f095bbf0a512bd5c219c2479d inherit pub_types_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2414293f095bbf0a512bd5c219c2479d"></a>
typedef <a class="el" href="struct_type_traits.html">TypeTraits</a>&lt; <a class="el" href="class_stream.html">Stream</a> &gt;::BaseType&#160;</td><td class="memItemRight" valign="bottom"><b>SourceStreamType</b></td></tr>
<tr class="separator:a2414293f095bbf0a512bd5c219c2479d inherit pub_types_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9887d7904379c525b441627d0b0ea6a inherit pub_types_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9887d7904379c525b441627d0b0ea6a"></a>
typedef <a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">SourceStreamType::ElementType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_input_stream_filter.html#af9887d7904379c525b441627d0b0ea6a">SourceElementType</a></td></tr>
<tr class="memdesc:af9887d7904379c525b441627d0b0ea6a inherit pub_types_class_i_input_stream_filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">The element type of the source stream. <br /></td></tr>
<tr class="separator:af9887d7904379c525b441627d0b0ea6a inherit pub_types_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_i_input_stream"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_i_input_stream')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_i_input_stream.html">IInputStream&lt; T &gt;</a></td></tr>
<tr class="memitem:a615ff4faae7d1fa40d270d2570d52446 inherit pub_types_class_i_input_stream"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a615ff4faae7d1fa40d270d2570d52446"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:a615ff4faae7d1fa40d270d2570d52446 inherit pub_types_class_i_input_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6484777b477cd938e322477779fc39fa inherit pub_types_class_i_input_stream"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6484777b477cd938e322477779fc39fa"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a></td></tr>
<tr class="memdesc:a6484777b477cd938e322477779fc39fa inherit pub_types_class_i_input_stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">The element type of this input stream. <br /></td></tr>
<tr class="separator:a6484777b477cd938e322477779fc39fa inherit pub_types_class_i_input_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; AsyncBufferedInputStream&lt; T, Stream &gt; &gt;</a></td></tr>
<tr class="memitem:ad77f7e5171e301e340eea6e3451ca1df inherit pub_types_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77f7e5171e301e340eea6e3451ca1df"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:ad77f7e5171e301e340eea6e3451ca1df inherit pub_types_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c40ee936e2a777b5cfe2b73edf336d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a9c40ee936e2a777b5cfe2b73edf336d5">AsyncBufferedInputStream</a> (const <a class="el" href="class_stream.html">Stream</a> &amp;stream, U32 numSourceElementsToRead=0, U32 numReadAhead=<a class="el" href="class_async_buffered_input_stream.html#a082b08e164f884c9970842e1efe17b43a8b844f8e4a553a9e6d347412fa1beb77">DEFAULT_STREAM_LOOKAHEAD</a>, bool <a class="el" href="class_async_buffered_input_stream.html#adebe059e8973bfab26f0b68a0f93a807">isLooping</a>=false, <a class="el" href="class_thread_pool.html">ThreadPool</a> *pool=&amp;<a class="el" href="class_thread_pool.html#a1550a848c845e18e232de06b53a809e0">ThreadPool::GLOBAL</a>(), <a class="el" href="class_thread_pool_1_1_context.html">ThreadContext</a> *context=<a class="el" href="class_thread_pool_1_1_context.html#a395f88a662265ff1eac88a351687de0a">ThreadContext::ROOT_CONTEXT</a>())</td></tr>
<tr class="separator:a9c40ee936e2a777b5cfe2b73edf336d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebe059e8973bfab26f0b68a0f93a807"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#adebe059e8973bfab26f0b68a0f93a807">isLooping</a> () const </td></tr>
<tr class="separator:adebe059e8973bfab26f0b68a0f93a807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eac8bdc6eef9b7f2f74ba7954bb75f9"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a9eac8bdc6eef9b7f2f74ba7954bb75f9">getReadAhead</a> () const </td></tr>
<tr class="separator:a9eac8bdc6eef9b7f2f74ba7954bb75f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8d562dc1a6db35d7f5db7ca330657e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd8d562dc1a6db35d7f5db7ca330657e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#afd8d562dc1a6db35d7f5db7ca330657e">start</a> ()</td></tr>
<tr class="memdesc:afd8d562dc1a6db35d7f5db7ca330657e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate the request chain of the element stream. <br /></td></tr>
<tr class="separator:afd8d562dc1a6db35d7f5db7ca330657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b864cb19c6aaff17ad112d88da1e7c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a1b864cb19c6aaff17ad112d88da1e7c8">stop</a> ()</td></tr>
<tr class="separator:a1b864cb19c6aaff17ad112d88da1e7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3175f1121dbddd43f74fa4f6f3ea05e"><td class="memItemLeft" align="right" valign="top">virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#ad3175f1121dbddd43f74fa4f6f3ea05e">read</a> (<a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a> *buffer, U32 num)</td></tr>
<tr class="separator:ad3175f1121dbddd43f74fa4f6f3ea05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_input_stream_filter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_input_stream_filter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_input_stream_filter.html">IInputStreamFilter&lt; T, Stream &gt;</a></td></tr>
<tr class="memitem:aacbfb4e7b032eeedc2eb775f95f9aa64 inherit pub_methods_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacbfb4e7b032eeedc2eb775f95f9aa64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_input_stream_filter.html#aacbfb4e7b032eeedc2eb775f95f9aa64">IInputStreamFilter</a> (const <a class="el" href="class_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:aacbfb4e7b032eeedc2eb775f95f9aa64 inherit pub_methods_class_i_input_stream_filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a filter reading elements from "stream". <br /></td></tr>
<tr class="separator:aacbfb4e7b032eeedc2eb775f95f9aa64 inherit pub_methods_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e076910cc7030b716df978ba7388d2 inherit pub_methods_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_input_stream_filter.html#a70e076910cc7030b716df978ba7388d2">getSourceStream</a> () const</td></tr>
<tr class="separator:a70e076910cc7030b716df978ba7388d2 inherit pub_methods_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5499e9ccd4b3b435216f29960b4daa inherit pub_methods_class_i_input_stream_filter"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5499e9ccd4b3b435216f29960b4daa"></a>
<a class="el" href="class_stream.html">Stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSourceStream</b> ()</td></tr>
<tr class="separator:a9c5499e9ccd4b3b435216f29960b4daa inherit pub_methods_class_i_input_stream_filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; AsyncBufferedInputStream&lt; T, Stream &gt; &gt;</a></td></tr>
<tr class="memitem:a5fd47aef34551970c9a1d0394065af96 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd47aef34551970c9a1d0394065af96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadSafeRefCount</b> (bool noSet)</td></tr>
<tr class="separator:a5fd47aef34551970c9a1d0394065af96 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511b99f9237aa4a5ac8055f390a74f2f inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>isShared</b> () const</td></tr>
<tr class="separator:a511b99f9237aa4a5ac8055f390a74f2f inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305fc75c7eae34e09403ce57969017a3 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><b>getRefCount</b> () const</td></tr>
<tr class="separator:a305fc75c7eae34e09403ce57969017a3 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d8b5210a825cfa8f12a2bb67c7cb43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addRef</b> ()</td></tr>
<tr class="memdesc:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference count on the object. <br /></td></tr>
<tr class="separator:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c6fe7285f9893de37b621a26b6d44 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> ()</td></tr>
<tr class="separator:a1d4c6fe7285f9893de37b621a26b6d44 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab553a5c0da72072680a555885144abae inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab553a5c0da72072680a555885144abae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearLowestBit</b> ()</td></tr>
<tr class="separator:ab553a5c0da72072680a555885144abae inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3284aaaf878739b72b5167f8c29308f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_thread_safe_deque.html">ThreadSafeDeque</a>&lt; <a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a3284aaaf878739b72b5167f8c29308f4">ElementList</a></td></tr>
<tr class="separator:a3284aaaf878739b72b5167f8c29308f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a576a7d0cb2fb563a86f1c8344cbed69e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a576a7d0cb2fb563a86f1c8344cbed69e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a576a7d0cb2fb563a86f1c8344cbed69e">_requestNext</a> ()=0</td></tr>
<tr class="memdesc:a576a7d0cb2fb563a86f1c8344cbed69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the next element from the underlying stream. <br /></td></tr>
<tr class="separator:a576a7d0cb2fb563a86f1c8344cbed69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ad2c7fd80bf0282e4e5dd00f237687"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ad2c7fd80bf0282e4e5dd00f237687"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#ad7ad2c7fd80bf0282e4e5dd00f237687">_onArrival</a> (const <a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a> &amp;element)</td></tr>
<tr class="memdesc:ad7ad2c7fd80bf0282e4e5dd00f237687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an element read has been completed on the underlying stream. <br /></td></tr>
<tr class="separator:ad7ad2c7fd80bf0282e4e5dd00f237687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae7503aedacb7a2a60af153d7b7284ef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#ae7503aedacb7a2a60af153d7b7284ef4">mIsLooping</a></td></tr>
<tr class="separator:ae7503aedacb7a2a60af153d7b7284ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a34b0ae64498431c863459a072b40c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#ab1a34b0ae64498431c863459a072b40c">mIsStopped</a></td></tr>
<tr class="separator:ab1a34b0ae64498431c863459a072b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dc677e46a043fdef71671db43364f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78dc677e46a043fdef71671db43364f1"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a78dc677e46a043fdef71671db43364f1">mNumRemainingSourceElements</a></td></tr>
<tr class="memdesc:a78dc677e46a043fdef71671db43364f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of source elements remaining in the source stream. <br /></td></tr>
<tr class="separator:a78dc677e46a043fdef71671db43364f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793fcd87372916857c17512ae9c6a159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793fcd87372916857c17512ae9c6a159"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a793fcd87372916857c17512ae9c6a159">mNumBufferedElements</a></td></tr>
<tr class="memdesc:a793fcd87372916857c17512ae9c6a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements currently on buffer list. <br /></td></tr>
<tr class="separator:a793fcd87372916857c17512ae9c6a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef2bc8c8a5a6b29a998e4097dc5a4e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ef2bc8c8a5a6b29a998e4097dc5a4e7"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a1ef2bc8c8a5a6b29a998e4097dc5a4e7">mMaxBufferedElements</a></td></tr>
<tr class="memdesc:a1ef2bc8c8a5a6b29a998e4097dc5a4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of elements allowed on buffer list. <br /></td></tr>
<tr class="separator:a1ef2bc8c8a5a6b29a998e4097dc5a4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0365dbd58c3cc4473064ec3243e257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf0365dbd58c3cc4473064ec3243e257"></a>
<a class="el" href="class_async_buffered_input_stream.html#a3284aaaf878739b72b5167f8c29308f4">ElementList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#abf0365dbd58c3cc4473064ec3243e257">mBufferedElements</a></td></tr>
<tr class="memdesc:abf0365dbd58c3cc4473064ec3243e257"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of buffered elements. <br /></td></tr>
<tr class="separator:abf0365dbd58c3cc4473064ec3243e257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6015a132910c44559aaae4ca3d774f8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6015a132910c44559aaae4ca3d774f8b"></a>
<a class="el" href="class_thread_pool.html">ThreadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a6015a132910c44559aaae4ca3d774f8b">mThreadPool</a></td></tr>
<tr class="memdesc:a6015a132910c44559aaae4ca3d774f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread pool to which read items are queued. <br /></td></tr>
<tr class="separator:a6015a132910c44559aaae4ca3d774f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928cfd9f95b44d60e54bf4fc1d808016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a928cfd9f95b44d60e54bf4fc1d808016"></a>
<a class="el" href="class_thread_pool_1_1_context.html">ThreadContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_buffered_input_stream.html#a928cfd9f95b44d60e54bf4fc1d808016">mThreadContext</a></td></tr>
<tr class="memdesc:a928cfd9f95b44d60e54bf4fc1d808016"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread context used for prioritizing read items in the pool. <br /></td></tr>
<tr class="separator:a928cfd9f95b44d60e54bf4fc1d808016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; AsyncBufferedInputStream&lt; T, Stream &gt; &gt;</a></td></tr>
<tr class="memitem:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedac4d209d114fbc1e72cba1daaf1bcd"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_safe_ref_count.html#aedac4d209d114fbc1e72cba1daaf1bcd">mRefCount</a></td></tr>
<tr class="memdesc:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference count and claim bit. Note that this increments in steps of two. <br /></td></tr>
<tr class="separator:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af6e1fbc4c5086d85c8dd01614b0a09f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e1fbc4c5086d85c8dd01614b0a09f1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncBufferedReadItem&lt; T, Stream &gt;</b></td></tr>
<tr class="separator:af6e1fbc4c5086d85c8dd01614b0a09f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; AsyncBufferedInputStream&lt; T, Stream &gt; &gt;</a></td></tr>
<tr class="memitem:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65ad1a5bcded320ceb4bd9fcaf753627"></a>
static <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>safeRead</b> (<a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt; *const volatile &amp;refPtr)</td></tr>
<tr class="memdesc:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a reference-counted pointer in a multi-thread safe way. <br /></td></tr>
<tr class="separator:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; AsyncBufferedInputStream&lt; T, Stream &gt; &gt;</a></td></tr>
<tr class="memitem:a15bb4ef12117f1bd3b01e6edbbb2b297 inherit pro_static_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">static U32&#160;</td><td class="memItemRight" valign="bottom"><b>decrementAndTestAndSet</b> (U32 &amp;refCount)</td></tr>
<tr class="separator:a15bb4ef12117f1bd3b01e6edbbb2b297 inherit pro_static_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3284aaaf878739b72b5167f8c29308f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_thread_safe_deque.html">ThreadSafeDeque</a>&lt; <a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a> &gt; <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::<a class="el" href="class_async_buffered_input_stream.html#a3284aaaf878739b72b5167f8c29308f4">ElementList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_stream.html" title="Base stream class for streaming data across a specific media. ">Stream</a> elements are kept on deques that can be concurrently accessed by multiple threads. </p>

</div>
</div>
<a class="anchor" id="abc11f322d098d4b5a17ad6b7478e2d0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Parent::SourceElementType <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::<a class="el" href="class_async_buffered_input_stream.html#abc11f322d098d4b5a17ad6b7478e2d0b">SourceElementType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of elements being read from the source stream.</p>
<dl class="section note"><dt>Note</dt><dd>This does not need to correspond to the type of elements buffered in this stream. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a082b08e164f884c9970842e1efe17b43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a082b08e164f884c9970842e1efe17b43a8b844f8e4a553a9e6d347412fa1beb77"></a>DEFAULT_STREAM_LOOKAHEAD&#160;</td><td class="fielddoc">
<p>The number of elements to buffer in advance by default. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c40ee936e2a777b5cfe2b73edf336d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Stream&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::<a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numSourceElementsToRead</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numReadAhead</em> = <code><a class="el" href="class_async_buffered_input_stream.html#a082b08e164f884c9970842e1efe17b43a8b844f8e4a553a9e6d347412fa1beb77">DEFAULT_STREAM_LOOKAHEAD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLooping</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_thread_pool.html">ThreadPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code>&amp;<a class="el" href="class_thread_pool.html#a1550a848c845e18e232de06b53a809e0">ThreadPool::GLOBAL</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_thread_pool_1_1_context.html">ThreadContext</a> *&#160;</td>
          <td class="paramname"><em>context</em> = <code><a class="el" href="class_thread_pool_1_1_context.html#a395f88a662265ff1eac88a351687de0a">ThreadContext::ROOT_CONTEXT</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a new buffered stream reading from "source".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The source stream from which to read the actual data elements. </td></tr>
    <tr><td class="paramname">numSourceElementsToRead</td><td>Total number of elements to read from "stream". </td></tr>
    <tr><td class="paramname">numReadAhead</td><td>Number of packets to read and buffer in advance. </td></tr>
    <tr><td class="paramname">isLooping</td><td>If true, the packet stream will loop infinitely over the source stream. </td></tr>
    <tr><td class="paramname">pool</td><td>The <a class="el" href="class_thread_pool.html">ThreadPool</a> to use for asynchronous packet reads. </td></tr>
    <tr><td class="paramname">context</td><td>The ThreadContext to place asynchronous packet reads in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9eac8bdc6eef9b7f2f74ba7954bb75f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::getReadAhead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of elements that will be read and buffered in advance. </dd></dl>

</div>
</div>
<a class="anchor" id="adebe059e8973bfab26f0b68a0f93a807"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::isLooping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the stream is looping infinitely. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3175f1121dbddd43f74fa4f6f3ea05e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_input_stream.html#a6484777b477cd938e322477779fc39fa">ElementType</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the next "num" elements into "buffer".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer into which the elements are stored. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements actually read; this may be less than "num" or even zero if no elements are available or reading failed. </dd></dl>

<p>Implements <a class="el" href="class_i_input_stream.html#a4240f54609af6c1f65ea229cbe729d85">IInputStream&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1b864cb19c6aaff17ad112d88da1e7c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call for the request chain of the element stream to stop at the next synchronization point. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae7503aedacb7a2a60af153d7b7284ef4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::mIsLooping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If true, the stream will restart over from the beginning once it has been read in entirety. </p>

</div>
</div>
<a class="anchor" id="ab1a34b0ae64498431c863459a072b40c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Stream = IInputStream&lt; T &gt;*&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_async_buffered_input_stream.html">AsyncBufferedInputStream</a>&lt; T, <a class="el" href="class_stream.html">Stream</a> &gt;::mIsStopped</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If true, no further requests should be issued on this stream. </p><dl class="section note"><dt>Note</dt><dd>This in itself doesn't say anything about pending requests. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/torque3d-qw64q/Engine/source/platform/async/<a class="el" href="async_buffered_stream_8h_source.html">asyncBufferedStream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
