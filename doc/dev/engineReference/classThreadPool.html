<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ThreadPool Class Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="modules.html">Modules</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" target="_blank" href="http://www.garagegames.com/documentation/torque-3d">Online</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER --><!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Asynchronous work manager.  
 <a href="classThreadPool.html#details">More...</a></p>

<p><code>#include &lt;platform/threads/threadPool.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ThreadPool:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classThreadPool__inherit__graph.png" border="0" usemap="#ThreadPool_inherit__map" alt="Inheritance graph"/></div>
<map name="ThreadPool_inherit__map" id="ThreadPool_inherit__map">
<area shape="rect" id="node2" href="classSFXInternal_1_1SFXThreadPool.html" title="Thread pool for sound I/O. " alt="" coords="5,80,192,107"/>
<area shape="rect" id="node3" href="structThreadPool_1_1GlobalThreadPool.html" title="ThreadPool::GlobalThreadPool" alt="" coords="216,80,413,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classThreadPool.html" title="Asynchronous work manager. ">ThreadPool</a> context defines a logical context in which WorkItems are being executed.  <a href="classThreadPool_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool_1_1GlobalThreadPool.html">GlobalThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An action to execute on a worker thread from the pool.  <a href="classThreadPool_1_1WorkItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c0f2e19b143a07cc17f3642bc0e1208"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classThreadSafeRef.html">ThreadSafeRef</a>&lt; <a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a9c0f2e19b143a07cc17f3642bc0e1208">WorkItemPtr</a></td></tr>
<tr class="separator:a9c0f2e19b143a07cc17f3642bc0e1208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a99d15ea72503a319e8da8ae6a5162c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a2a99d15ea72503a319e8da8ae6a5162c">ThreadPool</a> (const char *name, U32 numThreads=0)</td></tr>
<tr class="memdesc:a2a99d15ea72503a319e8da8ae6a5162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread pool with the given number of worker threads.  <a href="#a2a99d15ea72503a319e8da8ae6a5162c">More...</a><br /></td></tr>
<tr class="separator:a2a99d15ea72503a319e8da8ae6a5162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3d2ab618970605e684efc216655eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a44d3d2ab618970605e684efc216655eb">~ThreadPool</a> ()</td></tr>
<tr class="separator:a44d3d2ab618970605e684efc216655eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5204259e6c900d767786a5e1d1e3bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ad5204259e6c900d767786a5e1d1e3bc0">flushWorkItems</a> (S32 timeOut=-1)</td></tr>
<tr class="memdesc:ad5204259e6c900d767786a5e1d1e3bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>For the global pool, it is very important to only ever call this function on the main thread and to let work items only ever come from the main thread. </em> <a href="#ad5204259e6c900d767786a5e1d1e3bc0">More...</a><br /></td></tr>
<tr class="separator:ad5204259e6c900d767786a5e1d1e3bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298ababb630db39383e3d99df2c7b0a9"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a298ababb630db39383e3d99df2c7b0a9">getQueueTimeBasedPriorityBoost</a> () const </td></tr>
<tr class="memdesc:a298ababb630db39383e3d99df2c7b0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the priority increment applied to work items on each passing of the update interval.  <a href="#a298ababb630db39383e3d99df2c7b0a9">More...</a><br /></td></tr>
<tr class="separator:a298ababb630db39383e3d99df2c7b0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e4f22950e19827c33f2192aa4a28b8"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ad8e4f22950e19827c33f2192aa4a28b8">getQueueUpdateInterval</a> () const </td></tr>
<tr class="memdesc:ad8e4f22950e19827c33f2192aa4a28b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interval in which item priorities are updated on the queue.  <a href="#ad8e4f22950e19827c33f2192aa4a28b8">More...</a><br /></td></tr>
<tr class="separator:ad8e4f22950e19827c33f2192aa4a28b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5479bc24b4b605ff870a99bed8fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#aa0e5479bc24b4b605ff870a99bed8fcc">queueWorkItem</a> (<a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> *item)</td></tr>
<tr class="separator:aa0e5479bc24b4b605ff870a99bed8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ea729c3cde2081d0589306e353ff46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ae9ea729c3cde2081d0589306e353ff46">setQueueTimeBasedPriorityBoost</a> (F32 value)</td></tr>
<tr class="memdesc:ae9ea729c3cde2081d0589306e353ff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority increment applied to work items on each update interval.  <a href="#ae9ea729c3cde2081d0589306e353ff46">More...</a><br /></td></tr>
<tr class="separator:ae9ea729c3cde2081d0589306e353ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3d6218972e13b768ca5c9f2e94c049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#acd3d6218972e13b768ca5c9f2e94c049">setQueueUpdateInterval</a> (U32 milliSeconds)</td></tr>
<tr class="memdesc:acd3d6218972e13b768ca5c9f2e94c049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the update interval of the work item queue to the given value.  <a href="#acd3d6218972e13b768ca5c9f2e94c049">More...</a><br /></td></tr>
<tr class="separator:acd3d6218972e13b768ca5c9f2e94c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465c5f0162edf2b529e473b5873494eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a465c5f0162edf2b529e473b5873494eb">shutdown</a> ()</td></tr>
<tr class="memdesc:a465c5f0162edf2b529e473b5873494eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually shutdown threads outside of static destructors.  <a href="#a465c5f0162edf2b529e473b5873494eb">More...</a><br /></td></tr>
<tr class="separator:a465c5f0162edf2b529e473b5873494eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af458a3973346b630360da961d7e1373f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#af458a3973346b630360da961d7e1373f">waitForAllItems</a> (S32 timeOut=-1)</td></tr>
<tr class="memdesc:af458a3973346b630360da961d7e1373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you're using a non-global thread pool to parallelise some work, you may want to block until all the parallel work is complete.  <a href="#af458a3973346b630360da961d7e1373f">More...</a><br /></td></tr>
<tr class="separator:af458a3973346b630360da961d7e1373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1281072ad77a90afe309e84d3ad87218"><td class="memItemLeft" align="right" valign="top">static bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a1281072ad77a90afe309e84d3ad87218">getForceAllMainThread</a> ()</td></tr>
<tr class="separator:a1281072ad77a90afe309e84d3ad87218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f44dcacda4cdaa66bebca0e6c919c6"><td class="memItemLeft" align="right" valign="top">static U32 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ab3f44dcacda4cdaa66bebca0e6c919c6">getMainThreadThresholdTimeMS</a> ()</td></tr>
<tr class="separator:ab3f44dcacda4cdaa66bebca0e6c919c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1550a848c845e18e232de06b53a809e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a1550a848c845e18e232de06b53a809e0">GLOBAL</a> ()</td></tr>
<tr class="memdesc:a1550a848c845e18e232de06b53a809e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global thread pool singleton.  <a href="#a1550a848c845e18e232de06b53a809e0">More...</a><br /></td></tr>
<tr class="separator:a1550a848c845e18e232de06b53a809e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ed5c55905f58a04a017e29680ce57e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ab7ed5c55905f58a04a017e29680ce57e">processMainThreadWorkItems</a> ()</td></tr>
<tr class="memdesc:ab7ed5c55905f58a04a017e29680ce57e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classProcess.html" title="Event generation signal. ">Process</a> work items waiting on the main thread's work queue.  <a href="#ab7ed5c55905f58a04a017e29680ce57e">More...</a><br /></td></tr>
<tr class="separator:ab7ed5c55905f58a04a017e29680ce57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf86f0491869ce46b916fc26bc72340a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#aaf86f0491869ce46b916fc26bc72340a">queueWorkItemOnMainThread</a> (<a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> *item)</td></tr>
<tr class="memdesc:aaf86f0491869ce46b916fc26bc72340a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a work item to the main thread's work queue.  <a href="#aaf86f0491869ce46b916fc26bc72340a">More...</a><br /></td></tr>
<tr class="separator:aaf86f0491869ce46b916fc26bc72340a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ab73f8fc38da9d66c33ff30dfb122cba2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structThreadSafePriorityQueueWithUpdate.html">ThreadSafePriorityQueueWithUpdate</a>&lt; WorkItemWrapper, F32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">QueueType</a></td></tr>
<tr class="separator:ab73f8fc38da9d66c33ff30dfb122cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae1e0376c8208cc9773c06da2f31b708d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classString.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#ae1e0376c8208cc9773c06da2f31b708d">mName</a></td></tr>
<tr class="memdesc:ae1e0376c8208cc9773c06da2f31b708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this pool. Mainly for debugging. Used to name worker threads.  <a href="#ae1e0376c8208cc9773c06da2f31b708d">More...</a><br /></td></tr>
<tr class="separator:ae1e0376c8208cc9773c06da2f31b708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552ada6e357d9ee536a1a5cd61a2576f"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a552ada6e357d9ee536a1a5cd61a2576f">mNumPendingItems</a></td></tr>
<tr class="memdesc:a552ada6e357d9ee536a1a5cd61a2576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of work items that have not yet completed execution.  <a href="#a552ada6e357d9ee536a1a5cd61a2576f">More...</a><br /></td></tr>
<tr class="separator:a552ada6e357d9ee536a1a5cd61a2576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7605e992d865b12a5a2cf9f229dbf1"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#adf7605e992d865b12a5a2cf9f229dbf1">mNumThreads</a></td></tr>
<tr class="memdesc:adf7605e992d865b12a5a2cf9f229dbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads spawned by the pool.  <a href="#adf7605e992d865b12a5a2cf9f229dbf1">More...</a><br /></td></tr>
<tr class="separator:adf7605e992d865b12a5a2cf9f229dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897f6ae854bae84b00450443e759f3d0"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a897f6ae854bae84b00450443e759f3d0">mNumThreadsAwake</a></td></tr>
<tr class="memdesc:a897f6ae854bae84b00450443e759f3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads in non-sleeping state.  <a href="#a897f6ae854bae84b00450443e759f3d0">More...</a><br /></td></tr>
<tr class="separator:a897f6ae854bae84b00450443e759f3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70efa781292b81756c81e6712f30a137"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a70efa781292b81756c81e6712f30a137">mNumThreadsReady</a></td></tr>
<tr class="memdesc:a70efa781292b81756c81e6712f30a137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads guaranteed to be non-blocking.  <a href="#a70efa781292b81756c81e6712f30a137">More...</a><br /></td></tr>
<tr class="separator:a70efa781292b81756c81e6712f30a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836623a8086cc4926fc0e94519c395de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSemaphore.html">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a836623a8086cc4926fc0e94519c395de">mSemaphore</a></td></tr>
<tr class="memdesc:a836623a8086cc4926fc0e94519c395de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSemaphore.html">Semaphore</a> used to wake up threads, if necessary.  <a href="#a836623a8086cc4926fc0e94519c395de">More...</a><br /></td></tr>
<tr class="separator:a836623a8086cc4926fc0e94519c395de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a876ca7b2f38f2160324a7ff55a821d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreadPool.html#aa71780675ced446a1f4ebf8dab48f246">WorkerThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a5a876ca7b2f38f2160324a7ff55a821d">mThreads</a></td></tr>
<tr class="memdesc:a5a876ca7b2f38f2160324a7ff55a821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of worker threads.  <a href="#a5a876ca7b2f38f2160324a7ff55a821d">More...</a><br /></td></tr>
<tr class="separator:a5a876ca7b2f38f2160324a7ff55a821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25264ee60d81f23a3f5583123142a4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a25264ee60d81f23a3f5583123142a4c0">mWorkItemQueue</a></td></tr>
<tr class="memdesc:a25264ee60d81f23a3f5583123142a4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded priority queue for concurrent access by worker threads.  <a href="#a25264ee60d81f23a3f5583123142a4c0">More...</a><br /></td></tr>
<tr class="separator:a25264ee60d81f23a3f5583123142a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1ab2eeb4433747912e52a9572c8ddf51"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a1ab2eeb4433747912e52a9572c8ddf51">smForceAllMainThread</a></td></tr>
<tr class="memdesc:a1ab2eeb4433747912e52a9572c8ddf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force all work items to execute on main thread; turns this into a single-threaded system.  <a href="#a1ab2eeb4433747912e52a9572c8ddf51">More...</a><br /></td></tr>
<tr class="separator:a1ab2eeb4433747912e52a9572c8ddf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993e6e1f0ef65cc22cc42ead78b210d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a993e6e1f0ef65cc22cc42ead78b210d2">smMainThreadQueue</a></td></tr>
<tr class="memdesc:a993e6e1f0ef65cc22cc42ead78b210d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work queue for main thread; can be used to ping back work items to main thread that need processing that can only happen on main thread.  <a href="#a993e6e1f0ef65cc22cc42ead78b210d2">More...</a><br /></td></tr>
<tr class="separator:a993e6e1f0ef65cc22cc42ead78b210d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ab6169c69d188217f9ac604151e614"><td class="memItemLeft" align="right" valign="top">static U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreadPool.html#a52ab6169c69d188217f9ac604151e614">smMainThreadTimeMS</a></td></tr>
<tr class="separator:a52ab6169c69d188217f9ac604151e614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous work manager. </p>
<p><a class="el" href="classThread.html">Thread</a> pooling allows to submit work items for background execution. Each work item will be placed on a queue and, based on a total priority ordering, executed when it has the highest priority and a worker thread becomes available.</p>
<dl class="section note"><dt>Note</dt><dd>The global pool maintains the invariant that only the main thread may submit items in order to be able to flush the item queue reliably from the main thread itself. If other threads were issuing items to the queue, the queue may never empty out and the main thread will deadlock.</dd></dl>
<p>Flushing is the simplest method to guarantee that no asynchronous operation is pending in a specific case (deletion of the target object being the most common case). However, when possible, avoid this situation and design your work items to operate independently, e.g. by having only a single point of access to data that may have disappeared in the meantime and putting a check around that single access so that the item will silently die when its target object has disappeared.</p>
<p>The cleanest safe solution to this is to create a separate concurrently reference-counted structure that holds all interfacing state and functionality shared between a work item and its issueing code. This way the host object can safely disappear with the interfacing structure automatically being released once the last concurrent work item has been processed or discarded. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab73f8fc38da9d66c33ff30dfb122cba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structThreadSafePriorityQueueWithUpdate.html">ThreadSafePriorityQueueWithUpdate</a>&lt; WorkItemWrapper, F32 &gt; <a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">ThreadPool::QueueType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c0f2e19b143a07cc17f3642bc0e1208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classThreadSafeRef.html">ThreadSafeRef</a>&lt; <a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> &gt; <a class="el" href="classThreadPool.html#a9c0f2e19b143a07cc17f3642bc0e1208">ThreadPool::WorkItemPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2a99d15ea72503a319e8da8ae6a5162c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread pool with the given number of worker threads. </p>
<p>If numThreads is zero (the default), the number of threads created will be based on the number of CPU cores available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numThreads</td><td>Number of threads to create or zero for default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44d3d2ab618970605e684efc216655eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5204259e6c900d767786a5e1d1e3bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::flushWorkItems </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>For the global pool, it is very important to only ever call this function on the main thread and to let work items only ever come from the main thread. </em></p>
<p>Otherwise this function has the potential of dead-locking as new work items may constantly be fed to the queue without it ever getting empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOut</td><td>Soft limit on the number of milliseconds to wait for the queue to flush out. -1 = infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1281072ad77a90afe309e84d3ad87218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool&amp; ThreadPool::getForceAllMainThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classThreadPool.html#a1550a848c845e18e232de06b53a809e0">GLOBAL()</a>, and <a class="el" href="classThreadPool.html#a1ab2eeb4433747912e52a9572c8ddf51">smForceAllMainThread</a>.</p>

</div>
</div>
<a class="anchor" id="ab3f44dcacda4cdaa66bebca0e6c919c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static U32&amp; ThreadPool::getMainThreadThresholdTimeMS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classThreadPool.html#a52ab6169c69d188217f9ac604151e614">smMainThreadTimeMS</a>.</p>

</div>
</div>
<a class="anchor" id="a298ababb630db39383e3d99df2c7b0a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">F32 ThreadPool::getQueueTimeBasedPriorityBoost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the priority increment applied to work items on each passing of the update interval. </p>

</div>
</div>
<a class="anchor" id="ad8e4f22950e19827c33f2192aa4a28b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::getQueueUpdateInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the interval in which item priorities are updated on the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>update interval in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a1550a848c845e18e232de06b53a809e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadPool.html">ThreadPool</a> &amp; ThreadPool::GLOBAL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the global thread pool singleton. </p>

<p>References <a class="el" href="classManagedSingleton.html#ac70e2f7a9d9e7acfa711efc15a5571fb">ManagedSingleton&lt; GlobalThreadPool &gt;::instance()</a>.</p>

<p>Referenced by <a class="el" href="classAsyncPacketBufferedInputStream.html#af7f1df87d0fcb4aa25dd217811451ff8">AsyncPacketBufferedInputStream&lt; SFXStreamRef, SFXStreamPacket &gt;::_newReadItem()</a>, and <a class="el" href="classThreadPool.html#a1281072ad77a90afe309e84d3ad87218">getForceAllMainThread()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ed5c55905f58a04a017e29680ce57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ThreadPool::processMainThreadWorkItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classProcess.html" title="Event generation signal. ">Process</a> work items waiting on the main thread's work queue. </p>
<p>There is a soft limit imposed on the time this method is allowed to run so as to balance frame-to-frame load. However, work items, once their processing is initiated, will not be suspended and will run for as long as they take to complete, so make sure individual items perform as little work as necessary.</p>
<dl class="section see"><dt>See also</dt><dd>ThreadPool::getMainThreadThesholdTimeMS </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e5479bc24b4b605ff870a99bed8fcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::queueWorkItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classAsyncSingleBufferedInputStream.html#a11cfaf3857cfb2aed8bb2e3bc0431544">AsyncSingleBufferedInputStream&lt; T, Stream, ReadItem &gt;::_requestNext()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf86f0491869ce46b916fc26bc72340a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ThreadPool::queueWorkItemOnMainThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThreadPool_1_1WorkItem.html">WorkItem</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a work item to the main thread's work queue. </p>
<p>The main thread's work queue will be processed each frame using a set timeout to limit the work being done. Nonetheless, work items will not be suspended in-midst of processing, so make sure that whatever work you issue to the main thread is light work or you may see short hangs in gameplay.</p>
<p>To reiterate this: any code executed through this interface directly adds to frame processing time on the main thread.</p>
<p>This method <em>may</em> (and is meant to) be called from threads other than the main thread. </p>

</div>
</div>
<a class="anchor" id="ae9ea729c3cde2081d0589306e353ff46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::setQueueTimeBasedPriorityBoost </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the priority increment applied to work items on each update interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Priority increment. Set to zero to deactivate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd3d6218972e13b768ca5c9f2e94c049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::setQueueUpdateInterval </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>milliSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the update interval of the work item queue to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliSeconds</td><td>Time between updates in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a465c5f0162edf2b529e473b5873494eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually shutdown threads outside of static destructors. </p>

</div>
</div>
<a class="anchor" id="af458a3973346b630360da961d7e1373f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::waitForAllItems </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you're using a non-global thread pool to parallelise some work, you may want to block until all the parallel work is complete. </p>
<p>As with flushWorkItems, this method may block indefinitely if new items keep getting added to the pool before old ones finish.</p>
<p><em>This method will not wait for items queued on the main thread using queueWorkItemOnMainThread!</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOut</td><td>Soft limit on the number of milliseconds to wait for all items to complete. -1 = infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae1e0376c8208cc9773c06da2f31b708d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classString.html">String</a> ThreadPool::mName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of this pool. Mainly for debugging. Used to name worker threads. </p>

</div>
</div>
<a class="anchor" id="a552ada6e357d9ee536a1a5cd61a2576f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::mNumPendingItems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of work items that have not yet completed execution. </p>

</div>
</div>
<a class="anchor" id="adf7605e992d865b12a5a2cf9f229dbf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::mNumThreads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of worker threads spawned by the pool. </p>

</div>
</div>
<a class="anchor" id="a897f6ae854bae84b00450443e759f3d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::mNumThreadsAwake</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of worker threads in non-sleeping state. </p>

</div>
</div>
<a class="anchor" id="a70efa781292b81756c81e6712f30a137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::mNumThreadsReady</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of worker threads guaranteed to be non-blocking. </p>

</div>
</div>
<a class="anchor" id="a836623a8086cc4926fc0e94519c395de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSemaphore.html">Semaphore</a> ThreadPool::mSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSemaphore.html">Semaphore</a> used to wake up threads, if necessary. </p>

</div>
</div>
<a class="anchor" id="a5a876ca7b2f38f2160324a7ff55a821d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadPool.html#aa71780675ced446a1f4ebf8dab48f246">WorkerThread</a>* ThreadPool::mThreads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of worker threads. </p>

</div>
</div>
<a class="anchor" id="a25264ee60d81f23a3f5583123142a4c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">QueueType</a> ThreadPool::mWorkItemQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded priority queue for concurrent access by worker threads. </p>

</div>
</div>
<a class="anchor" id="a1ab2eeb4433747912e52a9572c8ddf51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::smForceAllMainThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force all work items to execute on main thread; turns this into a single-threaded system. </p>
<p>Primarily useful to find whether malfunctions are caused by parallel execution or not. </p>

<p>Referenced by <a class="el" href="classThreadPool.html#a1281072ad77a90afe309e84d3ad87218">getForceAllMainThread()</a>.</p>

</div>
</div>
<a class="anchor" id="a993e6e1f0ef65cc22cc42ead78b210d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreadPool.html#ab73f8fc38da9d66c33ff30dfb122cba2">QueueType</a> ThreadPool::smMainThreadQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Work queue for main thread; can be used to ping back work items to main thread that need processing that can only happen on main thread. </p>

</div>
</div>
<a class="anchor" id="a52ab6169c69d188217f9ac604151e614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::smMainThreadTimeMS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classThreadPool.html#ab3f44dcacda4cdaa66bebca0e6c919c6">getMainThreadThresholdTimeMS()</a>.</p>

</div>
</div>
</div><!-- contents -->

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
