<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: ThreadSafePriorityQueue&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a></li><li class="navelem"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="struct_thread_safe_priority_queue_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadSafePriorityQueue&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="thread_safe_priority_queue_8h_source.html">threadSafePriorityQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ThreadSafePriorityQueue&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node:</div>
<div class="dyncontent">
<div class="center"><img src="struct_thread_safe_priority_queue_1_1_node__inherit__graph.png" border="0" usemap="#_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_inherit__map" alt="Inheritance graph"/></div>
<map name="_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_inherit__map" id="_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_inherit__map">
<area shape="rect" id="node2" href="class_thread_safe_ref_count.html" title="ThreadSafeRefCount\l\&lt; Node \&gt;" alt="" coords="38,5,178,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ThreadSafePriorityQueue&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node:</div>
<div class="dyncontent">
<div class="center"><img src="struct_thread_safe_priority_queue_1_1_node__coll__graph.png" border="0" usemap="#_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_coll__map" alt="Collaboration graph"/></div>
<map name="_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_coll__map" id="_thread_safe_priority_queue_3_01_t_00_01_k_00_01_s_o_r_t___m_i_n___t_o___m_a_x_00_01_m_a_x___l_e_v_e_l_00_01_p_r_o_b_a_b_i_l_i_s_t_i_c___b_i_a_s_01_4_1_1_node_coll__map">
<area shape="rect" id="node2" href="class_thread_safe_ref_count.html" title="ThreadSafeRefCount\l\&lt; Node \&gt;" alt="" coords="38,5,178,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3bcb6d941a6bfef279c13d6bba224c23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcb6d941a6bfef279c13d6bba224c23"></a>
typedef <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount</a>&lt; <a class="el" href="struct_thread_safe_priority_queue_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:a3bcb6d941a6bfef279c13d6bba224c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; Node &gt;</a></td></tr>
<tr class="memitem:ad77f7e5171e301e340eea6e3451ca1df inherit pub_types_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77f7e5171e301e340eea6e3451ca1df"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="separator:ad77f7e5171e301e340eea6e3451ca1df inherit pub_types_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a390efe5059fa3d03194d2b445673d0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a390efe5059fa3d03194d2b445673d0e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (KeyType priority, const ValueType &amp;value)</td></tr>
<tr class="separator:a390efe5059fa3d03194d2b445673d0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086426db8d9e3e7e0a4f3c6ad004c4ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a086426db8d9e3e7e0a4f3c6ad004c4ba"></a>
KeyType&#160;</td><td class="memItemRight" valign="bottom"><b>getPriority</b> ()</td></tr>
<tr class="separator:a086426db8d9e3e7e0a4f3c6ad004c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad87fc589c3a1b05118ccf2bdb525621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad87fc589c3a1b05118ccf2bdb525621"></a>
ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getValue</b> ()</td></tr>
<tr class="separator:aad87fc589c3a1b05118ccf2bdb525621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc7f54f79b94ee12ca0dd8d894d6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4bc7f54f79b94ee12ca0dd8d894d6da"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#ac4bc7f54f79b94ee12ca0dd8d894d6da">getLevel</a> ()</td></tr>
<tr class="memdesc:ac4bc7f54f79b94ee12ca0dd8d894d6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the skip list level the node is at. <br /></td></tr>
<tr class="separator:ac4bc7f54f79b94ee12ca0dd8d894d6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f3b5fda908ec2d910d19864bfed3e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_thread_safe_ref.html">NodePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#aa2f3b5fda908ec2d910d19864bfed3e4">getNext</a> (U32 level)</td></tr>
<tr class="separator:aa2f3b5fda908ec2d910d19864bfed3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0aae62d3406831839705ad95da4be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a0aae62d3406831839705ad95da4be7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#a4a0aae62d3406831839705ad95da4be7">isMarkedForDeletion</a> ()</td></tr>
<tr class="memdesc:a4a0aae62d3406831839705ad95da4be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node is marked to be deleted. <br /></td></tr>
<tr class="separator:a4a0aae62d3406831839705ad95da4be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f82ae53cd0c6a2475f9a17f32b97385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#a2f82ae53cd0c6a2475f9a17f32b97385">tryMarkForDeletion</a> ()</td></tr>
<tr class="separator:a2f82ae53cd0c6a2475f9a17f32b97385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474b6adbab2ced2bf1851f482e51b83a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a474b6adbab2ced2bf1851f482e51b83a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearValue</b> ()</td></tr>
<tr class="separator:a474b6adbab2ced2bf1851f482e51b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae277551554c7dff6190da5838c706096"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#ae277551554c7dff6190da5838c706096">operator new</a> (size_t size, S32 level=-1)</td></tr>
<tr class="separator:ae277551554c7dff6190da5838c706096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2316222a7098e86fdc970dfbfe7085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#a3d2316222a7098e86fdc970dfbfe7085">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a3d2316222a7098e86fdc970dfbfe7085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; Node &gt;</a></td></tr>
<tr class="memitem:a5fd47aef34551970c9a1d0394065af96 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd47aef34551970c9a1d0394065af96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadSafeRefCount</b> (bool noSet)</td></tr>
<tr class="separator:a5fd47aef34551970c9a1d0394065af96 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511b99f9237aa4a5ac8055f390a74f2f inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>isShared</b> () const</td></tr>
<tr class="separator:a511b99f9237aa4a5ac8055f390a74f2f inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305fc75c7eae34e09403ce57969017a3 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><b>getRefCount</b> () const</td></tr>
<tr class="separator:a305fc75c7eae34e09403ce57969017a3 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d8b5210a825cfa8f12a2bb67c7cb43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addRef</b> ()</td></tr>
<tr class="memdesc:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference count on the object. <br /></td></tr>
<tr class="separator:a24d8b5210a825cfa8f12a2bb67c7cb43 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c6fe7285f9893de37b621a26b6d44 inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> ()</td></tr>
<tr class="separator:a1d4c6fe7285f9893de37b621a26b6d44 inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab553a5c0da72072680a555885144abae inherit pub_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab553a5c0da72072680a555885144abae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearLowestBit</b> ()</td></tr>
<tr class="separator:ab553a5c0da72072680a555885144abae inherit pub_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2b4fcf37bf32e1b7df819759f8b73e41"><td class="memItemLeft" align="right" valign="top">static U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_safe_priority_queue_1_1_node.html#a2b4fcf37bf32e1b7df819759f8b73e41">randomLevel</a> ()</td></tr>
<tr class="separator:a2b4fcf37bf32e1b7df819759f8b73e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; Node &gt;</a></td></tr>
<tr class="memitem:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65ad1a5bcded320ceb4bd9fcaf753627"></a>
static Node *&#160;</td><td class="memItemRight" valign="bottom"><b>safeRead</b> (Node *const volatile &amp;refPtr)</td></tr>
<tr class="memdesc:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a reference-counted pointer in a multi-thread safe way. <br /></td></tr>
<tr class="separator:a65ad1a5bcded320ceb4bd9fcaf753627 inherit pub_static_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; Node &gt;</a></td></tr>
<tr class="memitem:a15bb4ef12117f1bd3b01e6edbbb2b297 inherit pro_static_methods_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top">static U32&#160;</td><td class="memItemRight" valign="bottom"><b>decrementAndTestAndSet</b> (U32 &amp;refCount)</td></tr>
<tr class="separator:a15bb4ef12117f1bd3b01e6edbbb2b297 inherit pro_static_methods_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_thread_safe_ref_count"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_thread_safe_ref_count')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_thread_safe_ref_count.html">ThreadSafeRefCount&lt; Node &gt;</a></td></tr>
<tr class="memitem:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedac4d209d114fbc1e72cba1daaf1bcd"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_safe_ref_count.html#aedac4d209d114fbc1e72cba1daaf1bcd">mRefCount</a></td></tr>
<tr class="memdesc:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference count and claim bit. Note that this increments in steps of two. <br /></td></tr>
<tr class="separator:aedac4d209d114fbc1e72cba1daaf1bcd inherit pro_attribs_class_thread_safe_ref_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename K = F32, bool SORT_MIN_TO_MAX = false, U32 MAX_LEVEL = 4, U32 PROBABILISTIC_BIAS = 50&gt;<br />
struct ThreadSafePriorityQueue&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node</h3>

<p>A queue node.</p>
<p>Nodes are reference-counted to coordinate memory management between the different threads. Reclamation happens on the thread that releases the last reference.</p>
<p>Reference-counting and deletion requests are kept separate. A given node is marked for deletion and will then have its references progressively disappear and eventually be reclaimed once the reference count drops to zero.</p>
<p>Note that 'Next' references are released by the destructor which is only called when the reference count to the node itself drops to zero. This is to avoid threads getting trapped in a node with no link out. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa2f3b5fda908ec2d910d19864bfed3e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , bool SORT_MIN_TO_MAX, U32 MAX_LEVEL, U32 PROBABILISTIC_BIAS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::<a class="el" href="class_thread_safe_ref.html">NodePtr</a> &amp; <a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node::getNext </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the successor node at the given level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level of the desired successor node; must be within the node's level bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d2316222a7098e86fdc970dfbfe7085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , bool SORT_MIN_TO_MAX, U32 MAX_LEVEL, U32 PROBABILISTIC_BIAS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reclaim a node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to reclaim. Must refer to a <a class="el" href="struct_thread_safe_priority_queue_1_1_node.html">Node</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae277551554c7dff6190da5838c706096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , bool SORT_MIN_TO_MAX, U32 MAX_LEVEL, U32 PROBABILISTIC_BIAS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new node. The node comes with a reference count of one and its level already set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level to allocate the node at. If this is -1, a random level is chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new node. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b4fcf37bf32e1b7df819759f8b73e41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , bool SORT_MIN_TO_MAX, U32 MAX_LEVEL, U32 PROBABILISTIC_BIAS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node::randomLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choose a random level.</p>
<p>The chosen level depends on the given PROBABILISTIC_BIAS and MAX_LEVEL, but is not affected by the actual number of nodes in a queue. </p>

</div>
</div>
<a class="anchor" id="a2f82ae53cd0c6a2475f9a17f32b97385"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K , bool SORT_MIN_TO_MAX, U32 MAX_LEVEL, U32 PROBABILISTIC_BIAS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_safe_priority_queue.html">ThreadSafePriorityQueue</a>&lt; T, K, SORT_MIN_TO_MAX, MAX_LEVEL, PROBABILISTIC_BIAS &gt;::Node::tryMarkForDeletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to mark the node for deletion. If the mark bit has not yet been set and setting it on the current thread succeeds, returns true.</p>
<dl class="section return"><dt>Returns</dt><dd>true, if the marking succeeded. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/projects/torque3d-qw64q/Engine/source/platform/threads/<a class="el" href="thread_safe_priority_queue_8h_source.html">threadSafePriorityQueue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
