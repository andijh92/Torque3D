<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: MathUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">MathUtils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous math utility functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_math_utils_1_1_intersect_info.html">IntersectInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="namespace_math_utils.html#a11137f2229ddb8570ef11c0c68d1ab2c" title="Returns the distance between a point and triangle &#39;abc&#39;. ">mTriangleDistance()</a> to pass along collision info.  <a href="struct_math_utils_1_1_intersect_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_math_utils_1_1_line.html">Line</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to define a line.  <a href="struct_math_utils_1_1_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_math_utils_1_1_line_segment.html">LineSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to define a line segment.  <a href="struct_math_utils_1_1_line_segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_math_utils_1_1_quad.html">Quad</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_math_utils_1_1_quad_sort_point.html">QuadSortPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5dd642fe2fdecc388667610dcd26a532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dd642fe2fdecc388667610dcd26a532"></a>
typedef <a class="el" href="struct_math_utils_1_1_line.html">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a></td></tr>
<tr class="memdesc:a5dd642fe2fdecc388667610dcd26a532"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ray is also a line. <br /></td></tr>
<tr class="separator:a5dd642fe2fdecc388667610dcd26a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b3daa831a64b47e2d6bb0a07d22bcb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a9b3daa831a64b47e2d6bb0a07d22bcb3">capsuleCapsuleOverlap</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;a1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;b1, F32 rad1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;a2, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;b2, F32 rad2)</td></tr>
<tr class="separator:a9b3daa831a64b47e2d6bb0a07d22bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0c7a7814a5e625e6ad48220a81e49"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a6ce0c7a7814a5e625e6ad48220a81e49">segmentSegmentNearest</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;q1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p2, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;q2, F32 &amp;s, F32 &amp;t, <a class="el" href="class_point3_f.html">Point3F</a> &amp;c1, <a class="el" href="class_point3_f.html">Point3F</a> &amp;c2)</td></tr>
<tr class="separator:a6ce0c7a7814a5e625e6ad48220a81e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b569dd52dbaa608c9e7954ae5b426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a7a7b569dd52dbaa608c9e7954ae5b426">capsuleSphereNearestOverlap</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;A0, const <a class="el" href="class_point3_f.html">Point3F</a> A1, F32 radA, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;B, F32 radB, F32 &amp;t)</td></tr>
<tr class="separator:a7a7b569dd52dbaa608c9e7954ae5b426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3122473cfd09b0860f4cc8e4555bc4fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a3122473cfd09b0860f4cc8e4555bc4fb">vectorRotateZAxis</a> (<a class="el" href="class_point3_f.html">Point3F</a> &amp;vector, F32 radians)</td></tr>
<tr class="memdesc:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the passed vector around the world-z axis by the passed radians. <br /></td></tr>
<tr class="separator:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88453c8514422af6715e8a7d30443eee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88453c8514422af6715e8a7d30443eee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vectorRotateZAxis</b> (F32 radians, <a class="el" href="class_point3_f.html">Point3F</a> *vectors, U32 count)</td></tr>
<tr class="separator:a88453c8514422af6715e8a7d30443eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c088bb1dd0276a02c388d490457a2cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a0c088bb1dd0276a02c388d490457a2cf">getZBiasProjectionMatrix</a> (F32 bias, const <a class="el" href="class_frustum.html">Frustum</a> &amp;frustum, <a class="el" href="class_matrix_f.html">MatrixF</a> *outMat, bool rotate)</td></tr>
<tr class="separator:a0c088bb1dd0276a02c388d490457a2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac389f4ebfe61ab816696f310d6551b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac389f4ebfe61ab816696f310d6551b32"></a>
<a class="el" href="class_matrix_f.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ac389f4ebfe61ab816696f310d6551b32">createOrientFromDir</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;direction)</td></tr>
<tr class="memdesc:ac389f4ebfe61ab816696f310d6551b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates orientation matrix from a direction vector. Assumes ( 0 0 1 ) is up. <br /></td></tr>
<tr class="separator:ac389f4ebfe61ab816696f310d6551b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cec655954009e3be9ea519053645cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a7cec655954009e3be9ea519053645cf3">getMatrixFromUpVector</a> (const <a class="el" href="class_point3_f.html">VectorF</a> &amp;up, <a class="el" href="class_matrix_f.html">MatrixF</a> *outMat)</td></tr>
<tr class="separator:a7cec655954009e3be9ea519053645cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a1452c6905026a655d6a588965c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a7a6a1452c6905026a655d6a588965c8f">getMatrixFromForwardVector</a> (const <a class="el" href="class_point3_f.html">VectorF</a> &amp;forward, <a class="el" href="class_matrix_f.html">MatrixF</a> *outMat)</td></tr>
<tr class="separator:a7a6a1452c6905026a655d6a588965c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86990de026b4d63f854576d62ade48f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a86990de026b4d63f854576d62ade48f7">randomDir</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;axis, F32 thetaAngleMin, F32 thetaAngleMax, F32 phiAngleMin, F32 phiAngleMax)</td></tr>
<tr class="separator:a86990de026b4d63f854576d62ade48f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191f3093e4a41f12eecf99f69d293752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a191f3093e4a41f12eecf99f69d293752">randomPointInSphere</a> (F32 radius)</td></tr>
<tr class="separator:a191f3093e4a41f12eecf99f69d293752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc627fff58f05ce1beb143ef0b7c5f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point2_f.html">Point2F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#abc627fff58f05ce1beb143ef0b7c5f90">randomPointInCircle</a> (F32 radius)</td></tr>
<tr class="separator:abc627fff58f05ce1beb143ef0b7c5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d70f8d68205d739d500c033ae81277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a64d70f8d68205d739d500c033ae81277">getAnglesFromVector</a> (const <a class="el" href="class_point3_f.html">VectorF</a> &amp;vec, F32 &amp;yawAng, F32 &amp;pitchAng)</td></tr>
<tr class="separator:a64d70f8d68205d739d500c033ae81277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824186c39acfc5d2cd9859e68bf39a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ad824186c39acfc5d2cd9859e68bf39a3">getVectorFromAngles</a> (<a class="el" href="class_point3_f.html">VectorF</a> &amp;vec, F32 yawAng, F32 pitchAng)</td></tr>
<tr class="separator:ad824186c39acfc5d2cd9859e68bf39a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47200320e4e7753b240dd1c27a872e2a"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a47200320e4e7753b240dd1c27a872e2a">getAngleBetweenVectors</a> (<a class="el" href="class_point3_f.html">VectorF</a> vecA, <a class="el" href="class_point3_f.html">VectorF</a> vecB)</td></tr>
<tr class="separator:a47200320e4e7753b240dd1c27a872e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa968abb769df46d2b7d873d759802123"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#aa968abb769df46d2b7d873d759802123">getSignedAngleBetweenVectors</a> (<a class="el" href="class_point3_f.html">VectorF</a> vecA, <a class="el" href="class_point3_f.html">VectorF</a> vecB, <a class="el" href="class_point3_f.html">VectorF</a> norm)</td></tr>
<tr class="separator:aa968abb769df46d2b7d873d759802123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe5544b3534cb6ecee99739850755f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fe5544b3534cb6ecee99739850755f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a5fe5544b3534cb6ecee99739850755f4">transformBoundingBox</a> (const <a class="el" href="class_box3_f.html">Box3F</a> &amp;sbox, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;mat, const <a class="el" href="class_point3_f.html">Point3F</a> scale, <a class="el" href="class_box3_f.html">Box3F</a> &amp;dbox)</td></tr>
<tr class="memdesc:a5fe5544b3534cb6ecee99739850755f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform bounding box making sure to keep original box entirely contained. <br /></td></tr>
<tr class="separator:a5fe5544b3534cb6ecee99739850755f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602a8e076327a242acaa18bee414f4dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a602a8e076327a242acaa18bee414f4dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mProjectWorldToScreen</b> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;in, <a class="el" href="class_point3_f.html">Point3F</a> *out, const <a class="el" href="class_rect_i.html">RectI</a> &amp;view, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;world, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;projection)</td></tr>
<tr class="separator:a602a8e076327a242acaa18bee414f4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6926d24b2e85fcecc7b6bbf37335d4c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6926d24b2e85fcecc7b6bbf37335d4c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mProjectWorldToScreen</b> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;in, <a class="el" href="class_point3_f.html">Point3F</a> *out, const <a class="el" href="class_rect_i.html">RectI</a> &amp;view, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;worldProjection)</td></tr>
<tr class="separator:a6926d24b2e85fcecc7b6bbf37335d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2dbfb02c83511631d1b5babb7decec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e2dbfb02c83511631d1b5babb7decec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mProjectScreenToWorld</b> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;in, <a class="el" href="class_point3_f.html">Point3F</a> *out, const <a class="el" href="class_rect_i.html">RectI</a> &amp;view, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;world, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;projection, F32 zfar, F32 znear)</td></tr>
<tr class="separator:a0e2dbfb02c83511631d1b5babb7decec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260dc9225e4c1059f0176834f6cbf840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a260dc9225e4c1059f0176834f6cbf840">pointInPolygon</a> (const <a class="el" href="class_point2_f.html">Point2F</a> *verts, U32 vertCount, const <a class="el" href="class_point2_f.html">Point2F</a> &amp;testPt)</td></tr>
<tr class="separator:a260dc9225e4c1059f0176834f6cbf840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11137f2229ddb8570ef11c0c68d1ab2c"></a>
F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a11137f2229ddb8570ef11c0c68d1ab2c">mTriangleDistance</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;a, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;b, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;c, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p, <a class="el" href="struct_math_utils_1_1_intersect_info.html">IntersectInfo</a> *info=NULL)</td></tr>
<tr class="memdesc:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between a point and triangle 'abc'. <br /></td></tr>
<tr class="separator:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1bdae12d21c01fa11be3e4bc44895e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a9a1bdae12d21c01fa11be3e4bc44895e">mTriangleNormal</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;a, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;b, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;c)</td></tr>
<tr class="separator:a9a1bdae12d21c01fa11be3e4bc44895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ebf9ba8053323cd463d32e393a156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a0a4ebf9ba8053323cd463d32e393a156">mClosestPointOnSegment</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;a, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;b, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p)</td></tr>
<tr class="separator:a0a4ebf9ba8053323cd463d32e393a156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d265f7766c3421708fb3bb4486c1afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a3d265f7766c3421708fb3bb4486c1afc">mShortestSegmentBetweenLines</a> (const <a class="el" href="struct_math_utils_1_1_line.html">Line</a> &amp;line0, const <a class="el" href="struct_math_utils_1_1_line.html">Line</a> &amp;line1, <a class="el" href="struct_math_utils_1_1_line_segment.html">LineSegment</a> *outSegment)</td></tr>
<tr class="separator:a3d265f7766c3421708fb3bb4486c1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1868a42f377f78fe3d43f509a5621ae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1868a42f377f78fe3d43f509a5621ae8"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a1868a42f377f78fe3d43f509a5621ae8">greatestCommonDivisor</a> (U32 u, U32 v)</td></tr>
<tr class="memdesc:a1868a42f377f78fe3d43f509a5621ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest common divisor of two positive integers. <br /></td></tr>
<tr class="separator:a1868a42f377f78fe3d43f509a5621ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae875d7780bb21261787cab4d1152651a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ae875d7780bb21261787cab4d1152651a">mLineTriangleCollide</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;p2, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;t1, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;t2, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;t3, <a class="el" href="class_point3_f.html">Point3F</a> *outUVW, F32 *outT)</td></tr>
<tr class="separator:ae875d7780bb21261787cab4d1152651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ef6dde6ca3fdbe1ef3e663674d5778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a43ef6dde6ca3fdbe1ef3e663674d5778">mRayQuadCollide</a> (const <a class="el" href="struct_math_utils_1_1_quad.html">Quad</a> &amp;quad, const <a class="el" href="namespace_math_utils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a> &amp;ray, <a class="el" href="class_point2_f.html">Point2F</a> *outUV, F32 *outT)</td></tr>
<tr class="separator:a43ef6dde6ca3fdbe1ef3e663674d5778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa061357e84a3aa30a46b7560a7080224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa061357e84a3aa30a46b7560a7080224"></a>
S32 QSORT_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><b>cmpAngleAscending</b> (const void *a, const void *b)</td></tr>
<tr class="separator:aa061357e84a3aa30a46b7560a7080224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7104523e7c4fb9d94fc46c5812c91c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b7104523e7c4fb9d94fc46c5812c91c"></a>
S32 QSORT_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><b>cmpAngleDescending</b> (const void *a, const void *b)</td></tr>
<tr class="separator:a2b7104523e7c4fb9d94fc46c5812c91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65cc13fb2ac1b66d07cdcf92c0cad25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ae65cc13fb2ac1b66d07cdcf92c0cad25">sortQuadWindingOrder</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;quadMat, bool clockwise, const <a class="el" href="class_point3_f.html">Point3F</a> *verts, U32 *vertMap, U32 count)</td></tr>
<tr class="separator:ae65cc13fb2ac1b66d07cdcf92c0cad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc1cc9eae809b05afe077a6953acf88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#aebc1cc9eae809b05afe077a6953acf88">sortQuadWindingOrder</a> (bool clockwise, const <a class="el" href="class_point3_f.html">Point3F</a> *verts, U32 *vertMap, U32 count)</td></tr>
<tr class="separator:aebc1cc9eae809b05afe077a6953acf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87ed2416d92fc1f83ea006742c5a58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#af87ed2416d92fc1f83ea006742c5a58f">buildMatrix</a> (const <a class="el" href="class_point3_f.html">VectorF</a> *rvec, const <a class="el" href="class_point3_f.html">VectorF</a> *fvec, const <a class="el" href="class_point3_f.html">VectorF</a> *uvec, const <a class="el" href="class_point3_f.html">VectorF</a> *pos, <a class="el" href="class_matrix_f.html">MatrixF</a> *outMat)</td></tr>
<tr class="separator:af87ed2416d92fc1f83ea006742c5a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a01616d3939903f96d9f4fc38c74f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a01616d3939903f96d9f4fc38c74f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>reduceFrustum</b> (const <a class="el" href="class_frustum.html">Frustum</a> &amp;frustum, const <a class="el" href="class_rect_i.html">RectI</a> &amp;viewport, const <a class="el" href="class_rect_f.html">RectF</a> &amp;area, <a class="el" href="class_frustum.html">Frustum</a> &amp;outFrustum)</td></tr>
<tr class="separator:a36a01616d3939903f96d9f4fc38c74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65570815e13b8e2219a117820724ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae65570815e13b8e2219a117820724ba7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ae65570815e13b8e2219a117820724ba7">makeFrustum</a> (F32 *outLeft, F32 *outRight, F32 *outTop, F32 *outBottom, F32 fovYInRadians, F32 aspectRatio, F32 nearPlane)</td></tr>
<tr class="memdesc:ae65570815e13b8e2219a117820724ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the frustum near plane dimensions from the parameters. <br /></td></tr>
<tr class="separator:ae65570815e13b8e2219a117820724ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee85d4ec4970b21d72017ed68d8c0c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#aee85d4ec4970b21d72017ed68d8c0c31">makeProjection</a> (<a class="el" href="class_matrix_f.html">MatrixF</a> *outMatrix, F32 fovYInRadians, F32 aspectRatio, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="separator:aee85d4ec4970b21d72017ed68d8c0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e3d0178cd7aecc2bb3abffbf94f2c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71e3d0178cd7aecc2bb3abffbf94f2c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeFovPortFrustum</b> (<a class="el" href="class_frustum.html">Frustum</a> *outFrustum, bool isOrtho, F32 nearDist, F32 farDist, const <a class="el" href="struct_fov_port.html">FovPort</a> &amp;inPort, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;transform)</td></tr>
<tr class="separator:a71e3d0178cd7aecc2bb3abffbf94f2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d99ebbae72f402afddf1ec233ca1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a62d99ebbae72f402afddf1ec233ca1c9">makeProjection</a> (<a class="el" href="class_matrix_f.html">MatrixF</a> *outMatrix, F32 left, F32 right, F32 top, F32 bottom, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="separator:a62d99ebbae72f402afddf1ec233ca1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac307a2ceb7d95252dcd726d01c08aaf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ac307a2ceb7d95252dcd726d01c08aaf0">makeOrthoProjection</a> (<a class="el" href="class_matrix_f.html">MatrixF</a> *outMatrix, F32 left, F32 right, F32 top, F32 bottom, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="separator:ac307a2ceb7d95252dcd726d01c08aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5bb9616837c363e7c71d4456c1bf48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a4c5bb9616837c363e7c71d4456c1bf48">edgeFaceIntersect</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;edgeA, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;edgeB, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;faceA, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;faceB, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;faceC, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;faceD, <a class="el" href="class_point3_f.html">Point3F</a> *intersection)</td></tr>
<tr class="separator:a4c5bb9616837c363e7c71d4456c1bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88eeb14df080acf0012f938b26e0b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#aa88eeb14df080acf0012f938b26e0b83">isPlanarPolygon</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *vertices, U32 numVertices)</td></tr>
<tr class="separator:aa88eeb14df080acf0012f938b26e0b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cca7c205482c4d7485c55a2f3a7ce6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a9cca7c205482c4d7485c55a2f3a7ce6d">isConvexPolygon</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *vertices, U32 numVertices)</td></tr>
<tr class="separator:a9cca7c205482c4d7485c55a2f3a7ce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113cb6faa0d914457b67c058af3f428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ab113cb6faa0d914457b67c058af3f428">clipFrustumByPolygon</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *points, U32 numPoints, const <a class="el" href="class_rect_i.html">RectI</a> &amp;viewport, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;world, const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;projection, const <a class="el" href="class_frustum.html">Frustum</a> &amp;inFrustum, const <a class="el" href="class_frustum.html">Frustum</a> &amp;rootFrustum, <a class="el" href="class_frustum.html">Frustum</a> &amp;outFrustum)</td></tr>
<tr class="separator:ab113cb6faa0d914457b67c058af3f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1fcc28cca391419f78fac6f7f0c5ccb"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ae1fcc28cca391419f78fac6f7f0c5ccb">extrudePolygonEdges</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *vertices, U32 numVertices, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;direction, <a class="el" href="class_plane_f.html">PlaneF</a> *outPlanes)</td></tr>
<tr class="memdesc:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrude the given polygon along the given direction. <br /></td></tr>
<tr class="separator:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b96771d044bb177cfa138f83a9c42"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a7a4b96771d044bb177cfa138f83a9c42">extrudePolygonEdgesFromPoint</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *vertices, U32 numVertices, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;fromPoint, <a class="el" href="class_plane_f.html">PlaneF</a> *outPlanes)</td></tr>
<tr class="separator:a7a4b96771d044bb177cfa138f83a9c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157b973c3d634c9e8ab0c02883383637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a157b973c3d634c9e8ab0c02883383637">mBuildHull2D</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_point2_f.html">Point2F</a> &gt; inPoints, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_point2_f.html">Point2F</a> &gt; &amp;hullPoints)</td></tr>
<tr class="memdesc:a157b973c3d634c9e8ab0c02883383637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a convex hull from a cloud of 2D points, first and last hull point are the same.  <a href="#a157b973c3d634c9e8ab0c02883383637">More...</a><br /></td></tr>
<tr class="separator:a157b973c3d634c9e8ab0c02883383637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cce22be05e355d56fd4bcee7640060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9cce22be05e355d56fd4bcee7640060"></a>
<a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#ab9cce22be05e355d56fd4bcee7640060">reflect</a> (<a class="el" href="class_point3_f.html">Point3F</a> &amp;inVec, <a class="el" href="class_point3_f.html">Point3F</a> &amp;norm)</td></tr>
<tr class="memdesc:ab9cce22be05e355d56fd4bcee7640060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple reflection equation - pass in a vector and a normal to reflect off of. <br /></td></tr>
<tr class="separator:ab9cce22be05e355d56fd4bcee7640060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6">removeShortPolygonEdges</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *verts, U32 vertCount, F32 epsilon)</td></tr>
<tr class="separator:a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b543160ec7ce76d9663ce114187c126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b543160ec7ce76d9663ce114187c126"></a>
<a class="el" href="class_m_random_l_c_g.html">MRandomLCG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_math_utils.html#a7b543160ec7ce76d9663ce114187c126">sgRandom</a> (0xdeadbeef)</td></tr>
<tr class="memdesc:a7b543160ec7ce76d9663ce114187c126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our random number generator. <br /></td></tr>
<tr class="separator:a7b543160ec7ce76d9663ce114187c126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous math utility functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af87ed2416d92fc1f83ea006742c5a58f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::buildMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>fvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WORK IN PROGRESS</p>
<p>Creates an orthonormal basis matrix from one, two, or three unit length input vectors. If more than one input vector is provided they must be mutually perpendicular.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvec</td><td>Optional unit length right vector. </td></tr>
    <tr><td class="paramname">fvec</td><td>Optional unit length forward vector. </td></tr>
    <tr><td class="paramname">uvec</td><td>Optional unit length up vector. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional position to initialize the matrix. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>
<p>Work in Progress </p>

</div>
</div>
<a class="anchor" id="a9b3daa831a64b47e2d6bb0a07d22bcb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::capsuleCapsuleOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collide two capsules (sphere swept lines) against each other, reporting only if they intersect or not. Based on routine from "Real Time Collision Detection" by Christer Ericson pp 114. </p>

</div>
</div>
<a class="anchor" id="a7a7b569dd52dbaa608c9e7954ae5b426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::capsuleSphereNearestOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a>&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return capsule-sphere overlap. Returns time of first overlap, where time is viewed as a sphere of radius radA moving from point A0 to A1. </p>

</div>
</div>
<a class="anchor" id="ab113cb6faa0d914457b67c058af3f428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::clipFrustumByPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rect_i.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_frustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>inFrustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_frustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>rootFrustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_frustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>outFrustum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clip <em>inFrustum</em> by the given polygon.</p>
<dl class="section note"><dt>Note</dt><dd>The input polygon is limited to 58 vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Polygon vertices. </td></tr>
    <tr><td class="paramname">numPoints</td><td>Number of vertices in <em>points</em>. </td></tr>
    <tr><td class="paramname">viewport</td><td>Screen viewport. Note that this corresponds to the root frustum and not necessarily to <em>inFrustum</em>. </td></tr>
    <tr><td class="paramname">world</td><td>World-&gt;view transform. </td></tr>
    <tr><td class="paramname">projection</td><td>Projection matrix. </td></tr>
    <tr><td class="paramname">inFrustum</td><td><a class="el" href="class_frustum.html">Frustum</a> to clip. </td></tr>
    <tr><td class="paramname">rootFrustum</td><td><a class="el" href="class_frustum.html">Frustum</a> corresponding to <em>viewport</em>. </td></tr>
    <tr><td class="paramname">outFrustum</td><td>Resulting clipped frustum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the frustum was successfully clipped and <em>outFrustum</em> is valid, false otherwise (if, for example, the input polygon is completely outside <em>inFrustum</em>). </dd></dl>

</div>
</div>
<a class="anchor" id="a4c5bb9616837c363e7c71d4456c1bf48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::edgeFaceIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the intersection of the line going from <em>edgeA</em> to <em>edgeB</em> with the triangle given by <em>faceA</em>, <em>faceB</em>, and <em>faceC</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeA</td><td>Starting point of edge. </td></tr>
    <tr><td class="paramname">edgeB</td><td>End point of edge. </td></tr>
    <tr><td class="paramname">faceA</td><td>First vertex of triangle. </td></tr>
    <tr><td class="paramname">faceB</td><td>Second vertex of triangle. </td></tr>
    <tr><td class="paramname">faceC</td><td>Third vertex of triangle. </td></tr>
    <tr><td class="paramname">intersection</td><td>If there is an intersection, the point of intersection on the triangle's face is stored here. </td></tr>
    <tr><td class="paramname">True</td><td>if there is an intersection, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a4b96771d044bb177cfa138f83a9c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::extrudePolygonEdgesFromPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>fromPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_plane_f.html">PlaneF</a> *&#160;</td>
          <td class="paramname"><em>outPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extrude the edges of the given polygon away from <em>fromPoint</em> by constructing a set of planes that each go through <em>fromPoint</em> and a pair of vertices.</p>
<p>The resulting planes are in the same order as the vertices and have their normals facing <em>inwards</em>, i.e. the resulting volume will enclose the polygon's interior space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Vertices of the polygon in CCW or CW order (both are acceptable). </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
    <tr><td class="paramname">fromPoint</td><td></td></tr>
    <tr><td class="paramname">outPlanes</td><td>Array in which the resulting planes are stored. Must have room for at least as many planes are there are edges in the polygon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The input polygon does not necessarily need to be planar but it must be convex. </dd></dl>

</div>
</div>
<a class="anchor" id="a47200320e4e7753b240dd1c27a872e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::getAngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the angle between two given vectors</p>
<p>Angles is in RADIANS </p>

</div>
</div>
<a class="anchor" id="a64d70f8d68205d739d500c033ae81277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getAnglesFromVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>yawAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>pitchAng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns yaw and pitch angles from a given vector.</p>
<p>Angles are in RADIANS.</p>
<p>Assumes north is (0.0, 1.0, 0.0), the degrees move upwards clockwise.</p>
<p>The range of yaw is 0 - 2PI. The range of pitch is -PI/2 - PI/2.</p>
<p><b>ASSUMES Z AXIS IS UP</b> </p>

</div>
</div>
<a class="anchor" id="a7a6a1452c6905026a655d6a588965c8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getMatrixFromForwardVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an orthonormal basis matrix with the unit length input vector in column 1 (forward vector).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forward</td><td>The non-zero unit length forward vector. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cec655954009e3be9ea519053645cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getMatrixFromUpVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an orthonormal basis matrix with the unit length input vector in column 2 (up vector).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">up</td><td>The non-zero unit length up vector. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa968abb769df46d2b7d873d759802123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::getSignedAngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the angle between two given vectors, utilizing a normal vector to discertain the angle's sign</p>
<p>Angles is in RADIANS </p>

</div>
</div>
<a class="anchor" id="ad824186c39acfc5d2cd9859e68bf39a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getVectorFromAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>yawAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>pitchAng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns vector from given yaw and pitch angles.</p>
<p>Angles are in RADIANS.</p>
<p>Assumes north is (0.0, 1.0, 0.0), the degrees move upwards clockwise.</p>
<p>The range of yaw is 0 - 2PI. The range of pitch is -PI/2 - PI/2.</p>
<p><b>ASSUMES Z AXIS IS UP</b> </p>

</div>
</div>
<a class="anchor" id="a0c088bb1dd0276a02c388d490457a2cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getZBiasProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_frustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a projection matrix with the near plane moved forward by the bias amount. This function is a helper primarily for working around z-fighting issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bias</td><td>The amount to move the near plane forward. </td></tr>
    <tr><td class="paramname">frustum</td><td>The frustum to generate the new projection matrix from. </td></tr>
    <tr><td class="paramname">outMat</td><td>The resulting z-biased projection matrix. Note: It must be initialized before the call. </td></tr>
    <tr><td class="paramname">rotate</td><td>Optional parameter specifying whether to rotate the projection matrix similarly to <a class="el" href="class_g_f_x_device.html">GFXDevice</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cca7c205482c4d7485c55a2f3a7ce6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::isConvexPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out whether the given polygon is convex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices of the polygon. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is convex, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa88eeb14df080acf0012f938b26e0b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::isPlanarPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out whether the given polygon is planar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices of the polygon. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is planar, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac307a2ceb7d95252dcd726d01c08aaf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeOrthoProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build an orthographic projection matrix from the frustum near plane dimensions including the optional rotation required by GFX. </p>

</div>
</div>
<a class="anchor" id="aee85d4ec4970b21d72017ed68d8c0c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>fovYInRadians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a GFX projection matrix from the frustum parameters including the optional rotation required by GFX. </p>

</div>
</div>
<a class="anchor" id="a62d99ebbae72f402afddf1ec233ca1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix_f.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build a projection matrix from the frustum near plane dimensions including the optional rotation required by GFX. </p>

</div>
</div>
<a class="anchor" id="a157b973c3d634c9e8ab0c02883383637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::mBuildHull2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_point2_f.html">Point2F</a> &gt;&#160;</td>
          <td class="paramname"><em>_inPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_point2_f.html">Point2F</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hullPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a convex hull from a cloud of 2D points, first and last hull point are the same. </p>
<p>Andrew's monotone chain convex hull algorithm implementation </p>

</div>
</div>
<a class="anchor" id="a0a4ebf9ba8053323cd463d32e393a156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point3_f.html">Point3F</a> MathUtils::mClosestPointOnSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the closest point on the segment defined by points a, b to the point p. </p>

</div>
</div>
<a class="anchor" id="ae875d7780bb21261787cab4d1152651a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mLineTriangleCollide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outUVW</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outT</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the barycentric coordinates and time of intersection between a line segment and a triangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first point of the line segment. </td></tr>
    <tr><td class="paramname">p2</td><td>The second point of the line segment. </td></tr>
    <tr><td class="paramname">t1</td><td>The first point of the triangle. </td></tr>
    <tr><td class="paramname">t2</td><td>The second point of the triangle. </td></tr>
    <tr><td class="paramname">t2</td><td>The third point of the triangle. </td></tr>
    <tr><td class="paramname">outUVW</td><td>The optional output barycentric coords. </td></tr>
    <tr><td class="paramname">outT</td><td>The optional output time of intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a collision occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a43ef6dde6ca3fdbe1ef3e663674d5778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mRayQuadCollide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_math_utils_1_1_quad.html">Quad</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_math_utils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point2_f.html">Point2F</a> *&#160;</td>
          <td class="paramname"><em>outUV</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outT</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the uv coords and time of intersection between a ray and a quad.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad</td><td>The quad. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray. </td></tr>
    <tr><td class="paramname">outUV</td><td>The optional output UV coords of the intersection. </td></tr>
    <tr><td class="paramname">outT</td><td>The optional output time of intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a collision occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d265f7766c3421708fb3bb4486c1afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::mShortestSegmentBetweenLines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_math_utils_1_1_line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>line0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_math_utils_1_1_line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>line1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_math_utils_1_1_line_segment.html">LineSegment</a> *&#160;</td>
          <td class="paramname"><em>outSegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the shortest line segment between two lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outSegment</td><td>The result where .p0 is the point on line0 and .p1 is the point on line1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a1bdae12d21c01fa11be3e4bc44895e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point3_f.html">Point3F</a> MathUtils::mTriangleNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the normal of the passed triangle 'abc'.</p>
<p>If we assume counter-clockwise triangle culling, normal will point out from the 'solid' side of the triangle. </p>

</div>
</div>
<a class="anchor" id="a260dc9225e4c1059f0176834f6cbf840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::pointInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point2_f.html">Point2F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_f.html">Point2F</a> &amp;&#160;</td>
          <td class="paramname"><em>testPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the test point is within the polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verts</td><td>The array of points which forms the polygon. </td></tr>
    <tr><td class="paramname">vertCount</td><td>The number of points in the polygon. </td></tr>
    <tr><td class="paramname">testPt</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86990de026b4d63f854576d62ade48f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point3_f.html">Point3F</a> MathUtils::randomDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>thetaAngleMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>thetaAngleMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>phiAngleMin</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>phiAngleMax</em> = <code>360.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates random direction given angle parameters similar to the particle system.</p>
<p>The angles are relative to the specified axis. Both phi and theta are in degrees. </p>

</div>
</div>
<a class="anchor" id="abc627fff58f05ce1beb143ef0b7c5f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point2_f.html">Point2F</a> MathUtils::randomPointInCircle </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random 2D point within a circle of the specified radius centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a191f3093e4a41f12eecf99f69d293752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_point3_f.html">Point3F</a> MathUtils::randomPointInSphere </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a random 3D point within a sphere of the specified radius centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::removeShortPolygonEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all edges from the given polygon that have a total length shorter than <em>epsilon</em>. </p>

</div>
</div>
<a class="anchor" id="a6ce0c7a7814a5e625e6ad48220a81e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::segmentSegmentNearest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersect two line segments (p1,q1) and (p2,q2), returning points on lines (c1 &amp; c2) and line parameters (s,t). Based on routine from "Real Time Collision Detection" by Christer Ericson pp 149. </p>

</div>
</div>
<a class="anchor" id="ae65cc13fb2ac1b66d07cdcf92c0cad25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::sortQuadWindingOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>quadMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clockwise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>vertMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the passed verts ( <a class="el" href="class_point3_f.html">Point3F</a> ) in a clockwise or counter-clockwise winding order. Verts must be co-planar and non-collinear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadMat</td><td>Transform matrix from vert space to quad space. </td></tr>
    <tr><td class="paramname">clockwise</td><td>Sort clockwise or counter-clockwise </td></tr>
    <tr><td class="paramname">verts</td><td>Array of <a class="el" href="class_point3_f.html">Point3F</a> verts. </td></tr>
    <tr><td class="paramname">vertMap</td><td>Output - Array of vert element ids sorted by winding order. </td></tr>
    <tr><td class="paramname">count</td><td>Element count of the verts and vertMap arrays which must be allocated prior to this call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebc1cc9eae809b05afe077a6953acf88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::sortQuadWindingOrder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clockwise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>vertMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above except we assume that the passed verts ( <a class="el" href="class_point3_f.html">Point3F</a> ) are already transformed into 'quad space'. If this was done correctly and the points are coplanar this means their z components will all be zero. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
