<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="thread_pool_8h_source.html">threadPool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ThreadPool:</div>
<div class="dyncontent">
<div class="center"><img src="class_thread_pool__inherit__graph.png" border="0" usemap="#_thread_pool_inherit__map" alt="Inheritance graph"/></div>
<map name="_thread_pool_inherit__map" id="_thread_pool_inherit__map">
<area shape="rect" id="node2" href="class_s_f_x_internal_1_1_s_f_x_thread_pool.html" title="SFXInternal::SFXThreadPool" alt="" coords="5,80,191,107"/>
<area shape="rect" id="node3" href="struct_thread_pool_1_1_global_thread_pool.html" title="ThreadPool::GlobalThreadPool" alt="" coords="215,80,413,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ThreadPool:</div>
<div class="dyncontent">
<div class="center"><img src="class_thread_pool__coll__graph.png" border="0" usemap="#_thread_pool_coll__map" alt="Collaboration graph"/></div>
<map name="_thread_pool_coll__map" id="_thread_pool_coll__map">
<area shape="rect" id="node2" href="class_string.html" title="The String class represents a 0&#45;terminated array of characters. " alt="" coords="1097,44,1153,71"/>
<area shape="rect" id="node3" href="class_semaphore.html" title="Semaphore" alt="" coords="232,116,320,143"/>
<area shape="rect" id="node11" href="class_platform_thread_data.html" title="PlatformThreadData" alt="" coords="447,145,583,172"/>
<area shape="rect" id="node4" href="class_platform_semaphore.html" title="PlatformSemaphore" alt="" coords="5,116,141,143"/>
<area shape="rect" id="node5" href="struct_thread_safe_priority_queue_with_update.html" title="ThreadSafePriorityQueueWith\lUpdate\&lt; WorkItemWrapper, F32 \&gt;" alt="" coords="1013,214,1236,255"/>
<area shape="rect" id="node6" href="struct_thread_safe_priority_queue.html" title="ThreadSafePriorityQueue\l\&lt; WorkItemWrapper, F32,\l false, 4, 50 \&gt;" alt="" coords="697,207,871,263"/>
<area shape="rect" id="node7" href="class_thread_safe_ref.html" title="ThreadSafeRef\&lt; Node \&gt;" alt="" coords="435,268,595,295"/>
<area shape="rect" id="node8" href="struct_thread_safe_priority_queue.html" title="ThreadSafePriorityQueue\l\&lt; ThreadSafeRef\&lt; Node\l \&gt;, TickType, true, 4, 50 \&gt;" alt="" coords="697,287,871,343"/>
<area shape="rect" id="node9" href="struct_thread_pool_1_1_worker_thread.html" title="ThreadPool::WorkerThread" alt="" coords="1037,148,1213,175"/>
<area shape="rect" id="node10" href="class_thread.html" title="Thread" alt="" coords="753,156,815,183"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool_1_1_context.html">Context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool_1_1_global_thread_pool.html">GlobalThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool_1_1_worker_thread.html">WorkerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool_1_1_work_item.html">WorkItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool_1_1_work_item_wrapper.html">WorkItemWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c0f2e19b143a07cc17f3642bc0e1208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0f2e19b143a07cc17f3642bc0e1208"></a>
typedef <a class="el" href="class_thread_safe_ref.html">ThreadSafeRef</a>&lt; <a class="el" href="class_thread_pool_1_1_work_item.html">WorkItem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WorkItemPtr</b></td></tr>
<tr class="separator:a9c0f2e19b143a07cc17f3642bc0e1208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a99d15ea72503a319e8da8ae6a5162c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a2a99d15ea72503a319e8da8ae6a5162c">ThreadPool</a> (const char *name, U32 numThreads=0)</td></tr>
<tr class="separator:a2a99d15ea72503a319e8da8ae6a5162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465c5f0162edf2b529e473b5873494eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a465c5f0162edf2b529e473b5873494eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a465c5f0162edf2b529e473b5873494eb">shutdown</a> ()</td></tr>
<tr class="memdesc:a465c5f0162edf2b529e473b5873494eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually shutdown threads outside of static destructors. <br /></td></tr>
<tr class="separator:a465c5f0162edf2b529e473b5873494eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5479bc24b4b605ff870a99bed8fcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0e5479bc24b4b605ff870a99bed8fcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>queueWorkItem</b> (<a class="el" href="class_thread_pool_1_1_work_item.html">WorkItem</a> *item)</td></tr>
<tr class="separator:aa0e5479bc24b4b605ff870a99bed8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5204259e6c900d767786a5e1d1e3bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#ad5204259e6c900d767786a5e1d1e3bc0">flushWorkItems</a> (S32 timeOut=-1)</td></tr>
<tr class="separator:ad5204259e6c900d767786a5e1d1e3bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af458a3973346b630360da961d7e1373f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#af458a3973346b630360da961d7e1373f">waitForAllItems</a> (S32 timeOut=-1)</td></tr>
<tr class="separator:af458a3973346b630360da961d7e1373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e4f22950e19827c33f2192aa4a28b8"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#ad8e4f22950e19827c33f2192aa4a28b8">getQueueUpdateInterval</a> () const </td></tr>
<tr class="separator:ad8e4f22950e19827c33f2192aa4a28b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298ababb630db39383e3d99df2c7b0a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a298ababb630db39383e3d99df2c7b0a9"></a>
F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a298ababb630db39383e3d99df2c7b0a9">getQueueTimeBasedPriorityBoost</a> () const </td></tr>
<tr class="memdesc:a298ababb630db39383e3d99df2c7b0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the priority increment applied to work items on each passing of the update interval. <br /></td></tr>
<tr class="separator:a298ababb630db39383e3d99df2c7b0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3d6218972e13b768ca5c9f2e94c049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#acd3d6218972e13b768ca5c9f2e94c049">setQueueUpdateInterval</a> (U32 milliSeconds)</td></tr>
<tr class="separator:acd3d6218972e13b768ca5c9f2e94c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ea729c3cde2081d0589306e353ff46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#ae9ea729c3cde2081d0589306e353ff46">setQueueTimeBasedPriorityBoost</a> (F32 value)</td></tr>
<tr class="separator:ae9ea729c3cde2081d0589306e353ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5060c6f0aecf491d92f3029ce9ab187"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#ad5060c6f0aecf491d92f3029ce9ab187">queueWorkItemOnMainThread</a> (<a class="el" href="class_thread_pool_1_1_work_item.html">WorkItem</a> *item)</td></tr>
<tr class="separator:ad5060c6f0aecf491d92f3029ce9ab187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c0975540842564b06c7e59360877d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a11c0975540842564b06c7e59360877d0">processMainThreadWorkItems</a> ()</td></tr>
<tr class="separator:a11c0975540842564b06c7e59360877d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f44dcacda4cdaa66bebca0e6c919c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f44dcacda4cdaa66bebca0e6c919c6"></a>
static U32 &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMainThreadThresholdTimeMS</b> ()</td></tr>
<tr class="separator:ab3f44dcacda4cdaa66bebca0e6c919c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1281072ad77a90afe309e84d3ad87218"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1281072ad77a90afe309e84d3ad87218"></a>
static bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getForceAllMainThread</b> ()</td></tr>
<tr class="separator:a1281072ad77a90afe309e84d3ad87218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1550a848c845e18e232de06b53a809e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1550a848c845e18e232de06b53a809e0"></a>
static <a class="el" href="class_thread_pool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a1550a848c845e18e232de06b53a809e0">GLOBAL</a> ()</td></tr>
<tr class="memdesc:a1550a848c845e18e232de06b53a809e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global thread pool singleton. <br /></td></tr>
<tr class="separator:a1550a848c845e18e232de06b53a809e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ab73f8fc38da9d66c33ff30dfb122cba2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab73f8fc38da9d66c33ff30dfb122cba2"></a>
typedef <a class="el" href="struct_thread_safe_priority_queue_with_update.html">ThreadSafePriorityQueueWithUpdate</a>&lt; <a class="el" href="struct_thread_pool_1_1_work_item_wrapper.html">WorkItemWrapper</a>, F32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>QueueType</b></td></tr>
<tr class="separator:ab73f8fc38da9d66c33ff30dfb122cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae1e0376c8208cc9773c06da2f31b708d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1e0376c8208cc9773c06da2f31b708d"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#ae1e0376c8208cc9773c06da2f31b708d">mName</a></td></tr>
<tr class="memdesc:ae1e0376c8208cc9773c06da2f31b708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this pool. Mainly for debugging. Used to name worker threads. <br /></td></tr>
<tr class="separator:ae1e0376c8208cc9773c06da2f31b708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7605e992d865b12a5a2cf9f229dbf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7605e992d865b12a5a2cf9f229dbf1"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#adf7605e992d865b12a5a2cf9f229dbf1">mNumThreads</a></td></tr>
<tr class="memdesc:adf7605e992d865b12a5a2cf9f229dbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads spawned by the pool. <br /></td></tr>
<tr class="separator:adf7605e992d865b12a5a2cf9f229dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897f6ae854bae84b00450443e759f3d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a897f6ae854bae84b00450443e759f3d0"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a897f6ae854bae84b00450443e759f3d0">mNumThreadsAwake</a></td></tr>
<tr class="memdesc:a897f6ae854bae84b00450443e759f3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads in non-sleeping state. <br /></td></tr>
<tr class="separator:a897f6ae854bae84b00450443e759f3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70efa781292b81756c81e6712f30a137"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70efa781292b81756c81e6712f30a137"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a70efa781292b81756c81e6712f30a137">mNumThreadsReady</a></td></tr>
<tr class="memdesc:a70efa781292b81756c81e6712f30a137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of worker threads guaranteed to be non-blocking. <br /></td></tr>
<tr class="separator:a70efa781292b81756c81e6712f30a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552ada6e357d9ee536a1a5cd61a2576f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a552ada6e357d9ee536a1a5cd61a2576f"></a>
U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a552ada6e357d9ee536a1a5cd61a2576f">mNumPendingItems</a></td></tr>
<tr class="memdesc:a552ada6e357d9ee536a1a5cd61a2576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of work items that have not yet completed execution. <br /></td></tr>
<tr class="separator:a552ada6e357d9ee536a1a5cd61a2576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836623a8086cc4926fc0e94519c395de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836623a8086cc4926fc0e94519c395de"></a>
<a class="el" href="class_semaphore.html">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a836623a8086cc4926fc0e94519c395de">mSemaphore</a></td></tr>
<tr class="memdesc:a836623a8086cc4926fc0e94519c395de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_semaphore.html">Semaphore</a> used to wake up threads, if necessary. <br /></td></tr>
<tr class="separator:a836623a8086cc4926fc0e94519c395de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25264ee60d81f23a3f5583123142a4c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25264ee60d81f23a3f5583123142a4c0"></a>
<a class="el" href="struct_thread_safe_priority_queue_with_update.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a25264ee60d81f23a3f5583123142a4c0">mWorkItemQueue</a></td></tr>
<tr class="memdesc:a25264ee60d81f23a3f5583123142a4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded priority queue for concurrent access by worker threads. <br /></td></tr>
<tr class="separator:a25264ee60d81f23a3f5583123142a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a876ca7b2f38f2160324a7ff55a821d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a876ca7b2f38f2160324a7ff55a821d"></a>
<a class="el" href="struct_thread_pool_1_1_worker_thread.html">WorkerThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a5a876ca7b2f38f2160324a7ff55a821d">mThreads</a></td></tr>
<tr class="memdesc:a5a876ca7b2f38f2160324a7ff55a821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of worker threads. <br /></td></tr>
<tr class="separator:a5a876ca7b2f38f2160324a7ff55a821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1ab2eeb4433747912e52a9572c8ddf51"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#a1ab2eeb4433747912e52a9572c8ddf51">smForceAllMainThread</a></td></tr>
<tr class="separator:a1ab2eeb4433747912e52a9572c8ddf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ab6169c69d188217f9ac604151e614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ab6169c69d188217f9ac604151e614"></a>
static U32&#160;</td><td class="memItemRight" valign="bottom"><b>smMainThreadTimeMS</b></td></tr>
<tr class="separator:a52ab6169c69d188217f9ac604151e614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2e0d50d09e3ae5c4c568ac414e6289"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_thread_safe_priority_queue_with_update.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_pool.html#abd2e0d50d09e3ae5c4c568ac414e6289">smMainThreadQueue</a></td></tr>
<tr class="separator:abd2e0d50d09e3ae5c4c568ac414e6289"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa71780675ced446a1f4ebf8dab48f246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71780675ced446a1f4ebf8dab48f246"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>WorkerThread</b></td></tr>
<tr class="separator:aa71780675ced446a1f4ebf8dab48f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous work manager.</p>
<p><a class="el" href="class_thread.html">Thread</a> pooling allows to submit work items for background execution. Each work item will be placed on a queue and, based on a total priority ordering, executed when it has the highest priority and a worker thread becomes available.</p>
<dl class="section note"><dt>Note</dt><dd>The global pool maintains the invariant that only the main thread may submit items in order to be able to flush the item queue reliably from the main thread itself. If other threads were issuing items to the queue, the queue may never empty out and the main thread will deadlock.</dd></dl>
<p>Flushing is the simplest method to guarantee that no asynchronous operation is pending in a specific case (deletion of the target object being the most common case). However, when possible, avoid this situation and design your work items to operate independently, e.g. by having only a single point of access to data that may have disappeared in the meantime and putting a check around that single access so that the item will silently die when its target object has disappeared.</p>
<p>The cleanest safe solution to this is to create a separate concurrently reference-counted structure that holds all interfacing state and functionality shared between a work item and its issueing code. This way the host object can safely disappear with the interfacing structure automatically being released once the last concurrent work item has been processed or discarded. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2a99d15ea72503a319e8da8ae6a5162c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new thread pool with the given number of worker threads.</p>
<p>If numThreads is zero (the default), the number of threads created will be based on the number of CPU cores available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numThreads</td><td>Number of threads to create or zero for default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5204259e6c900d767786a5e1d1e3bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::flushWorkItems </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>For the global pool, it is very important to only ever call this function on the main thread and to let work items only ever come from the main thread. Otherwise this function has the potential of dead-locking as new work items may constantly be fed to the queue without it ever getting empty.</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOut</td><td>Soft limit on the number of milliseconds to wait for the queue to flush out. -1 = infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8e4f22950e19827c33f2192aa4a28b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 ThreadPool::getQueueUpdateInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the interval in which item priorities are updated on the queue. </p><dl class="section return"><dt>Returns</dt><dd>update interval in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a11c0975540842564b06c7e59360877d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::processMainThreadWorkItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_process.html">Process</a> work items waiting on the main thread's work queue.</p>
<p>There is a soft limit imposed on the time this method is allowed to run so as to balance frame-to-frame load. However, work items, once their processing is initiated, will not be suspended and will run for as long as they take to complete, so make sure individual items perform as little work as necessary.</p>
<dl class="section see"><dt>See also</dt><dd>ThreadPool::getMainThreadThesholdTimeMS </dd></dl>

</div>
</div>
<a class="anchor" id="ad5060c6f0aecf491d92f3029ce9ab187"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::queueWorkItemOnMainThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_thread_pool_1_1_work_item.html">WorkItem</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a work item to the main thread's work queue.</p>
<p>The main thread's work queue will be processed each frame using a set timeout to limit the work being done. Nonetheless, work items will not be suspended in-midst of processing, so make sure that whatever work you issue to the main thread is light work or you may see short hangs in gameplay.</p>
<p>To reiterate this: any code executed through this interface directly adds to frame processing time on the main thread.</p>
<p>This method <em>may</em> (and is meant to) be called from threads other than the main thread. </p>

</div>
</div>
<a class="anchor" id="ae9ea729c3cde2081d0589306e353ff46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::setQueueTimeBasedPriorityBoost </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the priority increment applied to work items on each update interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Priority increment. Set to zero to deactivate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd3d6218972e13b768ca5c9f2e94c049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::setQueueUpdateInterval </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>milliSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the update interval of the work item queue to the given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliSeconds</td><td>Time between updates in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af458a3973346b630360da961d7e1373f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::waitForAllItems </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you're using a non-global thread pool to parallelise some work, you may want to block until all the parallel work is complete. As with flushWorkItems, this method may block indefinitely if new items keep getting added to the pool before old ones finish.</p>
<p><em>This method will not wait for items queued on the main thread using queueWorkItemOnMainThread!</em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOut</td><td>Soft limit on the number of milliseconds to wait for all items to complete. -1 = infinite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1ab2eeb4433747912e52a9572c8ddf51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::smForceAllMainThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Force all work items to execute on main thread; turns this into a single-threaded system. Primarily useful to find whether malfunctions are caused by parallel execution or not. </p>

</div>
</div>
<a class="anchor" id="abd2e0d50d09e3ae5c4c568ac414e6289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_thread_safe_priority_queue_with_update.html">ThreadPool::QueueType</a> ThreadPool::smMainThreadQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Work queue for main thread; can be used to ping back work items to main thread that need processing that can only happen on main thread. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/projects/torque3d-qw64q/Engine/source/platform/threads/<a class="el" href="thread_pool_8h_source.html">threadPool.h</a></li>
<li>C:/projects/torque3d-qw64q/Engine/source/platform/threads/threadPool.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
