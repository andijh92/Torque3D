<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PolyhedronImpl&lt; Base &gt; Struct Template Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="modules.html">Modules</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" target="_blank" href="http://www.garagegames.com/documentation/torque-3d">Online</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER --><!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="structPolyhedronImpl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PolyhedronImpl&lt; Base &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A polyhedron.  
 <a href="structPolyhedronImpl.html#details">More...</a></p>

<p><code>#include &lt;math/mPolyhedron.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for PolyhedronImpl&lt; Base &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="structPolyhedronImpl__inherit__graph.png" border="0" usemap="#PolyhedronImpl_3_01Base_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="PolyhedronImpl_3_01Base_01_4_inherit__map" id="PolyhedronImpl_3_01Base_01_4_inherit__map">
<area shape="rect" id="node3" href="structPolyhedronImpl.html" title="PolyhedronImpl\&lt; FrustumData \&gt;" alt="" coords="5,171,215,197"/>
<area shape="rect" id="node2" href="classBase.html" title="Base" alt="" coords="85,5,135,32"/>
<area shape="rect" id="node4" href="classFrustum.html" title="This class implements a view frustum for use in culling scene objects and rendering the scene..." alt="" coords="75,247,145,273"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6666da9a146dd8db588b4b965e377b80"><td class="memItemLeft" align="right" valign="top">typedef Base::Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a6666da9a146dd8db588b4b965e377b80">Edge</a></td></tr>
<tr class="separator:a6666da9a146dd8db588b4b965e377b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55897e8802e23d3fe48033bd39c03164"><td class="memItemLeft" align="right" valign="top">typedef Base::EdgeListType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a55897e8802e23d3fe48033bd39c03164">EdgeListType</a></td></tr>
<tr class="separator:a55897e8802e23d3fe48033bd39c03164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"><td class="memItemLeft" align="right" valign="top">typedef Base::PlaneListType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a6bcbb6c849d2a24c7a5c0e7bdfe8cd13">PlaneListType</a></td></tr>
<tr class="separator:a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c4f2b0c52b113910c188273db49675"><td class="memItemLeft" align="right" valign="top">typedef Base::PointListType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a88c4f2b0c52b113910c188273db49675">PointListType</a></td></tr>
<tr class="separator:a88c4f2b0c52b113910c188273db49675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a995ec41ee31a6ff601d8514130c07bbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a995ec41ee31a6ff601d8514130c07bbb">PolyhedronImpl</a> ()</td></tr>
<tr class="memdesc:a995ec41ee31a6ff601d8514130c07bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty polyhedron.  <a href="#a995ec41ee31a6ff601d8514130c07bbb">More...</a><br /></td></tr>
<tr class="separator:a995ec41ee31a6ff601d8514130c07bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5118b39df900b0c75c77b144424b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a15c5118b39df900b0c75c77b144424b7">PolyhedronImpl</a> (<a class="el" href="structPolyhedronImpl.html#a6bcbb6c849d2a24c7a5c0e7bdfe8cd13">PlaneListType</a> planes, <a class="el" href="structPolyhedronImpl.html#a88c4f2b0c52b113910c188273db49675">PointListType</a> points, <a class="el" href="structPolyhedronImpl.html#a55897e8802e23d3fe48033bd39c03164">EdgeListType</a> edges)</td></tr>
<tr class="memdesc:a15c5118b39df900b0c75c77b144424b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a polyhedron described by the given planes and edges.  <a href="#a15c5118b39df900b0c75c77b144424b7">More...</a><br /></td></tr>
<tr class="separator:a15c5118b39df900b0c75c77b144424b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b4cd32c0bb7b185d7e9150b156767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBox3F.html">Box3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#ae27b4cd32c0bb7b185d7e9150b156767">getBounds</a> () const </td></tr>
<tr class="memdesc:ae27b4cd32c0bb7b185d7e9150b156767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AABB around the polyhedron.  <a href="#ae27b4cd32c0bb7b185d7e9150b156767">More...</a><br /></td></tr>
<tr class="separator:ae27b4cd32c0bb7b185d7e9150b156767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891d67d99ccf153f78b28e558a3933a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#ad891d67d99ccf153f78b28e558a3933a">getCenterPoint</a> () const </td></tr>
<tr class="memdesc:ad891d67d99ccf153f78b28e558a3933a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the median point of all points defined on the polyhedron.  <a href="#ad891d67d99ccf153f78b28e558a3933a">More...</a><br /></td></tr>
<tr class="separator:ad891d67d99ccf153f78b28e558a3933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transform</div></td></tr>
<tr class="memitem:ad9f47528b69f00afffc3686a46289040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#ad9f47528b69f00afffc3686a46289040">transform</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;matrix, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;scale=<a class="el" href="classPoint3F.html#ad151506ac669d2daa19d98bbbba73a79">Point3F::One</a>)</td></tr>
<tr class="memdesc:ad9f47528b69f00afffc3686a46289040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the polyhedron using the given transform matrix and scale.  <a href="#ad9f47528b69f00afffc3686a46289040">More...</a><br /></td></tr>
<tr class="separator:ad9f47528b69f00afffc3686a46289040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Containment</div></td></tr>
<tr class="memitem:aaf4c10f923722657e589cbcbf75f3858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#aaf4c10f923722657e589cbcbf75f3858">isContained</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;point, F32 epsilon=0.f) const </td></tr>
<tr class="separator:aaf4c10f923722657e589cbcbf75f3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad243fedd25ddfa92f124793a3671ff66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#ad243fedd25ddfa92f124793a3671ff66">isContained</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *points, U32 numPoints) const </td></tr>
<tr class="separator:ad243fedd25ddfa92f124793a3671ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc71944718b3521ec143a8833a4e733"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#adfc71944718b3521ec143a8833a4e733">isContained</a> (const <a class="el" href="classBox3F.html">Box3F</a> &amp;aabb) const </td></tr>
<tr class="separator:adfc71944718b3521ec143a8833a4e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c1350c070ccf3b5c5ca4af975274d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#ad2c1350c070ccf3b5c5ca4af975274d3">isContained</a> (const <a class="el" href="classSphereF.html">SphereF</a> &amp;sphere) const </td></tr>
<tr class="separator:ad2c1350c070ccf3b5c5ca4af975274d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3506dc44cdb3708f6dbbf0b4f8aa5156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a3506dc44cdb3708f6dbbf0b4f8aa5156">isContained</a> (const <a class="el" href="classOrientedBox3F.html">OrientedBox3F</a> &amp;obb) const </td></tr>
<tr class="separator:a3506dc44cdb3708f6dbbf0b4f8aa5156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Intersection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All of these intersection methods are approximate in that they can produce false positives on GeometryIntersecting.</p>
<p>For precise testing, use <a class="el" href="structIntersector.html" title="Geometric intersecting testing. ">Intersector</a>. </p>
</div></td></tr>
<tr class="memitem:a5e84c994610cf371269af2f0920b5903"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a5e84c994610cf371269af2f0920b5903">testPotentialIntersection</a> (const <a class="el" href="classBox3F.html">Box3F</a> &amp;aabb) const </td></tr>
<tr class="separator:a5e84c994610cf371269af2f0920b5903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290980d0d9bcd82f226719404473715b"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a290980d0d9bcd82f226719404473715b">testPotentialIntersection</a> (const <a class="el" href="classSphereF.html">SphereF</a> &amp;sphere) const </td></tr>
<tr class="separator:a290980d0d9bcd82f226719404473715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7c4298e73a81e415c95f0000fe6383"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a9d7c4298e73a81e415c95f0000fe6383">testPotentialIntersection</a> (const <a class="el" href="classOrientedBox3F.html">OrientedBox3F</a> &amp;obb) const </td></tr>
<tr class="separator:a9d7c4298e73a81e415c95f0000fe6383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec79027fc757f0797cfca195b1502c"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a16ec79027fc757f0797cfca195b1502c">testPlanes</a> (const <a class="el" href="classBox3F.html">Box3F</a> &amp;bounds, U32 planeMask=0xFFFFFFFF, F32 expand=0.0f) const </td></tr>
<tr class="separator:a16ec79027fc757f0797cfca195b1502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Clipping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functionality to clip other geometries against the polyhedron. </p>
</div></td></tr>
<tr class="memitem:abb49eca2927a80a721268e70ce5f2825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#abb49eca2927a80a721268e70ce5f2825">clipSegment</a> (<a class="el" href="classPoint3F.html">Point3F</a> &amp;pnt0, <a class="el" href="classPoint3F.html">Point3F</a> &amp;pnt1) const </td></tr>
<tr class="separator:abb49eca2927a80a721268e70ce5f2825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a6cf15594f6792f53d15f23ffd3e85"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a83a6cf15594f6792f53d15f23ffd3e85">clipPolygon</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *inVertices, U32 inNumVertices, <a class="el" href="classPoint3F.html">Point3F</a> *outVertices, U32 maxOutVertices) const </td></tr>
<tr class="separator:a83a6cf15594f6792f53d15f23ffd3e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operations for constructing solids and polygons through boolean operations involving the polyhedron. </p>
</div></td></tr>
<tr class="memitem:a6562f9bb01803b6a2e820c46d6c01d62"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a6562f9bb01803b6a2e820c46d6c01d62">constructIntersection</a> (const <a class="el" href="classPlaneF.html">PlaneF</a> &amp;plane, <a class="el" href="classPoint3F.html">Point3F</a> *outPoints, U32 maxOutPoints) const </td></tr>
<tr class="memdesc:a6562f9bb01803b6a2e820c46d6c01d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the intersection of this polyhedron with the given plane.  <a href="#a6562f9bb01803b6a2e820c46d6c01d62">More...</a><br /></td></tr>
<tr class="separator:a6562f9bb01803b6a2e820c46d6c01d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extraction</div></td></tr>
<tr class="memitem:acb1a34e1139bde084bccde470230486d"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:acb1a34e1139bde084bccde470230486d"><td class="memTemplItemLeft" align="right" valign="top">U32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#acb1a34e1139bde084bccde470230486d">extractFace</a> (U32 plane, IndexType *outIndices, U32 maxOutIndices) const </td></tr>
<tr class="memdesc:acb1a34e1139bde084bccde470230486d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the polygon for the given plane.  <a href="#acb1a34e1139bde084bccde470230486d">More...</a><br /></td></tr>
<tr class="separator:acb1a34e1139bde084bccde470230486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a735d3a23e4c74d19602cc038b1506405"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a735d3a23e4c74d19602cc038b1506405"><td class="memTemplItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structPolyhedronImpl.html#a735d3a23e4c74d19602cc038b1506405">_testOverlap</a> (const P &amp;bounds) const </td></tr>
<tr class="separator:a735d3a23e4c74d19602cc038b1506405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Base = PolyhedronVectorData&gt;<br />
struct PolyhedronImpl&lt; Base &gt;</h3>

<p>A polyhedron. </p>
<p>Polyhedrons are stored as both sets of planes as well sets of edges and vertices (basically a winged-edge format).</p>
<p>Polyhedrons must be convex.</p>
<dl class="section note"><dt>Note</dt><dd>The default orientation for the plane normals of a polyhedron is <em>inwards</em>. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a6666da9a146dd8db588b4b965e377b80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::Edge <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html#a6666da9a146dd8db588b4b965e377b80">Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55897e8802e23d3fe48033bd39c03164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::EdgeListType <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html#a55897e8802e23d3fe48033bd39c03164">EdgeListType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::PlaneListType <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html#a6bcbb6c849d2a24c7a5c0e7bdfe8cd13">PlaneListType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a88c4f2b0c52b113910c188273db49675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::PointListType <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html#a88c4f2b0c52b113910c188273db49675">PointListType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a995ec41ee31a6ff601d8514130c07bbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty polyhedron. </p>

</div>
</div>
<a class="anchor" id="a15c5118b39df900b0c75c77b144424b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::<a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPolyhedronImpl.html#a6bcbb6c849d2a24c7a5c0e7bdfe8cd13">PlaneListType</a>&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPolyhedronImpl.html#a88c4f2b0c52b113910c188273db49675">PointListType</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPolyhedronImpl.html#a55897e8802e23d3fe48033bd39c03164">EdgeListType</a>&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a polyhedron described by the given planes and edges. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a735d3a23e4c74d19602cc038b1506405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::_testOverlap </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83a6cf15594f6792f53d15f23ffd3e85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::clipPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>inVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>inNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPlaneSet.html#a96db7203e14a1fdeabdce73a7c1bf911" title="Clip a convex polygon by all planes in the set. ">PlaneSet::clipPolygon</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb49eca2927a80a721268e70ce5f2825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::clipSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPlaneSet.html#a74a5593ea51c612767c4c3191776081d" title="Clip the given line segment against the plane set. ">PlaneSet::clipSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6562f9bb01803b6a2e820c46d6c01d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::constructIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPlaneF.html">PlaneF</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the intersection of this polyhedron with the given plane. </p>
<p>The result is a polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>Plane to intersect the polyhedron with. </td></tr>
    <tr><td class="paramname">outPoints</td><td>(out) Array where the resulting polygon points are stored. A safe size is to just allocate as many points as there are edges in the polyhedron. If you know the maximum number of vertices that can result from the intersection (for example, 4 for a box), then it is ok to only allocate that much. </td></tr>
    <tr><td class="paramname">maxOutPoints</td><td>Number of points that can be stored in <em>outPoints</em>. If insufficient, the return value will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of points written to <em>outPoints</em>. If there is no intersection between the given plane and the polyhedron, this will be zero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The resulting points will be ordered to form a proper polygon but there is no guarantee on which direction the ordering is in compared to the plane. </dd></dl>

<p>References <a class="el" href="classPlaneF.html#a9d1206bc8e594fddb14e24af29704789">PlaneF::clipSegment()</a>, <a class="el" href="classPlaneF.html#a4559cd275bede58fc6044ce9f62b8a49aa203802807f2f0666df0017cfa571cdb">PlaneF::Front</a>, <a class="el" href="classPlaneF.html#a4559cd275bede58fc6044ce9f62b8a49a6b49eaac25768200133c4ac418b91624">PlaneF::On</a>, and <a class="el" href="classPlaneF.html#a6af3a1b77204e6a3a94584ebd2a187a1">PlaneF::whichSide()</a>.</p>

</div>
</div>
<a class="anchor" id="acb1a34e1139bde084bccde470230486d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::extractFace </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>outIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the polygon for the given plane. </p>
<p>The resulting indices will be CW ordered if the plane normals on the polyhedron are facing inwards and CCW ordered otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>Index of the plane on the polyhedron. </td></tr>
    <tr><td class="paramname">outIndices</td><td>Array where the resulting vertex indices will be stored. Must have enough room. If you don't know the exact size that you need, just allocate one index for any point in the mesh. </td></tr>
    <tr><td class="paramname">maxOutIndices</td><td>The number of indices that can be stored in <em>outIndices</em>. If insufficient, the return value will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of indices written to <em>outIndices</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method relies on correct CW ordering of edges with respect to face[0]. </dd></dl>

</div>
</div>
<a class="anchor" id="ae27b4cd32c0bb7b185d7e9150b156767"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBox3F.html">Box3F</a> <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the AABB around the polyhedron. </p>

</div>
</div>
<a class="anchor" id="ad891d67d99ccf153f78b28e558a3933a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::getCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the median point of all points defined on the polyhedron. </p>

</div>
</div>
<a class="anchor" id="aaf4c10f923722657e589cbcbf75f3858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Point3F&amp;,F32) </dd></dl>

</div>
</div>
<a class="anchor" id="ad243fedd25ddfa92f124793a3671ff66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Point3F*,U32) </dd></dl>

</div>
</div>
<a class="anchor" id="adfc71944718b3521ec143a8833a4e733"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBox3F.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Box3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c1350c070ccf3b5c5ca4af975274d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSphereF.html">SphereF</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const SphereF&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a3506dc44cdb3708f6dbbf0b4f8aa5156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientedBox3F.html">OrientedBox3F</a> &amp;&#160;</td>
          <td class="paramname"><em>obb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const OrientedBox3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a16ec79027fc757f0797cfca195b1502c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::testPlanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBox3F.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>planeMask</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>expand</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPlaneSet.html#afdfc5ad6b059245c4b7c4b13a3556116" title="Returns a bitmask of which planes are hit by the given box. ">PlaneSet::testPlanes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e84c994610cf371269af2f0920b5903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBox3F.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const Box3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a290980d0d9bcd82f226719404473715b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSphereF.html">SphereF</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const SphereF&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a9d7c4298e73a81e415c95f0000fe6383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOrientedBox3F.html">OrientedBox3F</a> &amp;&#160;</td>
          <td class="paramname"><em>obb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const OrientedBox3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f47528b69f00afffc3686a46289040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structPolyhedronImpl.html">PolyhedronImpl</a>&lt; <a class="el" href="classBase.html">Base</a> &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="classPoint3F.html#ad151506ac669d2daa19d98bbbba73a79">Point3F::One</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the polyhedron using the given transform matrix and scale. </p>

<p>References <a class="el" href="classMatrixF.html#a9f81cbefe8963884152cb90e08239b42">MatrixF::mulP()</a>, <a class="el" href="classPlaneTransformer.html#a5331c9c03375a28d6b8ae0bfa7a35c7c">PlaneTransformer::set()</a>, and <a class="el" href="classPlaneTransformer.html#ada2e34ead7fa2fe6df41761679e7e96a">PlaneTransformer::transform()</a>.</p>

</div>
</div>
</div><!-- contents -->

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
