<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GFXDevice Class Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="modules.html">Modules</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" target="_blank" href="http://www.garagegames.com/documentation/torque-3d">Online</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER --><!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGFXDevice-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GFXDevice Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> is the TSE graphics interface layer.  
 <a href="classGFXDevice.html#details">More...</a></p>

<p><code>#include &lt;gfx/gfxDevice.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for GFXDevice:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classGFXDevice__inherit__graph.png" border="0" usemap="#GFXDevice_inherit__map" alt="Inheritance graph"/></div>
<map name="GFXDevice_inherit__map" id="GFXDevice_inherit__map">
<area shape="rect" id="node2" href="classGFXD3D11Device.html" title="GFXD3D11Device" alt="" coords="5,80,124,107"/>
<area shape="rect" id="node3" href="classGFXD3D9Device.html" title="GFXD3D9Device" alt="" coords="149,80,261,107"/>
<area shape="rect" id="node5" href="classGFXGLDevice.html" title="GFXGLDevice" alt="" coords="285,80,381,107"/>
<area shape="rect" id="node6" href="classGFXNullDevice.html" title="GFXNullDevice" alt="" coords="405,80,508,107"/>
<area shape="rect" id="node4" href="classGFXPCD3D9Device.html" title="GFXPCD3D9Device" alt="" coords="141,155,268,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3e60f6690dbd79a0bd11e4af78f9fa6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSignal.html">Signal</a>&lt; bool(<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDeviceEventType</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3e60f6690dbd79a0bd11e4af78f9fa6a">DeviceEventSignal</a></td></tr>
<tr class="separator:a3e60f6690dbd79a0bd11e4af78f9fa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ec26ff908a29191c0052937d8154da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154da">GenericShaderType</a> { <br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daab60202d148fd08874654a053d8f44b2f">GSColor</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daaa05d34baac00a450eebc422f454484b2">GSTexture</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daaf1a8a2a1e62fb248fd6f02dc6c056e4b">GSModColorTexture</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daa7c17358274fe24d511d0288a08508ac6">GSAddColorTexture</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daa34a78b46781cc6031aa53fb5579f21df">GSTargetRestore</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daaff5c31aaf710208b40a3f78795b23d7e">GS_COUNT</a>
<br />
 }</td></tr>
<tr class="separator:ad4ec26ff908a29191c0052937d8154da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb5ceeaa0ddff954175417e43d5141"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDeviceEventType</a> { <br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a531f9b88d21ccaa4780797716753d0ce">deCreate</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a51ab624fd7dd399629f1e45d898ecaae">deInit</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a4f3b136d74fbcdfdf1aa8e488e13899e">deDestroy</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a05c1fa3c4a024c0978fc60a85c2999c1">deStartOfFrame</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a83e2494cae3a09d7a22e515fcb449cd6">deEndOfFrame</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a7a077ed6b615369c276ab5bbc6a042a7">dePostFrame</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a2b34f47ff10868d4739a83017c69aff3">deStartOfField</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a2b777ea4e88f4f030ec923d09b7748f4">deLeftStereoFrameRendered</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a485c5070f709ecd02b8e7c4e2f8f2428">deRightStereoFrameRendered</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141a9e62077d15f8445dcac3a0eca6638ddb">deEndOfField</a>
<br />
 }</td></tr>
<tr class="separator:a7afb5ceeaa0ddff954175417e43d5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a682b30e5aee6a9a7c1386ac7ad1f34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34">GFXDeviceLimits</a> { <a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a> = 2
 }</td></tr>
<tr class="separator:a7a682b30e5aee6a9a7c1386ac7ad1f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3225b9116288563b521a711d8e6a44c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad3225b9116288563b521a711d8e6a44c">GFXDeviceRenderStyles</a> { <br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad3225b9116288563b521a711d8e6a44ca640da156ba21718ccab0ec48a0a7abcc">RS_Standard</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad3225b9116288563b521a711d8e6a44ca603394ebbc96932384669f62d01e9067">RS_StereoSideBySide</a> = (1&lt;&lt;0), 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#ad3225b9116288563b521a711d8e6a44caa23104185c2c48c386acba6216326e89">RS_StereoSeparate</a> = (1&lt;&lt;1)
<br />
 }</td></tr>
<tr class="separator:ad3225b9116288563b521a711d8e6a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42aae58e3b0dd2c1abe0050a8d556193"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a42aae58e3b0dd2c1abe0050a8d556193">GFXDevice</a> ()</td></tr>
<tr class="separator:a42aae58e3b0dd2c1abe0050a8d556193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578967fe4b2a5b92c6582bbb848f92a4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a578967fe4b2a5b92c6582bbb848f92a4">~GFXDevice</a> ()</td></tr>
<tr class="separator:a578967fe4b2a5b92c6582bbb848f92a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828dc9eb9b8cd4eec6daf8090cc4639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac828dc9eb9b8cd4eec6daf8090cc4639">activateStereoTarget</a> (S32 eyeId)</td></tr>
<tr class="memdesc:ac828dc9eb9b8cd4eec6daf8090cc4639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates a stereo render target, setting the correct viewport to render eye contents.  <a href="#ac828dc9eb9b8cd4eec6daf8090cc4639">More...</a><br /></td></tr>
<tr class="separator:ac828dc9eb9b8cd4eec6daf8090cc4639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d2c4cb480f486ecb002f514568353"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#afc5d2c4cb480f486ecb002f514568353">allowRender</a> () const </td></tr>
<tr class="separator:afc5d2c4cb480f486ecb002f514568353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bafdaef04ee0db78d8f5c443383363f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2bafdaef04ee0db78d8f5c443383363f">beginReset</a> ()</td></tr>
<tr class="separator:a2bafdaef04ee0db78d8f5c443383363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6891dec318410ef94116b4ec950342c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af6891dec318410ef94116b4ec950342c">canCurrentlyRender</a> () const </td></tr>
<tr class="memdesc:af6891dec318410ef94116b4ec950342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the scene has begun and its safe to make rendering calls.  <a href="#af6891dec318410ef94116b4ec950342c">More...</a><br /></td></tr>
<tr class="separator:af6891dec318410ef94116b4ec950342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e618ec59bd3af2c80feebc76bcf9c4f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXFence.html">GFXFence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4e618ec59bd3af2c80feebc76bcf9c4f">createFence</a> ()=0</td></tr>
<tr class="memdesc:a4e618ec59bd3af2c80feebc76bcf9c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a fence.  <a href="#a4e618ec59bd3af2c80feebc76bcf9c4f">More...</a><br /></td></tr>
<tr class="separator:a4e618ec59bd3af2c80feebc76bcf9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a363725d0a5402fc0b4889749371ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXOcclusionQuery.html">GFXOcclusionQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery</a> ()</td></tr>
<tr class="memdesc:ae0a363725d0a5402fc0b4889749371ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hardware occlusion query object or NULL if this device does not support them.  <a href="#ae0a363725d0a5402fc0b4889749371ed">More...</a><br /></td></tr>
<tr class="separator:ae0a363725d0a5402fc0b4889749371ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38d3e939c2395566a6dddd70f2e42d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad38d3e939c2395566a6dddd70f2e42d4">doParanoidStateCheck</a> ()</td></tr>
<tr class="separator:ad38d3e939c2395566a6dddd70f2e42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d70d5cb8bdbb63f3d56c3295fa794f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8d70d5cb8bdbb63f3d56c3295fa794f7">dumpStates</a> (const char *fileName) const </td></tr>
<tr class="memdesc:a8d70d5cb8bdbb63f3d56c3295fa794f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a method designed for debugging.  <a href="#a8d70d5cb8bdbb63f3d56c3295fa794f7">More...</a><br /></td></tr>
<tr class="separator:a8d70d5cb8bdbb63f3d56c3295fa794f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073437d6c949e49416478ac6bac5b2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4073437d6c949e49416478ac6bac5b2d">finalizeReset</a> ()</td></tr>
<tr class="separator:a4073437d6c949e49416478ac6bac5b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bf19f579f4342e471b8d951963298"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structGFXAdapter.html">GFXAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter</a> ()</td></tr>
<tr class="memdesc:a9c0bf19f579f4342e471b8d951963298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Adapter that was used to create this device.  <a href="#a9c0bf19f579f4342e471b8d951963298">More...</a><br /></td></tr>
<tr class="separator:a9c0bf19f579f4342e471b8d951963298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b07c823a86a49eb070bfcf24ee98cc"><td class="memItemLeft" align="right" valign="top">virtual GFXAdapterType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a16b07c823a86a49eb070bfcf24ee98cc">getAdapterType</a> ()=0</td></tr>
<tr class="memdesc:a16b07c823a86a49eb070bfcf24ee98cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns active graphics adapter type.  <a href="#a16b07c823a86a49eb070bfcf24ee98cc">More...</a><br /></td></tr>
<tr class="separator:a16b07c823a86a49eb070bfcf24ee98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f1cf6b3214e266d5fa63cc2b97539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXCardProfiler.html">GFXCardProfiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3c5f1cf6b3214e266d5fa63cc2b97539">getCardProfiler</a> () const </td></tr>
<tr class="separator:a3c5f1cf6b3214e266d5fa63cc2b97539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af0e3f85ba5431ed2ad27fc5c4312dd0f">getCurrentRenderStyle</a> () const </td></tr>
<tr class="memdesc:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current rendering style based on GFXDeviceRenderStyles.  <a href="#af0e3f85ba5431ed2ad27fc5c4312dd0f">More...</a><br /></td></tr>
<tr class="separator:af0e3f85ba5431ed2ad27fc5c4312dd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311ad224954a89f24ba649a2825ceec"><td class="memItemLeft" align="right" valign="top">S32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac311ad224954a89f24ba649a2825ceec">getCurrentStereoTarget</a> () const </td></tr>
<tr class="memdesc:ac311ad224954a89f24ba649a2825ceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current stereo target being rendered to.  <a href="#ac311ad224954a89f24ba649a2825ceec">More...</a><br /></td></tr>
<tr class="separator:ac311ad224954a89f24ba649a2825ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSwizzle.html">Swizzle</a>&lt; U8, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24</a> () const </td></tr>
<tr class="memdesc:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSwizzle.html" title="This class will swizzle &#39;sizeof( T )&#39; length chunks of memory into different patterns which are user ...">Swizzle</a> to convert 24bpp bitmaps from RGB to the native device format.  <a href="#a936a62a3dd886a1ec053b8cc42bf0d12">More...</a><br /></td></tr>
<tr class="separator:a936a62a3dd886a1ec053b8cc42bf0d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSwizzle.html">Swizzle</a>&lt; U8, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6fdbb77883a6fcca9ae65fabae68c2ea">getDeviceSwizzle32</a> () const </td></tr>
<tr class="memdesc:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSwizzle.html" title="This class will swizzle &#39;sizeof( T )&#39; length chunks of memory into different patterns which are user ...">Swizzle</a> to convert 32bpp bitmaps from RGBA to the native device format.  <a href="#a6fdbb77883a6fcca9ae65fabae68c2ea">More...</a><br /></td></tr>
<tr class="separator:a6fdbb77883a6fcca9ae65fabae68c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2771e16ff7e612d0755fe0ef1c45e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDrawUtil.html">GFXDrawUtil</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa2771e16ff7e612d0755fe0ef1c45e74">getDrawUtil</a> ()</td></tr>
<tr class="memdesc:aa2771e16ff7e612d0755fe0ef1c45e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this device's drawing utility class.  <a href="#aa2771e16ff7e612d0755fe0ef1c45e74">More...</a><br /></td></tr>
<tr class="separator:aa2771e16ff7e612d0755fe0ef1c45e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="memItemLeft" align="right" valign="top">virtual F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad1a5ad5aff2a286e12b8396e024d8e33">getFillConventionOffset</a> () const  =0</td></tr>
<tr class="memdesc:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fill convention for this device.  <a href="#ad1a5ad5aff2a286e12b8396e024d8e33">More...</a><br /></td></tr>
<tr class="separator:ad1a5ad5aff2a286e12b8396e024d8e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3946bcacb1fe7cce0a5ad2a808d683"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#afe3946bcacb1fe7cce0a5ad2a808d683">getInverseStereoEyeTransforms</a> ()</td></tr>
<tr class="separator:afe3946bcacb1fe7cce0a5ad2a808d683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab91faf2269e73d98e8c3b9a79c0af5a"><td class="memItemLeft" align="right" valign="top">virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aab91faf2269e73d98e8c3b9a79c0af5a">getMaxDynamicIndices</a> ()=0</td></tr>
<tr class="separator:aab91faf2269e73d98e8c3b9a79c0af5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d2bcf9c0c38f90bfbd3c01af125a96"><td class="memItemLeft" align="right" valign="top">virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a53d2bcf9c0c38f90bfbd3c01af125a96">getMaxDynamicVerts</a> ()=0</td></tr>
<tr class="separator:a53d2bcf9c0c38f90bfbd3c01af125a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a774881e8870ee0dcb8d2116d6aef5a6f">getStereoEyeOffsets</a> ()</td></tr>
<tr class="memdesc:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current eye offset used during stereo rendering.  <a href="#a774881e8870ee0dcb8d2116d6aef5a6f">More...</a><br /></td></tr>
<tr class="separator:a774881e8870ee0dcb8d2116d6aef5a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7fb9d807efd6e23c3d5316b25ecaba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#abc7fb9d807efd6e23c3d5316b25ecaba">getStereoEyeTransforms</a> ()</td></tr>
<tr class="separator:abc7fb9d807efd6e23c3d5316b25ecaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf529e9c3301c71809b7cb41b052dd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFovPort.html">FovPort</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9cf529e9c3301c71809b7cb41b052dd2">getStereoFovPort</a> ()</td></tr>
<tr class="memdesc:a9cf529e9c3301c71809b7cb41b052dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current eye offset used during stereo rendering.  <a href="#a9cf529e9c3301c71809b7cb41b052dd2">More...</a><br /></td></tr>
<tr class="separator:a9cf529e9c3301c71809b7cb41b052dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4a01652d52c2d9884586959513d733"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4b4a01652d52c2d9884586959513d733">getStereoHeadTransform</a> ()</td></tr>
<tr class="separator:a4b4a01652d52c2d9884586959513d733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02192f0d2b16306a5660e4f7c7d7d7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRectI.html">RectI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a02192f0d2b16306a5660e4f7c7d7d7d6">getStereoViewports</a> ()</td></tr>
<tr class="separator:a02192f0d2b16306a5660e4f7c7d7d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb03342ccba47508daf1c98f08f08af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint2F.html">Point2F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#accb03342ccba47508daf1c98f08f08af">getWorldToScreenScale</a> () const </td></tr>
<tr class="memdesc:accb03342ccba47508daf1c98f08f08af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale for converting world space units to screen space units...  <a href="#accb03342ccba47508daf1c98f08f08af">More...</a><br /></td></tr>
<tr class="separator:accb03342ccba47508daf1c98f08f08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e77604d95bf67bf892a6bc6ddf15a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a975e77604d95bf67bf892a6bc6ddf15a">init</a> (const <a class="el" href="structGFXVideoMode.html">GFXVideoMode</a> &amp;mode, <a class="el" href="classPlatformWindow.html">PlatformWindow</a> *window=NULL)=0</td></tr>
<tr class="memdesc:a975e77604d95bf67bf892a6bc6ddf15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize this <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a>, optionally specifying a platform window to bind to.  <a href="#a975e77604d95bf67bf892a6bc6ddf15a">More...</a><br /></td></tr>
<tr class="separator:a975e77604d95bf67bf892a6bc6ddf15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eab068a5df508c89b42926e272ab4fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a1eab068a5df508c89b42926e272ab4fa">recentlyReset</a> ()</td></tr>
<tr class="separator:a1eab068a5df508c89b42926e272ab4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba845cb4964bf84eb90a8fa97e38adda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aba845cb4964bf84eb90a8fa97e38adda">setAllowRender</a> (bool render)</td></tr>
<tr class="separator:aba845cb4964bf84eb90a8fa97e38adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16f89a7d220bb185911b325a168a6a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa16f89a7d220bb185911b325a168a6a4">setCurrentRenderStyle</a> (U32 style)</td></tr>
<tr class="memdesc:aa16f89a7d220bb185911b325a168a6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current rendering style, based on GFXDeviceRenderStyles.  <a href="#aa16f89a7d220bb185911b325a168a6a4">More...</a><br /></td></tr>
<tr class="separator:aa16f89a7d220bb185911b325a168a6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdc4198cbd7b593a18ca8be755f8998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0fdc4198cbd7b593a18ca8be755f8998">setCurrentStereoTarget</a> (const F32 targetId)</td></tr>
<tr class="memdesc:a0fdc4198cbd7b593a18ca8be755f8998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current stereo target being rendered to (in case we're doing anything with postfx)  <a href="#a0fdc4198cbd7b593a18ca8be755f8998">More...</a><br /></td></tr>
<tr class="separator:a0fdc4198cbd7b593a18ca8be755f8998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423dbbef99f73865489e232014932812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a423dbbef99f73865489e232014932812">setStereoEyeOffsets</a> (<a class="el" href="classPoint3F.html">Point3F</a> *offsets)</td></tr>
<tr class="memdesc:a423dbbef99f73865489e232014932812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current eye offset used during stereo rendering.  <a href="#a423dbbef99f73865489e232014932812">More...</a><br /></td></tr>
<tr class="separator:a423dbbef99f73865489e232014932812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4715b4049f9d80a5eff9c837835f4209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4715b4049f9d80a5eff9c837835f4209">setStereoEyeTransforms</a> (<a class="el" href="classMatrixF.html">MatrixF</a> *transforms)</td></tr>
<tr class="separator:a4715b4049f9d80a5eff9c837835f4209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b056605f616c21dd2cad10917031e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a19b056605f616c21dd2cad10917031e9">setStereoFovPort</a> (const <a class="el" href="structFovPort.html">FovPort</a> *ports)</td></tr>
<tr class="memdesc:a19b056605f616c21dd2cad10917031e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current eye offset used during stereo rendering. Assumes NumStereoPorts are available.  <a href="#a19b056605f616c21dd2cad10917031e9">More...</a><br /></td></tr>
<tr class="separator:a19b056605f616c21dd2cad10917031e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a78c6586d8a6a1403b3d0a65a55e236d8">setStereoHeadTransform</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;mat)</td></tr>
<tr class="memdesc:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the head matrix for stereo rendering.  <a href="#a78c6586d8a6a1403b3d0a65a55e236d8">More...</a><br /></td></tr>
<tr class="separator:a78c6586d8a6a1403b3d0a65a55e236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf86e581a626ae46b2e436c44d647de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2cf86e581a626ae46b2e436c44d647de">setStereoTargets</a> (<a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a> **targets)</td></tr>
<tr class="memdesc:a2cf86e581a626ae46b2e436c44d647de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stereo render targets.  <a href="#a2cf86e581a626ae46b2e436c44d647de">More...</a><br /></td></tr>
<tr class="separator:a2cf86e581a626ae46b2e436c44d647de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccac78b964e3c85cf054082e6e2b885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6ccac78b964e3c85cf054082e6e2b885">setSteroViewports</a> (const <a class="el" href="classRectI.html">RectI</a> *ports)</td></tr>
<tr class="memdesc:a6ccac78b964e3c85cf054082e6e2b885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stereo viewports.  <a href="#a6ccac78b964e3c85cf054082e6e2b885">More...</a><br /></td></tr>
<tr class="separator:a6ccac78b964e3c85cf054082e6e2b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a4b0ac3141200a820922b58da5107"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab07a4b0ac3141200a820922b58da5107">setupGenericShaders</a> (<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154da">GenericShaderType</a> type=<a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daab60202d148fd08874654a053d8f44b2f">GSColor</a>)</td></tr>
<tr class="memdesc:ab07a4b0ac3141200a820922b58da5107"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function to set a default shader for rendering GUI elements on systems which do not support fixed-function operations as well as for things which need just generic position/texture/color shaders.  <a href="#ab07a4b0ac3141200a820922b58da5107">More...</a><br /></td></tr>
<tr class="separator:ab07a4b0ac3141200a820922b58da5107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug Methods</div></td></tr>
<tr class="memitem:a36fbc0a8a18c83bee5aa3c4984905e94"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a36fbc0a8a18c83bee5aa3c4984905e94">enterDebugEvent</a> (<a class="el" href="classColorI.html">ColorI</a> color, const char *name)=0</td></tr>
<tr class="separator:a36fbc0a8a18c83bee5aa3c4984905e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c1dadf2039bf1441d26e8342388a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aca2c1dadf2039bf1441d26e8342388a5">leaveDebugEvent</a> ()=0</td></tr>
<tr class="separator:aca2c1dadf2039bf1441d26e8342388a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc83e217ed0133cb9b9267683b03475"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3bc83e217ed0133cb9b9267683b03475">setDebugMarker</a> (<a class="el" href="classColorI.html">ColorI</a> color, const char *name)=0</td></tr>
<tr class="separator:a3bc83e217ed0133cb9b9267683b03475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Video Mode Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Enumerates the supported video modes of the device </p>
</div></td></tr>
<tr class="memitem:a205d1b053188b4fb95aea848e3302dc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a205d1b053188b4fb95aea848e3302dc5">enumerateVideoModes</a> ()=0</td></tr>
<tr class="separator:a205d1b053188b4fb95aea848e3302dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcfdaaf73855c6ba53e472eb1d700b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="structGFXVideoMode.html">GFXVideoMode</a> &gt; *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a1bcfdaaf73855c6ba53e472eb1d700b3">getVideoModeList</a> () const </td></tr>
<tr class="memdesc:a1bcfdaaf73855c6ba53e472eb1d700b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the video mode list.  <a href="#a1bcfdaaf73855c6ba53e472eb1d700b3">More...</a><br /></td></tr>
<tr class="separator:a1bcfdaaf73855c6ba53e472eb1d700b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584fb79c33de9df4ebdbe8531b17b865"><td class="memItemLeft" align="right" valign="top">virtual GFXFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a584fb79c33de9df4ebdbe8531b17b865">selectSupportedFormat</a> (<a class="el" href="classGFXTextureProfile.html">GFXTextureProfile</a> *profile, const <a class="el" href="classVector.html">Vector</a>&lt; GFXFormat &gt; &amp;formats, bool texture, bool mustblend, bool mustfilter)=0</td></tr>
<tr class="memdesc:a584fb79c33de9df4ebdbe8531b17b865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first format from the list which meets all the criteria of the texture profile and query options.  <a href="#a584fb79c33de9df4ebdbe8531b17b865">More...</a><br /></td></tr>
<tr class="separator:a584fb79c33de9df4ebdbe8531b17b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Render Target functions</div></td></tr>
<tr class="memitem:ad993db38e2a55452481cca1522a28d38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad993db38e2a55452481cca1522a28d38">allocRenderToTextureTarget</a> ()=0</td></tr>
<tr class="memdesc:ad993db38e2a55452481cca1522a28d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a target for doing render to texture operations, with no depth/stencil buffer.  <a href="#ad993db38e2a55452481cca1522a28d38">More...</a><br /></td></tr>
<tr class="separator:ad993db38e2a55452481cca1522a28d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4da4638b532dd340bab16f22e00bb1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXWindowTarget.html">GFXWindowTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3c4da4638b532dd340bab16f22e00bb1">allocWindowTarget</a> (<a class="el" href="classPlatformWindow.html">PlatformWindow</a> *window)=0</td></tr>
<tr class="memdesc:a3c4da4638b532dd340bab16f22e00bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a target for a given window.  <a href="#a3c4da4638b532dd340bab16f22e00bb1">More...</a><br /></td></tr>
<tr class="separator:a3c4da4638b532dd340bab16f22e00bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac6e7907ef7d8a23c57f74ccdc0ac4339">pushActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the current render target to restore later.  <a href="#ac6e7907ef7d8a23c57f74ccdc0ac4339">More...</a><br /></td></tr>
<tr class="separator:ac6e7907ef7d8a23c57f74ccdc0ac4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0397a347c5f3211860979b0a107e3203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0397a347c5f3211860979b0a107e3203">popActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:a0397a347c5f3211860979b0a107e3203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previous render target.  <a href="#a0397a347c5f3211860979b0a107e3203">More...</a><br /></td></tr>
<tr class="separator:a0397a347c5f3211860979b0a107e3203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7270b308ee6cb8dc7d44faccf67cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aec7270b308ee6cb8dc7d44faccf67cad">setActiveRenderTarget</a> (<a class="el" href="classGFXTarget.html">GFXTarget</a> *target, bool updateViewport=true)</td></tr>
<tr class="memdesc:aec7270b308ee6cb8dc7d44faccf67cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new active render target.  <a href="#aec7270b308ee6cb8dc7d44faccf67cad">More...</a><br /></td></tr>
<tr class="separator:aec7270b308ee6cb8dc7d44faccf67cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTarget.html">GFXTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget</a> ()</td></tr>
<tr class="memdesc:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current active render target.  <a href="#ae56964c4831dd3a1f6c1819be6bf7ad9">More...</a><br /></td></tr>
<tr class="separator:ae56964c4831dd3a1f6c1819be6bf7ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shader functions</div></td></tr>
<tr class="memitem:a3a72024c21bc9f43c11e90e15fe86343"><td class="memItemLeft" align="right" valign="top">virtual F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3a72024c21bc9f43c11e90e15fe86343">getPixelShaderVersion</a> () const  =0</td></tr>
<tr class="separator:a3a72024c21bc9f43c11e90e15fe86343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02b6f74b519b52757c71f744df7f092"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa02b6f74b519b52757c71f744df7f092">setPixelShaderVersion</a> (F32 version)=0</td></tr>
<tr class="separator:aa02b6f74b519b52757c71f744df7f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="memItemLeft" align="right" valign="top">virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a54209fc4a4c1bef924d7bfa13d615ca3">getNumSamplers</a> () const  =0</td></tr>
<tr class="memdesc:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of texture samplers that can be used in a shader rendering pass.  <a href="#a54209fc4a4c1bef924d7bfa13d615ca3">More...</a><br /></td></tr>
<tr class="separator:a54209fc4a4c1bef924d7bfa13d615ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1305c77b9071c68c7e72f267f40946"><td class="memItemLeft" align="right" valign="top">virtual U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4f1305c77b9071c68c7e72f267f40946">getNumRenderTargets</a> () const  =0</td></tr>
<tr class="memdesc:a4f1305c77b9071c68c7e72f267f40946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simultaneous render targets supported by the device.  <a href="#a4f1305c77b9071c68c7e72f267f40946">More...</a><br /></td></tr>
<tr class="separator:a4f1305c77b9071c68c7e72f267f40946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e3d37b0ca3d5ff1fe20d8778c27412"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae0e3d37b0ca3d5ff1fe20d8778c27412">setShader</a> (<a class="el" href="classGFXShader.html">GFXShader</a> *shader, bool force=false)</td></tr>
<tr class="separator:ae0e3d37b0ca3d5ff1fe20d8778c27412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a2ba572ca80f0023c0ccdbce2ba8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders</a> (bool force=false)</td></tr>
<tr class="separator:a175a2ba572ca80f0023c0ccdbce2ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbeeb26e49406db965dd8da7c3cf778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a1fbeeb26e49406db965dd8da7c3cf778">setShaderConstBuffer</a> (<a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a> *buffer)</td></tr>
<tr class="memdesc:a1fbeeb26e49406db965dd8da7c3cf778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer! (Actual set happens on the next draw call, just like textures, state blocks, etc)  <a href="#a1fbeeb26e49406db965dd8da7c3cf778">More...</a><br /></td></tr>
<tr class="separator:a1fbeeb26e49406db965dd8da7c3cf778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1782edd3fa1bfb70fe6e2477139a450"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXShader.html">GFXShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac1782edd3fa1bfb70fe6e2477139a450">createShader</a> ()=0</td></tr>
<tr class="memdesc:ac1782edd3fa1bfb70fe6e2477139a450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty shader which must be initialized and deleted by the caller.  <a href="#ac1782edd3fa1bfb70fe6e2477139a450">More...</a><br /></td></tr>
<tr class="separator:ac1782edd3fa1bfb70fe6e2477139a450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Settings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>NONE of these should be overridden by API implementations because of the state caching stuff. </p>
</div></td></tr>
<tr class="memitem:a96b201f929f4c7c5bbcd723d32f132a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a96b201f929f4c7c5bbcd723d32f132a5">setLight</a> (U32 stage, <a class="el" href="classGFXLightInfo.html">GFXLightInfo</a> *light)</td></tr>
<tr class="separator:a96b201f929f4c7c5bbcd723d32f132a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287e5cd40c9b2944b9e6d51b1550fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9287e5cd40c9b2944b9e6d51b1550fc3">setLightMaterial</a> (const <a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a> &amp;mat)</td></tr>
<tr class="separator:a9287e5cd40c9b2944b9e6d51b1550fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831d4a88a902bc9dc13afdb4727e0d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a831d4a88a902bc9dc13afdb4727e0d99">setGlobalAmbientColor</a> (const <a class="el" href="classColorF.html">ColorF</a> &amp;color)</td></tr>
<tr class="separator:a831d4a88a902bc9dc13afdb4727e0d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture State Settings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>NONE of these should be overridden by API implementations because of the state caching stuff. </p>
</div></td></tr>
<tr class="memitem:a25fd4143c2a3a02865b4d39b5a8b691d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a25fd4143c2a3a02865b4d39b5a8b691d">setTexture</a> (U32 stage, <a class="el" href="classGFXTextureObject.html">GFXTextureObject</a> *texture)</td></tr>
<tr class="separator:a25fd4143c2a3a02865b4d39b5a8b691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb2a85886f21b71656409abd3a8ffbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0cb2a85886f21b71656409abd3a8ffbd">setCubeTexture</a> (U32 stage, <a class="el" href="classGFXCubemap.html">GFXCubemap</a> *cubemap)</td></tr>
<tr class="separator:a0cb2a85886f21b71656409abd3a8ffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba3582c1126a073cee6627539e7020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTextureObject.html">GFXTextureObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a63ba3582c1126a073cee6627539e7020">getCurrentTexture</a> (U32 stage)</td></tr>
<tr class="separator:a63ba3582c1126a073cee6627539e7020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Block Interface</div></td></tr>
<tr class="memitem:aed6f0f49a3b0d9bea9149475a412c043"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aed6f0f49a3b0d9bea9149475a412c043">createStateBlock</a> (const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;desc)</td></tr>
<tr class="memdesc:aed6f0f49a3b0d9bea9149475a412c043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a state block object based on the desc passed in.  <a href="#aed6f0f49a3b0d9bea9149475a412c043">More...</a><br /></td></tr>
<tr class="separator:aed6f0f49a3b0d9bea9149475a412c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2407e0e26a6eb50614d0609132b43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a13a2407e0e26a6eb50614d0609132b43">setStateBlock</a> (<a class="el" href="classGFXStateBlock.html">GFXStateBlock</a> *block)</td></tr>
<tr class="memdesc:a13a2407e0e26a6eb50614d0609132b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current stateblock (actually activated in ::updateStates)  <a href="#a13a2407e0e26a6eb50614d0609132b43">More...</a><br /></td></tr>
<tr class="separator:a13a2407e0e26a6eb50614d0609132b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a86920cddd637f7bb2e33c16de9cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXStateBlock.html">GFXStateBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae2a86920cddd637f7bb2e33c16de9cd4">getStateBlock</a> ()</td></tr>
<tr class="separator:ae2a86920cddd637f7bb2e33c16de9cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad607356d34ebcaea70c35614f724b498"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad607356d34ebcaea70c35614f724b498">setStateBlockByDesc</a> (const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;desc)</td></tr>
<tr class="memdesc:ad607356d34ebcaea70c35614f724b498"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets a stateblock directly from the description structure.  <a href="#ad607356d34ebcaea70c35614f724b498">More...</a><br /></td></tr>
<tr class="separator:ad607356d34ebcaea70c35614f724b498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix interface</div></td></tr>
<tr class="memitem:ae8964ddd37f4be2361cb346b1e132fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;newWorld)</td></tr>
<tr class="memdesc:ae8964ddd37f4be2361cb346b1e132fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the top of the world matrix stack.  <a href="#ae8964ddd37f4be2361cb346b1e132fe9">More...</a><br /></td></tr>
<tr class="separator:ae8964ddd37f4be2361cb346b1e132fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix</a> () const </td></tr>
<tr class="memdesc:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the matrix on the top of the world matrix stack.  <a href="#a2f27a6b462aa7d9b393ae9b528b00e00">More...</a><br /></td></tr>
<tr class="separator:a2f27a6b462aa7d9b393ae9b528b00e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b012283186cb887f4bda73b35fad1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix</a> ()</td></tr>
<tr class="memdesc:ab1b012283186cb887f4bda73b35fad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the world matrix stack and copies the current top matrix to the new top of the stack.  <a href="#ab1b012283186cb887f4bda73b35fad1a">More...</a><br /></td></tr>
<tr class="separator:ab1b012283186cb887f4bda73b35fad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a2651759c03f2c039fb775961a09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix</a> ()</td></tr>
<tr class="memdesc:a2b3a2651759c03f2c039fb775961a09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the world matrix stack.  <a href="#a2b3a2651759c03f2c039fb775961a09c">More...</a><br /></td></tr>
<tr class="separator:a2b3a2651759c03f2c039fb775961a09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e383532f8a7db58b99310ab9a9dd2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;newProj)</td></tr>
<tr class="memdesc:a1e383532f8a7db58b99310ab9a9dd2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the projection matrix.  <a href="#a1e383532f8a7db58b99310ab9a9dd2ba">More...</a><br /></td></tr>
<tr class="separator:a1e383532f8a7db58b99310ab9a9dd2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8491b8ad4fbe1c529c13886d48ac419"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad8491b8ad4fbe1c529c13886d48ac419">getProjectionMatrix</a> () const </td></tr>
<tr class="memdesc:ad8491b8ad4fbe1c529c13886d48ac419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the projection matrix.  <a href="#ad8491b8ad4fbe1c529c13886d48ac419">More...</a><br /></td></tr>
<tr class="separator:ad8491b8ad4fbe1c529c13886d48ac419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f00a3b21b5ec5d071fd9a409891a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;newView)</td></tr>
<tr class="memdesc:a612f00a3b21b5ec5d071fd9a409891a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the view matrix.  <a href="#a612f00a3b21b5ec5d071fd9a409891a1">More...</a><br /></td></tr>
<tr class="separator:a612f00a3b21b5ec5d071fd9a409891a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb96149889ba6465948deec8f1646bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix</a> () const </td></tr>
<tr class="memdesc:a8bb96149889ba6465948deec8f1646bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the view matrix.  <a href="#a8bb96149889ba6465948deec8f1646bd">More...</a><br /></td></tr>
<tr class="separator:a8bb96149889ba6465948deec8f1646bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd2cb45f6c371e03b065b02b4a648b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;mat)</td></tr>
<tr class="memdesc:aa2dd2cb45f6c371e03b065b02b4a648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix at the top of the world matrix stack by a matrix and replaces the top of the matrix stack with the result.  <a href="#aa2dd2cb45f6c371e03b065b02b4a648b">More...</a><br /></td></tr>
<tr class="separator:aa2dd2cb45f6c371e03b065b02b4a648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix</a> (const U32 stage, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;texMat)</td></tr>
<tr class="memdesc:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set texture matrix for a sampler.  <a href="#ae41b6b0d8ce7f82a67f82f5045837efc">More...</a><br /></td></tr>
<tr class="separator:ae41b6b0d8ce7f82a67f82f5045837efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff095cc01fc3319d229996a16791b919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aff095cc01fc3319d229996a16791b919">setViewport</a> (const <a class="el" href="classRectI.html">RectI</a> &amp;rect)</td></tr>
<tr class="memdesc:aff095cc01fc3319d229996a16791b919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an area of the target to render to.  <a href="#aff095cc01fc3319d229996a16791b919">More...</a><br /></td></tr>
<tr class="separator:aff095cc01fc3319d229996a16791b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport</a> () const </td></tr>
<tr class="memdesc:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current area of the target we will render to.  <a href="#a438a05795dc86bad94a7a1e9dffdd1e4">More...</a><br /></td></tr>
<tr class="separator:a438a05795dc86bad94a7a1e9dffdd1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6babdb0e6e95db55663e506a55d6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#afca6babdb0e6e95db55663e506a55d6a">setClipRect</a> (const <a class="el" href="classRectI.html">RectI</a> &amp;rect)=0</td></tr>
<tr class="separator:afca6babdb0e6e95db55663e506a55d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b3fbc6868e209a0ecec65c68b856b9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a80b3fbc6868e209a0ecec65c68b856b9">getClipRect</a> () const  =0</td></tr>
<tr class="separator:a80b3fbc6868e209a0ecec65c68b856b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468d8c68aa637bd4ff58fd4ec61a52d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a468d8c68aa637bd4ff58fd4ec61a52d0">setFrustum</a> (F32 left, F32 right, F32 bottom, F32 top, F32 nearPlane, F32 farPlane, bool bRotate=true)</td></tr>
<tr class="memdesc:a468d8c68aa637bd4ff58fd4ec61a52d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection frustum.  <a href="#a468d8c68aa637bd4ff58fd4ec61a52d0">More...</a><br /></td></tr>
<tr class="separator:a468d8c68aa637bd4ff58fd4ec61a52d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df6e3d25a5ecb94ba43faccba4a3c11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7df6e3d25a5ecb94ba43faccba4a3c11">setFrustum</a> (const <a class="el" href="classFrustum.html">Frustum</a> &amp;frust, bool bRotate=true)</td></tr>
<tr class="separator:a7df6e3d25a5ecb94ba43faccba4a3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6682a478e5ec9ab1bdced5f6c3674d85">getFrustum</a> (F32 *left, F32 *right, F32 *bottom, F32 *top, F32 *nearPlane, F32 *farPlane, bool *isOrtho) const </td></tr>
<tr class="memdesc:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection frustum.  <a href="#a6682a478e5ec9ab1bdced5f6c3674d85">More...</a><br /></td></tr>
<tr class="separator:a6682a478e5ec9ab1bdced5f6c3674d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20267e71efa9d22e5effe9632a7fd736"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a20267e71efa9d22e5effe9632a7fd736">getFrustum</a> () const </td></tr>
<tr class="memdesc:a20267e71efa9d22e5effe9632a7fd736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection frustum.  <a href="#a20267e71efa9d22e5effe9632a7fd736">More...</a><br /></td></tr>
<tr class="separator:a20267e71efa9d22e5effe9632a7fd736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919f3f4e11d349b3919f851a40c7f4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac919f3f4e11d349b3919f851a40c7f4d">setOrtho</a> (F32 left, F32 right, F32 bottom, F32 top, F32 nearPlane, F32 farPlane, bool doRotate=false)</td></tr>
<tr class="memdesc:ac919f3f4e11d349b3919f851a40c7f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will construct and apply an orthographic projection matrix with the provided parameters.  <a href="#ac919f3f4e11d349b3919f851a40c7f4d">More...</a><br /></td></tr>
<tr class="separator:ac919f3f4e11d349b3919f851a40c7f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb441df9be45731b1bd4ee66d83f81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a05cb441df9be45731b1bd4ee66d83f81">isFrustumOrtho</a> () const </td></tr>
<tr class="memdesc:a05cb441df9be45731b1bd4ee66d83f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the current frustum uses orthographic projection rather than perspective projection.  <a href="#a05cb441df9be45731b1bd4ee66d83f81">More...</a><br /></td></tr>
<tr class="separator:a05cb441df9be45731b1bd4ee66d83f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4f2b16b1eaf4224769547cbe0959eaab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4f2b16b1eaf4224769547cbe0959eaab">destroy</a> ()</td></tr>
<tr class="separator:a4f2b16b1eaf4224769547cbe0959eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca769dd2c67d56ae1b19f4f9212d47f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a1ca769dd2c67d56ae1b19f4f9212d47f">devicePresent</a> ()</td></tr>
<tr class="separator:a1ca769dd2c67d56ae1b19f4f9212d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69076c283dcd2631fd01f9ac8e9b750"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGFXDevice.html">GFXDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af69076c283dcd2631fd01f9ac8e9b750">get</a> ()</td></tr>
<tr class="separator:af69076c283dcd2631fd01f9ac8e9b750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e92df30409a034b51dfb9a906f7627"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGFXDevice.html#a3e60f6690dbd79a0bd11e4af78f9fa6a">DeviceEventSignal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a22e92df30409a034b51dfb9a906f7627">getDeviceEventSignal</a> ()</td></tr>
<tr class="separator:a22e92df30409a034b51dfb9a906f7627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d39ded294eb76d3c87a464fe6b675"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a5d7d39ded294eb76d3c87a464fe6b675">initConsole</a> ()</td></tr>
<tr class="separator:a5d7d39ded294eb76d3c87a464fe6b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a051a7f704e1cc95a7340365561a92e9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a051a7f704e1cc95a7340365561a92e9a">_updateRenderTargets</a> ()=0</td></tr>
<tr class="memdesc:a051a7f704e1cc95a7340365561a92e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the render targets and viewport in a device specific manner when they are dirty.  <a href="#a051a7f704e1cc95a7340365561a92e9a">More...</a><br /></td></tr>
<tr class="separator:a051a7f704e1cc95a7340365561a92e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf399c09070ac19e3f3c45bc9f8cfea4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#acf399c09070ac19e3f3c45bc9f8cfea4">beginSceneInternal</a> ()=0</td></tr>
<tr class="separator:acf399c09070ac19e3f3c45bc9f8cfea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab885e8132647e1b6ebbc5d24bad2c950"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab885e8132647e1b6ebbc5d24bad2c950">deviceInited</a> ()</td></tr>
<tr class="memdesc:ab885e8132647e1b6ebbc5d24bad2c950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> that we are initialized.  <a href="#ab885e8132647e1b6ebbc5d24bad2c950">More...</a><br /></td></tr>
<tr class="separator:ab885e8132647e1b6ebbc5d24bad2c950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b636000d55dc81bded299d5fe47b65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab9b636000d55dc81bded299d5fe47b65">endSceneInternal</a> ()=0</td></tr>
<tr class="separator:ab9b636000d55dc81bded299d5fe47b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7c66bfbb861c43a14b330cbe337e24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3b7c66bfbb861c43a14b330cbe337e24">preDestroy</a> ()</td></tr>
<tr class="memdesc:a3b7c66bfbb861c43a14b330cbe337e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called before this, or any other device, is deleted in the global <a class="el" href="classGFXDevice.html#a4f2b16b1eaf4224769547cbe0959eaab">destroy()</a> method.  <a href="#a3b7c66bfbb861c43a14b330cbe337e24">More...</a><br /></td></tr>
<tr class="separator:a3b7c66bfbb861c43a14b330cbe337e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter</a> (const <a class="el" href="structGFXAdapter.html">GFXAdapter</a> &amp;adapter)</td></tr>
<tr class="memdesc:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the adapter that this device is using. For use by <a class="el" href="classGFXInit.html#a7a3cf47311dbb6edf16a0b37d5048dff" title="Creates a GFXDevice based on an adapter from the enumerateAdapters method. ">GFXInit::createDevice</a> only.  <a href="#a4dfb10ddda5a685595ebdbe6c939eba4">More...</a><br /></td></tr>
<tr class="separator:a4dfb10ddda5a685595ebdbe6c939eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382cb2b32a67827e6b6cc8f95afc30f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2382cb2b32a67827e6b6cc8f95afc30f">setGlobalAmbientInternal</a> (<a class="el" href="classColorF.html">ColorF</a> color)=0</td></tr>
<tr class="separator:a2382cb2b32a67827e6b6cc8f95afc30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf4953b9d3aabc2797b923d0395e9f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7bf4953b9d3aabc2797b923d0395e9f8">setLightInternal</a> (U32 lightStage, const <a class="el" href="classGFXLightInfo.html">GFXLightInfo</a> light, bool lightEnable)=0</td></tr>
<tr class="separator:a7bf4953b9d3aabc2797b923d0395e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b380dd09d07a7b5c048c4ff9a28b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7c8b380dd09d07a7b5c048c4ff9a28b4">setLightMaterialInternal</a> (const <a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a> mat)=0</td></tr>
<tr class="separator:a7c8b380dd09d07a7b5c048c4ff9a28b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69948ce316fd8bd1979d6477100c341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae69948ce316fd8bd1979d6477100c341">setMatrix</a> (GFXMatrixType mtype, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;mat)=0</td></tr>
<tr class="memdesc:ae69948ce316fd8bd1979d6477100c341"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function must be implemented differently per API and it should set ONLY the current matrix.  <a href="#ae69948ce316fd8bd1979d6477100c341">More...</a><br /></td></tr>
<tr class="separator:ae69948ce316fd8bd1979d6477100c341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092d8361c678b9aeb930213be271f55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac092d8361c678b9aeb930213be271f55">setShaderConstBufferInternal</a> (<a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:ac092d8361c678b9aeb930213be271f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by base <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to actually set a const buffer.  <a href="#ac092d8361c678b9aeb930213be271f55">More...</a><br /></td></tr>
<tr class="separator:ac092d8361c678b9aeb930213be271f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e6777ac71f79797458ce28b1b6fffa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a58e6777ac71f79797458ce28b1b6fffa">setTextureInternal</a> (U32 textureUnit, const <a class="el" href="classGFXTextureObject.html">GFXTextureObject</a> *texture)=0</td></tr>
<tr class="separator:a58e6777ac71f79797458ce28b1b6fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stateblock functions</div></td></tr>
<tr class="memitem:a984f77b6e3ae50d8149d7e09b90035d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a984f77b6e3ae50d8149d7e09b90035d0">createStateBlockInternal</a> (const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a984f77b6e3ae50d8149d7e09b90035d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to create a device specific stateblock.  <a href="#a984f77b6e3ae50d8149d7e09b90035d0">More...</a><br /></td></tr>
<tr class="separator:a984f77b6e3ae50d8149d7e09b90035d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ceb04e1a40cab3bfd42d0f53721e41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad2ceb04e1a40cab3bfd42d0f53721e41">setStateBlockInternal</a> (<a class="el" href="classGFXStateBlock.html">GFXStateBlock</a> *block, bool force)=0</td></tr>
<tr class="memdesc:ad2ceb04e1a40cab3bfd42d0f53721e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to actually set a stateblock.  <a href="#ad2ceb04e1a40cab3bfd42d0f53721e41">More...</a><br /></td></tr>
<tr class="separator:ad2ceb04e1a40cab3bfd42d0f53721e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Initialization.</div></td></tr>
<tr class="memitem:aa22f5f747e2aefd7912edb2f85521cf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa22f5f747e2aefd7912edb2f85521cf1">initStates</a> ()=0</td></tr>
<tr class="memdesc:aa22f5f747e2aefd7912edb2f85521cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">State initialization.  <a href="#aa22f5f747e2aefd7912edb2f85521cf1">More...</a><br /></td></tr>
<tr class="separator:aa22f5f747e2aefd7912edb2f85521cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab3b997ba465a5c7481616b57cc496ea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab3b997ba465a5c7481616b57cc496ea9">mAllowRender</a></td></tr>
<tr class="memdesc:ab3b997ba465a5c7481616b57cc496ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if we're in a mode where we want rendering to occur.  <a href="#ab3b997ba465a5c7481616b57cc496ea9">More...</a><br /></td></tr>
<tr class="separator:ab3b997ba465a5c7481616b57cc496ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0640c509f516369ded3ab66d8d033af4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0640c509f516369ded3ab66d8d033af4">mCanCurrentlyRender</a></td></tr>
<tr class="memdesc:a0640c509f516369ded3ab66d8d033af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set once the device is active.  <a href="#a0640c509f516369ded3ab66d8d033af4">More...</a><br /></td></tr>
<tr class="separator:a0640c509f516369ded3ab66d8d033af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXCardProfiler.html">GFXCardProfiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a42308d582bcfd5bcfc4be84ad5b74b36">mCardProfiler</a></td></tr>
<tr class="memdesc:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CardProfiler for this device.  <a href="#a42308d582bcfd5bcfc4be84ad5b74b36">More...</a><br /></td></tr>
<tr class="separator:a42308d582bcfd5bcfc4be84ad5b74b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe369bc897df355de806d52a3aeafe3"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#adbe369bc897df355de806d52a3aeafe3">mCurrentFrontBufferIdx</a></td></tr>
<tr class="separator:adbe369bc897df355de806d52a3aeafe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512cbf498248d8312d4403e5992f58bd"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a512cbf498248d8312d4403e5992f58bd">mCurrentRenderStyle</a></td></tr>
<tr class="memdesc:a512cbf498248d8312d4403e5992f58bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style of rendering that is to be performed, based on GFXDeviceRenderStyles.  <a href="#a512cbf498248d8312d4403e5992f58bd">More...</a><br /></td></tr>
<tr class="separator:a512cbf498248d8312d4403e5992f58bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34099197db5b16c78de828ad781ef30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">GFXTargetRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af34099197db5b16c78de828ad781ef30">mCurrentRT</a></td></tr>
<tr class="memdesc:af34099197db5b16c78de828ad781ef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current render target which may or may not not be yet activated.  <a href="#af34099197db5b16c78de828ad781ef30">More...</a><br /></td></tr>
<tr class="separator:af34099197db5b16c78de828ad781ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="memItemLeft" align="right" valign="top">S32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aee3c4c42b4d22530a1a69fc7de1334ec">mCurrentStereoTarget</a></td></tr>
<tr class="memdesc:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current stereo target being rendered to.  <a href="#aee3c4c42b4d22530a1a69fc7de1334ec">More...</a><br /></td></tr>
<tr class="separator:aee3c4c42b4d22530a1a69fc7de1334ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c873557881c5019fbe8671a18a05bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSwizzle.html">Swizzle</a>&lt; U8, 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a43c873557881c5019fbe8671a18a05bb">mDeviceSwizzle24</a></td></tr>
<tr class="separator:a43c873557881c5019fbe8671a18a05bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa819b68c170b3ed9540dabc2d631090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSwizzle.html">Swizzle</a>&lt; U8, 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#afa819b68c170b3ed9540dabc2d631090">mDeviceSwizzle32</a></td></tr>
<tr class="separator:afa819b68c170b3ed9540dabc2d631090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6c20eed5ba81d25036e9b650110e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDrawUtil.html">GFXDrawUtil</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7e6c20eed5ba81d25036e9b650110e4e">mDrawer</a></td></tr>
<tr class="separator:a7e6c20eed5ba81d25036e9b650110e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b9da8251f994a5b89a8999b865148c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFovPort.html">FovPort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a51b9da8251f994a5b89a8999b865148c">mFovPorts</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:a51b9da8251f994a5b89a8999b865148c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fov port settings.  <a href="#a51b9da8251f994a5b89a8999b865148c">More...</a><br /></td></tr>
<tr class="separator:a51b9da8251f994a5b89a8999b865148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac4dc34bd6e229397547b5126ab074a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aaac4dc34bd6e229397547b5126ab074a">mFrontBuffer</a> [2]</td></tr>
<tr class="separator:aaac4dc34bd6e229397547b5126ab074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383de7991bfb38654381ac35bee51974"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a383de7991bfb38654381ac35bee51974">mInitialized</a></td></tr>
<tr class="memdesc:a383de7991bfb38654381ac35bee51974"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will allow querying to see if a device is initialized and ready to have operations performed on it.  <a href="#a383de7991bfb38654381ac35bee51974">More...</a><br /></td></tr>
<tr class="separator:a383de7991bfb38654381ac35bee51974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b3396082a57edce8055de839fc3f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab28b3396082a57edce8055de839fc3f3">mInverseStereoEyeTransforms</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:ab28b3396082a57edce8055de839fc3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of mStereoEyeTransforms.  <a href="#ab28b3396082a57edce8055de839fc3f3">More...</a><br /></td></tr>
<tr class="separator:ab28b3396082a57edce8055de839fc3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c4a54be462dcd9aa41ed9c9bfe88c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a355c4a54be462dcd9aa41ed9c9bfe88c">mReset</a></td></tr>
<tr class="separator:a355c4a54be462dcd9aa41ed9c9bfe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bccb6833d494e75ebd17a3481187b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXResource.html">GFXResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a434bccb6833d494e75ebd17a3481187b">mResourceListHead</a></td></tr>
<tr class="memdesc:a434bccb6833d494e75ebd17a3481187b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head of the resource list.  <a href="#a434bccb6833d494e75ebd17a3481187b">More...</a><br /></td></tr>
<tr class="separator:a434bccb6833d494e75ebd17a3481187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff41a4cae195f1eaf108370e450b9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">GFXTargetRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#acff41a4cae195f1eaf108370e450b9b7">mRTDeactivate</a></td></tr>
<tr class="memdesc:acff41a4cae195f1eaf108370e450b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tracks a previously activated render target which need to be deactivated.  <a href="#acff41a4cae195f1eaf108370e450b9b7">More...</a><br /></td></tr>
<tr class="separator:acff41a4cae195f1eaf108370e450b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7559e13ed0b83f00855d96b58951dba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7559e13ed0b83f00855d96b58951dba4">mRTDirty</a></td></tr>
<tr class="memdesc:a7559e13ed0b83f00855d96b58951dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is set when the current and/or deactivate render targets have changed and the device need to update its state on the next draw/clear.  <a href="#a7559e13ed0b83f00855d96b58951dba4">More...</a><br /></td></tr>
<tr class="separator:a7559e13ed0b83f00855d96b58951dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9661b2d8db8a749d77ceaa193b125fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classStrongRefPtr.html">GFXTargetRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9661b2d8db8a749d77ceaa193b125fe9">mRTStack</a></td></tr>
<tr class="memdesc:a9661b2d8db8a749d77ceaa193b125fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack of previously active render targets.  <a href="#a9661b2d8db8a749d77ceaa193b125fe9">More...</a><br /></td></tr>
<tr class="separator:a9661b2d8db8a749d77ceaa193b125fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7c85d356eebe4d5c9e13938073f0b2e4">mStereoEyeOffset</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eye offset used when using a stereo rendering style.  <a href="#a7c85d356eebe4d5c9e13938073f0b2e4">More...</a><br /></td></tr>
<tr class="separator:a7c85d356eebe4d5c9e13938073f0b2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9719978834b18a8591dbb2b9b8bd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0a9719978834b18a8591dbb2b9b8bd35">mStereoEyeTransforms</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:a0a9719978834b18a8591dbb2b9b8bd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left and right matrix for eyes.  <a href="#a0a9719978834b18a8591dbb2b9b8bd35">More...</a><br /></td></tr>
<tr class="separator:a0a9719978834b18a8591dbb2b9b8bd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acce4a751019055aaf5e767203427dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8acce4a751019055aaf5e767203427dd">mStereoHeadTransform</a></td></tr>
<tr class="memdesc:a8acce4a751019055aaf5e767203427dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center matrix for head.  <a href="#a8acce4a751019055aaf5e767203427dd">More...</a><br /></td></tr>
<tr class="separator:a8acce4a751019055aaf5e767203427dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b294ea6b6557a29bece47901d049bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a5b294ea6b6557a29bece47901d049bce">mStereoTargets</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:a5b294ea6b6557a29bece47901d049bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination targets for stereo rendering.  <a href="#a5b294ea6b6557a29bece47901d049bce">More...</a><br /></td></tr>
<tr class="separator:a5b294ea6b6557a29bece47901d049bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b078eeae79f9883a8ca2c5474819e65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRectI.html">RectI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a5b078eeae79f9883a8ca2c5474819e65">mStereoViewports</a> [<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td></tr>
<tr class="memdesc:a5b078eeae79f9883a8ca2c5474819e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination viewports for stereo rendering.  <a href="#a5b078eeae79f9883a8ca2c5474819e65">More...</a><br /></td></tr>
<tr class="separator:a5b078eeae79f9883a8ca2c5474819e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99c283f886c8f2b009c5d981e27ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="structGFXVideoMode.html">GFXVideoMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9a99c283f886c8f2b009c5d981e27ad1">mVideoModes</a></td></tr>
<tr class="memdesc:a9a99c283f886c8f2b009c5d981e27ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of valid video modes for this device.  <a href="#a9a99c283f886c8f2b009c5d981e27ad1">More...</a><br /></td></tr>
<tr class="separator:a9a99c283f886c8f2b009c5d981e27ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e47fe86d99aed8172572a044bc4aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRectI.html">RectI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad43e47fe86d99aed8172572a044bc4aa">mViewport</a></td></tr>
<tr class="memdesc:ad43e47fe86d99aed8172572a044bc4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current viewport rect.  <a href="#ad43e47fe86d99aed8172572a044bc4aa">More...</a><br /></td></tr>
<tr class="separator:ad43e47fe86d99aed8172572a044bc4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b127b09986479d663abb4b75745e96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a51b127b09986479d663abb4b75745e96">mViewportDirty</a></td></tr>
<tr class="memdesc:a51b127b09986479d663abb4b75745e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true the viewport has been changed and it must be updated on the next draw/clear.  <a href="#a51b127b09986479d663abb4b75745e96">More...</a><br /></td></tr>
<tr class="separator:a51b127b09986479d663abb4b75745e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Light Tracking</div></td></tr>
<tr class="memitem:a2d6a137fa62660913b15f387f84a6d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXLightInfo.html">GFXLightInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2d6a137fa62660913b15f387f84a6d4d">mCurrentLight</a> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a2d6a137fa62660913b15f387f84a6d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604ab7c118abd8b5d9e2ccc8fb7dd72a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a604ab7c118abd8b5d9e2ccc8fb7dd72a">mCurrentLightEnable</a> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a604ab7c118abd8b5d9e2ccc8fb7dd72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a527d0548f69341ce5090babb6cc03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a85a527d0548f69341ce5090babb6cc03">mLightDirty</a> [LIGHT_STAGE_COUNT]</td></tr>
<tr class="separator:a85a527d0548f69341ce5090babb6cc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ee4a2c9a16284f82db47a19f91bc34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a78ee4a2c9a16284f82db47a19f91bc34">mLightsDirty</a></td></tr>
<tr class="separator:a78ee4a2c9a16284f82db47a19f91bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4173195fde309ef9374d21bf07dbac25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classColorF.html">ColorF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a4173195fde309ef9374d21bf07dbac25">mGlobalAmbientColor</a></td></tr>
<tr class="separator:a4173195fde309ef9374d21bf07dbac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c56b555a16db1bb8c5a0e4b5c60c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab44c56b555a16db1bb8c5a0e4b5c60c3">mGlobalAmbientColorDirty</a></td></tr>
<tr class="separator:ab44c56b555a16db1bb8c5a0e4b5c60c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Fixed function material tracking</div></td></tr>
<tr class="memitem:a2122cca014575c1a80262b10b53091a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2122cca014575c1a80262b10b53091a1">mCurrentLightMaterial</a></td></tr>
<tr class="separator:a2122cca014575c1a80262b10b53091a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c105b7501fa0ac0303870e650174f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af8c105b7501fa0ac0303870e650174f1">mLightMaterialDirty</a></td></tr>
<tr class="separator:af8c105b7501fa0ac0303870e650174f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix managing variables</div></td></tr>
<tr class="memitem:aff5d637cc039b275af5f1c121f329dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aff5d637cc039b275af5f1c121f329dc3">mWorldMatrix</a> [WORLD_STACK_MAX]</td></tr>
<tr class="separator:aff5d637cc039b275af5f1c121f329dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92eb4b02fb61b330b3ee5ddbfcd29ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab92eb4b02fb61b330b3ee5ddbfcd29ba">mWorldMatrixDirty</a></td></tr>
<tr class="separator:ab92eb4b02fb61b330b3ee5ddbfcd29ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d1a7c773d0de6d78d46e7235a5107"><td class="memItemLeft" align="right" valign="top">S32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a></td></tr>
<tr class="separator:a948d1a7c773d0de6d78d46e7235a5107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3258f45fb86b003b11c54e91e5ade8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3258f45fb86b003b11c54e91e5ade8a5">mProjectionMatrix</a></td></tr>
<tr class="separator:a3258f45fb86b003b11c54e91e5ade8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc6a2e2c64ed6ff7df1f9558e1cefb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3fc6a2e2c64ed6ff7df1f9558e1cefb2">mProjectionMatrixDirty</a></td></tr>
<tr class="separator:a3fc6a2e2c64ed6ff7df1f9558e1cefb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914b619a373d5c753a7bae8b40140e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8914b619a373d5c753a7bae8b40140e9">mViewMatrix</a></td></tr>
<tr class="separator:a8914b619a373d5c753a7bae8b40140e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4468a18976dcf128855c0bc5d0caf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#add4468a18976dcf128855c0bc5d0caf8">mViewMatrixDirty</a></td></tr>
<tr class="separator:add4468a18976dcf128855c0bc5d0caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a85de42022a63022dc4adc1552200d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aa6a85de42022a63022dc4adc1552200d">mTextureMatrix</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:aa6a85de42022a63022dc4adc1552200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07c95c8f756a971eaf77e38cea070a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7d07c95c8f756a971eaf77e38cea070a">mTextureMatrixDirty</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a7d07c95c8f756a971eaf77e38cea070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51de21268634908ec665e228138be0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8d51de21268634908ec665e228138be0">mTextureMatrixCheckDirty</a></td></tr>
<tr class="separator:a8d51de21268634908ec665e228138be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Current frustum planes</div></td></tr>
<tr class="memitem:a35f71a1fbf81f4866c8916078e5e3f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFrustum.html">Frustum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a35f71a1fbf81f4866c8916078e5e3f0a">mFrustum</a></td></tr>
<tr class="separator:a35f71a1fbf81f4866c8916078e5e3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Resource debug methods</h2></td></tr>
<tr class="memitem:aef70d216314854ef1cdd7f601c17f38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aef70d216314854ef1cdd7f601c17f38e">mDeviceStatistics</a></td></tr>
<tr class="separator:aef70d216314854ef1cdd7f601c17f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bbcac49b45197d05fc5534b65551f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a64bbcac49b45197d05fc5534b65551f5">fillResourceVectors</a> (const char *resNames, bool unflaggedOnly, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;textureObjects, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;textureTargets, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;windowTargets, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;vertexBuffers, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;primitiveBuffers, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;fences, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;cubemaps, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;shaders, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;stateblocks)</td></tr>
<tr class="memdesc:a64bbcac49b45197d05fc5534b65551f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper method for describeResourcesToFile.  <a href="#a64bbcac49b45197d05fc5534b65551f5">More...</a><br /></td></tr>
<tr class="separator:a64bbcac49b45197d05fc5534b65551f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac593d7a7e1a885c152a1286ea0ce3414"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac593d7a7e1a885c152a1286ea0ce3414">listResources</a> (bool unflaggedOnly)</td></tr>
<tr class="memdesc:ac593d7a7e1a885c152a1286ea0ce3414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists how many of each GFX resource (e.g.  <a href="#ac593d7a7e1a885c152a1286ea0ce3414">More...</a><br /></td></tr>
<tr class="separator:ac593d7a7e1a885c152a1286ea0ce3414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2f7cc426b59410e378661a0c826ba2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ade2f7cc426b59410e378661a0c826ba2">flagCurrentResources</a> ()</td></tr>
<tr class="memdesc:ade2f7cc426b59410e378661a0c826ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags all resources GFX is currently aware of.  <a href="#ade2f7cc426b59410e378661a0c826ba2">More...</a><br /></td></tr>
<tr class="separator:ade2f7cc426b59410e378661a0c826ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f5fc5632f0b89e57668e7a5e7bd3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a598f5fc5632f0b89e57668e7a5e7bd3c">clearResourceFlags</a> ()</td></tr>
<tr class="memdesc:a598f5fc5632f0b89e57668e7a5e7bd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the flag on all resources GFX is currently aware of.  <a href="#a598f5fc5632f0b89e57668e7a5e7bd3c">More...</a><br /></td></tr>
<tr class="separator:a598f5fc5632f0b89e57668e7a5e7bd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6382f1469ffc3d9eea345808999d8ede"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6382f1469ffc3d9eea345808999d8ede">describeResources</a> (const char *resName, const char *file, bool unflaggedOnly)</td></tr>
<tr class="memdesc:a6382f1469ffc3d9eea345808999d8ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a description of the specified resource types to the console.  <a href="#a6382f1469ffc3d9eea345808999d8ede">More...</a><br /></td></tr>
<tr class="separator:a6382f1469ffc3d9eea345808999d8ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707344e1c602854a433551c379c432d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a707344e1c602854a433551c379c432d1">getDeviceStatistics</a> ()</td></tr>
<tr class="memdesc:a707344e1c602854a433551c379c432d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current <a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a>, stats are cleared every ::beginScene call.  <a href="#a707344e1c602854a433551c379c432d1">More...</a><br /></td></tr>
<tr class="separator:a707344e1c602854a433551c379c432d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
State tracking variables</h2></td></tr>
<tr class="memitem:a2f57e2c8b460f93b5b38d9b28e788858"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858">TexDirtyType</a> { <br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858ab0f98aa9f323f79e3adb72d0753a702d">GFXTDT_Normal</a>, 
<br />
&#160;&#160;<a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858a90dd633a9fc928823e63ee9de6dade9c">GFXTDT_Cube</a>
<br />
 }</td></tr>
<tr class="separator:a2f57e2c8b460f93b5b38d9b28e788858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9abcb3e6bdf6b3b0fc87782b86b3c7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classMap.html">Map</a>&lt; U32, <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8b9abcb3e6bdf6b3b0fc87782b86b3c7">StateBlockMap</a></td></tr>
<tr class="separator:a8b9abcb3e6bdf6b3b0fc87782b86b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af56a682e13bfc1054bc7b676034e08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a></td></tr>
<tr class="memdesc:a3af56a682e13bfc1054bc7b676034e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if ANY state is dirty, including matrices or primitive buffers.  <a href="#a3af56a682e13bfc1054bc7b676034e08">More...</a><br /></td></tr>
<tr class="separator:a3af56a682e13bfc1054bc7b676034e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2621a5027fb59956868f32f4e0386553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2621a5027fb59956868f32f4e0386553">mCurrentTexture</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a2621a5027fb59956868f32f4e0386553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb88935753509005512018446598043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aeeb88935753509005512018446598043">mNewTexture</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:aeeb88935753509005512018446598043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873f2e2daf84075fa8f09b177cd04d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXCubemapHandle.html">GFXCubemapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a873f2e2daf84075fa8f09b177cd04d29">mCurrentCubemap</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a873f2e2daf84075fa8f09b177cd04d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ac98966a4c9149cd735d3a3b5eaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXCubemapHandle.html">GFXCubemapHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a684ac98966a4c9149cd735d3a3b5eaa8">mNewCubemap</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a684ac98966a4c9149cd735d3a3b5eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddd6afe745204f748a5ab2a13a778a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858">TexDirtyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9ddd6afe745204f748a5ab2a13a778a2">mTexType</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a9ddd6afe745204f748a5ab2a13a778a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10f10df402ae33f15136e09419521a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0c10f10df402ae33f15136e09419521a">mTextureDirty</a> [TEXTURE_STAGE_COUNT]</td></tr>
<tr class="separator:a0c10f10df402ae33f15136e09419521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981107f9ba92cb7f876957e55b19de3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8981107f9ba92cb7f876957e55b19de3">mTexturesDirty</a></td></tr>
<tr class="separator:a8981107f9ba92cb7f876957e55b19de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3275b8253694e118dce2bde8536c15cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXDevice.html#a8b9abcb3e6bdf6b3b0fc87782b86b3c7">StateBlockMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3275b8253694e118dce2bde8536c15cc">mCurrentStateBlocks</a></td></tr>
<tr class="separator:a3275b8253694e118dce2bde8536c15cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec0cd5b93e1f3eba2903c0bd4a551b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#afec0cd5b93e1f3eba2903c0bd4a551b8">mStateBlockDirty</a></td></tr>
<tr class="separator:afec0cd5b93e1f3eba2903c0bd4a551b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5978aeb64309fdd50ed5bbb638363be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af5978aeb64309fdd50ed5bbb638363be">mCurrentStateBlock</a></td></tr>
<tr class="separator:af5978aeb64309fdd50ed5bbb638363be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35efe65723aa02af5fd8a16444a4d1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a35efe65723aa02af5fd8a16444a4d1fb">mNewStateBlock</a></td></tr>
<tr class="separator:a35efe65723aa02af5fd8a16444a4d1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6f0f57053db7faddd214efe2c05b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aeb6f0f57053db7faddd214efe2c05b04">mCurrentShaderConstBuffer</a></td></tr>
<tr class="separator:aeb6f0f57053db7faddd214efe2c05b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad06dc744102faf1f4098114920931"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a29ad06dc744102faf1f4098114920931">smWireframe</a></td></tr>
<tr class="memdesc:a29ad06dc744102faf1f4098114920931"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global forced wireframe mode.  <a href="#a29ad06dc744102faf1f4098114920931">More...</a><br /></td></tr>
<tr class="separator:a29ad06dc744102faf1f4098114920931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e38378deb803d3c18b5e0c572d75b6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a58e38378deb803d3c18b5e0c572d75b6">smDisableVSync</a></td></tr>
<tr class="memdesc:a58e38378deb803d3c18b5e0c572d75b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global vsync state.  <a href="#a58e38378deb803d3c18b5e0c572d75b6">More...</a><br /></td></tr>
<tr class="separator:a58e38378deb803d3c18b5e0c572d75b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="memItemLeft" align="right" valign="top">static F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6df2c70b6334aeeb9cbcd7dab1630ade">smForcedPixVersion</a></td></tr>
<tr class="memdesc:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">The forced shader model version if non-zero.  <a href="#a6df2c70b6334aeeb9cbcd7dab1630ade">More...</a><br /></td></tr>
<tr class="separator:a6df2c70b6334aeeb9cbcd7dab1630ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa3220067accab7a93c8b3149b50c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a01aa3220067accab7a93c8b3149b50c1">smDisableOcclusionQuery</a></td></tr>
<tr class="memdesc:a01aa3220067accab7a93c8b3149b50c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable all hardware occlusion queries causing them to return only the visibile state.  <a href="#a01aa3220067accab7a93c8b3149b50c1">More...</a><br /></td></tr>
<tr class="separator:a01aa3220067accab7a93c8b3149b50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buffer Allocation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4de9b7b58f57a53063a29ddcfec79493"></a>These methods are implemented per-device and are called by the GFX layer when a user calls an alloc</p>
<dl class="section note"><dt>Note</dt><dd>Primitive Buffers are NOT implemented per device, they wrap index buffers </dd></dl>
</td></tr>
<tr class="memitem:ade79ea252d77700f99fdbd624182b79f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">StrongRefPtr</a>&lt; <a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ade79ea252d77700f99fdbd624182b79f">mCurrentVertexBuffer</a> [<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:ade79ea252d77700f99fdbd624182b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da647fc184d78513d169e6b9b401ae7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8da647fc184d78513d169e6b9b401ae7">mVertexBufferDirty</a> [<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a8da647fc184d78513d169e6b9b401ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf14d72cee6a4eee5d2e946e2b8ab79"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a8cf14d72cee6a4eee5d2e946e2b8ab79">mVertexBufferFrequency</a> [<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a8cf14d72cee6a4eee5d2e946e2b8ab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e59790ca5758de9492a9983220cfe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a49e59790ca5758de9492a9983220cfe6">mVertexBufferFrequencyDirty</a> [<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td></tr>
<tr class="separator:a49e59790ca5758de9492a9983220cfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5e09e4d66089c8359624494326a8a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a5c5e09e4d66089c8359624494326a8a0">mCurrVertexDecl</a></td></tr>
<tr class="separator:a5c5e09e4d66089c8359624494326a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1d89f66d7436373e11a2de109541c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a7e1d89f66d7436373e11a2de109541c5">mVertexDeclDirty</a></td></tr>
<tr class="separator:a7e1d89f66d7436373e11a2de109541c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6843bc771a1a79fe956ed982ad82986e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStrongRefPtr.html">StrongRefPtr</a>&lt; <a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6843bc771a1a79fe956ed982ad82986e">mCurrentPrimitiveBuffer</a></td></tr>
<tr class="separator:a6843bc771a1a79fe956ed982ad82986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a46bbe9ca9f07165ac1b5e15a7191d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a90a46bbe9ca9f07165ac1b5e15a7191d">mPrimitiveBufferDirty</a></td></tr>
<tr class="separator:a90a46bbe9ca9f07165ac1b5e15a7191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5598dda8b6efbce870cb3580d3bed88"><td class="memItemLeft" align="right" valign="top">static const U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a> = 4</td></tr>
<tr class="memdesc:ac5598dda8b6efbce870cb3580d3bed88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of supported vertex streams which may be more than the device supports.  <a href="#ac5598dda8b6efbce870cb3580d3bed88">More...</a><br /></td></tr>
<tr class="separator:ac5598dda8b6efbce870cb3580d3bed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b296b835980733311084858243c676"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a43b296b835980733311084858243c676">allocVertexBuffer</a> (U32 numVerts, const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *vertexFormat, U32 vertSize, GFXBufferType bufferType, void *data=NULL)=0</td></tr>
<tr class="memdesc:a43b296b835980733311084858243c676"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allocates a vertex buffer and returns a pointer to the allocated buffer.  <a href="#a43b296b835980733311084858243c676">More...</a><br /></td></tr>
<tr class="separator:a43b296b835980733311084858243c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38052299c52e6f333cf4b038e709520d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a38052299c52e6f333cf4b038e709520d">allocVertexDecl</a> (const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *vertexFormat)=0</td></tr>
<tr class="memdesc:a38052299c52e6f333cf4b038e709520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="classGFXVertexFormat.html" title="The vertex format structure usually created via the declare and implement macros. ...">GFXVertexFormat</a> to allocate the hardware specific vertex declaration for rendering.  <a href="#a38052299c52e6f333cf4b038e709520d">More...</a><br /></td></tr>
<tr class="separator:a38052299c52e6f333cf4b038e709520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513eafd27cec212b0f4a227c0e980f1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a513eafd27cec212b0f4a227c0e980f1b">setVertexDecl</a> (const <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a> *decl)=0</td></tr>
<tr class="memdesc:a513eafd27cec212b0f4a227c0e980f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current vertex declaration on the device.  <a href="#a513eafd27cec212b0f4a227c0e980f1b">More...</a><br /></td></tr>
<tr class="separator:a513eafd27cec212b0f4a227c0e980f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40df8472f8ce595b8081e26d595da57"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ad40df8472f8ce595b8081e26d595da57">setVertexStream</a> (U32 stream, <a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> *buffer)=0</td></tr>
<tr class="memdesc:ad40df8472f8ce595b8081e26d595da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex buffer on the device.  <a href="#ad40df8472f8ce595b8081e26d595da57">More...</a><br /></td></tr>
<tr class="separator:ad40df8472f8ce595b8081e26d595da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d4fe702476a93273750e994b122baf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a83d4fe702476a93273750e994b122baf">setVertexStreamFrequency</a> (U32 stream, U32 frequency)=0</td></tr>
<tr class="memdesc:a83d4fe702476a93273750e994b122baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex stream frequency on the device.  <a href="#a83d4fe702476a93273750e994b122baf">More...</a><br /></td></tr>
<tr class="separator:a83d4fe702476a93273750e994b122baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f670d81f44d389c0b4c237244c0d8dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a3f670d81f44d389c0b4c237244c0d8dc">allocPrimitiveBuffer</a> (U32 numIndices, U32 numPrimitives, GFXBufferType bufferType, void *data=NULL)=0</td></tr>
<tr class="memdesc:a3f670d81f44d389c0b4c237244c0d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allocates a primitive buffer and returns a pointer to the allocated buffer.  <a href="#a3f670d81f44d389c0b4c237244c0d8dc">More...</a><br /></td></tr>
<tr class="separator:a3f670d81f44d389c0b4c237244c0d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Texture functions</h2></td></tr>
<tr class="memitem:a42dbd3cae371b904e59d669b6e44382e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTextureManager.html">GFXTextureManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a42dbd3cae371b904e59d669b6e44382e">mTextureManager</a></td></tr>
<tr class="separator:a42dbd3cae371b904e59d669b6e44382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2845d65759a6c57ee430ac522baa0591"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXCubemap.html">GFXCubemap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a2845d65759a6c57ee430ac522baa0591">createCubemap</a> ()=0</td></tr>
<tr class="separator:a2845d65759a6c57ee430ac522baa0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae530441812a0b904302c77c30d6bc6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGFXTextureManager.html">GFXTextureManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ae530441812a0b904302c77c30d6bc6ca">getTextureManager</a> ()</td></tr>
<tr class="separator:ae530441812a0b904302c77c30d6bc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Rendering methods</h2></td></tr>
<tr class="memitem:a998ce4a95beabc46cc1dabd7514742bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPlatformTimer.html">PlatformTimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a998ce4a95beabc46cc1dabd7514742bd">mFrameTime</a></td></tr>
<tr class="separator:a998ce4a95beabc46cc1dabd7514742bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e7aecac375ebffa3c3eb0996d2c86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a184e7aecac375ebffa3c3eb0996d2c86">clear</a> (U32 flags, <a class="el" href="classColorI.html">ColorI</a> color, F32 z, U32 stencil)=0</td></tr>
<tr class="separator:a184e7aecac375ebffa3c3eb0996d2c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e65eaac7a29c50d64b5f5865e7a13"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a680e65eaac7a29c50d64b5f5865e7a13">beginScene</a> ()</td></tr>
<tr class="separator:a680e65eaac7a29c50d64b5f5865e7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fb94fdd451d5cbba2f4b5ebdb359c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a47fb94fdd451d5cbba2f4b5ebdb359c2">endScene</a> ()</td></tr>
<tr class="separator:a47fb94fdd451d5cbba2f4b5ebdb359c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31022933142174acd4f8598a80c14aec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a31022933142174acd4f8598a80c14aec">beginField</a> ()</td></tr>
<tr class="separator:a31022933142174acd4f8598a80c14aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbba63f9d9a6dbb5f4d90e39fa2d0f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a0fbba63f9d9a6dbb5f4d90e39fa2d0f1">endField</a> ()</td></tr>
<tr class="separator:a0fbba63f9d9a6dbb5f4d90e39fa2d0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f42c65529f7db671b731bd38d2492"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGFXTexHandle.html">GFXTexHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer</a> ()</td></tr>
<tr class="separator:aac0f42c65529f7db671b731bd38d2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5f906b6757e53a837df0fd90b0b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a27f5f906b6757e53a837df0fd90b0b51">setPrimitiveBuffer</a> (<a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> *buffer)</td></tr>
<tr class="separator:a27f5f906b6757e53a837df0fd90b0b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ddf97417de82295f859773420f3cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer</a> (<a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> *buffer, U32 stream=0, U32 frequency=0)</td></tr>
<tr class="memdesc:a71ddf97417de82295f859773420f3cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex buffer.  <a href="#a71ddf97417de82295f859773420f3cdc">More...</a><br /></td></tr>
<tr class="separator:a71ddf97417de82295f859773420f3cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee483ec4b229f6b4983a4f9bb5947fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat</a> (const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *vertexFormat)</td></tr>
<tr class="memdesc:aee483ec4b229f6b4983a4f9bb5947fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current vertex format.  <a href="#aee483ec4b229f6b4983a4f9bb5947fee">More...</a><br /></td></tr>
<tr class="separator:aee483ec4b229f6b4983a4f9bb5947fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73fd289201b74cad6f80c5bbd82fc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#acd73fd289201b74cad6f80c5bbd82fc3">drawPrimitive</a> (GFXPrimitiveType primType, U32 vertexStart, U32 primitiveCount)=0</td></tr>
<tr class="separator:acd73fd289201b74cad6f80c5bbd82fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9e832fd0c3cf2946e9bbb1c1a7544"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a9fd9e832fd0c3cf2946e9bbb1c1a7544">drawIndexedPrimitive</a> (GFXPrimitiveType primType, U32 startVertex, U32 minIndex, U32 numVerts, U32 startIndex, U32 primitiveCount)=0</td></tr>
<tr class="memdesc:a9fd9e832fd0c3cf2946e9bbb1c1a7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parameters to drawIndexedPrimitive are somewhat complicated.  <a href="#a9fd9e832fd0c3cf2946e9bbb1c1a7544">More...</a><br /></td></tr>
<tr class="separator:a9fd9e832fd0c3cf2946e9bbb1c1a7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38816c438c3a1caa45e3e7cd8f337b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#ab38816c438c3a1caa45e3e7cd8f337b5">drawPrimitive</a> (const <a class="el" href="structGFXPrimitive.html">GFXPrimitive</a> &amp;prim)</td></tr>
<tr class="separator:ab38816c438c3a1caa45e3e7cd8f337b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6040e00f4c6cd5cbef7fececa692a5aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a6040e00f4c6cd5cbef7fececa692a5aa">drawPrimitive</a> (U32 primitiveIndex)</td></tr>
<tr class="separator:a6040e00f4c6cd5cbef7fececa692a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5368f06eef65c7cc370292d3b060b532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a5368f06eef65c7cc370292d3b060b532">drawPrimitives</a> ()</td></tr>
<tr class="separator:a5368f06eef65c7cc370292d3b060b532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25998cf14ca686f28529dda2cb6c50ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#a25998cf14ca686f28529dda2cb6c50ae">drawPrimitiveBuffer</a> (<a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> *buffer)</td></tr>
<tr class="separator:a25998cf14ca686f28529dda2cb6c50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General state interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7d6af627d589f83f39d5ef2a3ebf815b"></a>Sets the dirty Render/Texture/Sampler states from the caching system </p>
</td></tr>
<tr class="memitem:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#adc04807e3c0888dc6ccce3fc4f5a4343">getWireframe</a> ()</td></tr>
<tr class="memdesc:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the forced global wireframe state.  <a href="#adc04807e3c0888dc6ccce3fc4f5a4343">More...</a><br /></td></tr>
<tr class="separator:adc04807e3c0888dc6ccce3fc4f5a4343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfc90cf657e9a85cb3189c3452f5479"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#acdfc90cf657e9a85cb3189c3452f5479">getDisableOcclusionQuery</a> ()</td></tr>
<tr class="memdesc:acdfc90cf657e9a85cb3189c3452f5479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occlusion query is disabled.  <a href="#acdfc90cf657e9a85cb3189c3452f5479">More...</a><br /></td></tr>
<tr class="separator:acdfc90cf657e9a85cb3189c3452f5479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5f9b69134353c0a6f3663ca2feece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGFXDevice.html#af2c5f9b69134353c0a6f3663ca2feece">updateStates</a> (bool forceSetAll=false)</td></tr>
<tr class="separator:af2c5f9b69134353c0a6f3663ca2feece"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> is the TSE graphics interface layer. </p>
<p>This allows the TSE to do many things, such as use multiple render devices for multi-head systems, and allow a game to render in DirectX 9, OpenGL or any other API which has a GFX implementation seamlessly. There are many concepts in GFX device which may not be familiar to you, especially if you have not used DirectX. <br />
<b>Buffers</b> There are three types of buffers in GFX: vertex, index and primitive. Please note that index buffers are not accessable outside the GFX layer, they are wrapped by primitive buffers. Primitive buffers will be explained in detail later. Buffers are allocated and deallocated using their associated allocXBuffer and freeXBuffer methods on the device. When a buffer is allocated you pass in a pointer to, depending on the buffer, a vertex type pointer or a U16 pointer. During allocation, this pointer is set to the address of where you should copy in the information for this buffer. You must the tell the <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> that the information is in, and it should prepare the buffer for use by calling the prepare method on it. Dynamic vertex buffer example: </p><div class="fragment"><div class="line">GFXVertexP *verts;        <span class="comment">// Making a buffer containing verticies with only position</span></div><div class="line"></div><div class="line"><span class="comment">// Allocate a dynamic vertex buffer to hold 3 vertices and use *verts as the location to copy information into</span></div><div class="line"><a class="code" href="classGFXVertexBufferHandle.html">GFXVertexBufferHandle</a> vb = GFX-&gt;allocVertexBuffer( 3, &amp;verts, <span class="keyword">true</span> ); </div><div class="line"></div><div class="line"><span class="comment">// Now set the information, we&#39;re making a triangle</span></div><div class="line">verts[0].point = <a class="code" href="classPoint3F.html">Point3F</a>( 200.f, 200.f, 0.f );</div><div class="line">verts[1].point = <a class="code" href="classPoint3F.html">Point3F</a>( 200.f, 400.f, 0.f );</div><div class="line">verts[2].point = <a class="code" href="classPoint3F.html">Point3F</a>( 400.f, 200.f, 0.f );</div><div class="line"></div><div class="line"><span class="comment">// Tell GFX that the information is in and it should be made ready for use</span></div><div class="line"><span class="comment">// Note that nothing is done with verts, this should not and MUST NOT be deleted</span></div><div class="line"><span class="comment">// stored, or otherwise used after prepare is called.</span></div><div class="line">GFX-&gt;prepare( vb );</div><div class="line"></div><div class="line"><span class="comment">// Because this is a dynamic vertex buffer, it is only assured to be valid until someone </span></div><div class="line"><span class="comment">// else allocates a dynamic vertex buffer, so we will render it now</span></div><div class="line">GFX-&gt;setVertexBuffer( vb );</div><div class="line">GFX-&gt;drawPrimitive( GFXTriangleStrip, 0, 1 );</div><div class="line"></div><div class="line"><span class="comment">// Now because this is a dynamic vertex buffer it MUST NOT BE FREED you are only</span></div><div class="line"><span class="comment">// given a handle to a vertex buffer which belongs to the device</span></div></div><!-- fragment --><p>To use a static vertex buffer, it is very similar, this is an example using a static primitive buffer: <br />
This takes place inside a constructor for a class which has a member variable called mPB which is the primitive buffer for the class instance. </p><div class="fragment"><div class="line">U16 *idx;                          <span class="comment">// This is going to be where to write indices</span></div><div class="line">GFXPrimitiveInfo *primitiveInfo;   <span class="comment">// This will be where to write primitive information</span></div><div class="line"></div><div class="line"><span class="comment">// Allocate a primitive buffer with 4 indices, and 1 primitive described for use</span></div><div class="line">mPB = GFX-&gt;allocPrimitiveBuffer( 4, &amp;idx, 1, &amp;primitiveInfo );</div><div class="line"></div><div class="line"><span class="comment">// Write the index information, this is going to be for the outline of a triangle using</span></div><div class="line"><span class="comment">// a line strip</span></div><div class="line">idx[0] = 0;</div><div class="line">idx[1] = 1;</div><div class="line">idx[2] = 2;</div><div class="line">idx[3] = 0;</div><div class="line"></div><div class="line"><span class="comment">// Write the information for the primitive</span></div><div class="line">primitiveInfo-&gt;indexStart = 0;            <span class="comment">// Starting with index 0</span></div><div class="line">primitiveInfo-&gt;minVertex = 0;             <span class="comment">// The minimum vertex index is 0</span></div><div class="line">primitiveInfo-&gt;maxVertex = 3;             <span class="comment">// The maximum vertex index is 3</span></div><div class="line">primitiveInfo-&gt;primitiveCount = 3;        <span class="comment">// There are 3 lines we are drawing</span></div><div class="line">primitiveInfo-&gt;type = GFXLineStrip;       <span class="comment">// This primitive info describes a line strip</span></div></div><!-- fragment --><p> The following code takes place in the destructor for the same class </p><div class="fragment"><div class="line"><span class="comment">// Because this is a static buffer it&#39;s our responsibility to free it when we are done</span></div><div class="line">GFX-&gt;freePrimitiveBuffer( mPB );</div></div><!-- fragment --><p> This last bit takes place in the rendering function for the class </p><div class="fragment"><div class="line"><span class="comment">// You need to set a vertex buffer as well, primitive buffers contain indexing</span></div><div class="line"><span class="comment">// information, not vertex information. This is so you could have, say, a static</span></div><div class="line"><span class="comment">// vertex buffer, and a dynamic primitive buffer.</span></div><div class="line"></div><div class="line"><span class="comment">// This sets the primitive buffer to the static buffer we allocated in the constructor</span></div><div class="line">GFX-&gt;setPrimitiveBuffer( mPB );</div><div class="line"></div><div class="line"><span class="comment">// Draw the first primitive contained in the set primitive buffer, our primitive buffer</span></div><div class="line"><span class="comment">// has only one primitive, so we could also technically call GFX-&gt;drawPrimitives(); and</span></div><div class="line"><span class="comment">// get the same result. </span></div><div class="line">GFX-&gt;drawPrimitive( 0 );</div></div><!-- fragment --><p> If you need any more examples on how to use these buffers please see the rest of the engine. <br />
<b>Primitive Buffers</b> <br />
Primitive buffers wrap and extend the concept of index buffers. The purpose of a primitive buffer is to let objects store all information they have to render their primitives in a central place. Say that a shape is made up of triangle strips and triangle fans, it would still have only one primitive buffer which contained primitive information for each strip and fan. It could then draw itself with one call.</p>
<p>TO BE FINISHED LATER </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3e60f6690dbd79a0bd11e4af78f9fa6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSignal.html">Signal</a>&lt;bool (<a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDeviceEventType</a>)&gt; <a class="el" href="classGFXDevice.html#a3e60f6690dbd79a0bd11e4af78f9fa6a">GFXDevice::DeviceEventSignal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b9abcb3e6bdf6b3b0fc87782b86b3c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classMap.html">Map</a>&lt;U32, <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a>&gt; <a class="el" href="classGFXDevice.html#a8b9abcb3e6bdf6b3b0fc87782b86b3c7">GFXDevice::StateBlockMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ad4ec26ff908a29191c0052937d8154da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154da">GFXDevice::GenericShaderType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daab60202d148fd08874654a053d8f44b2f"></a>GSColor&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daaa05d34baac00a450eebc422f454484b2"></a>GSTexture&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daaf1a8a2a1e62fb248fd6f02dc6c056e4b"></a>GSModColorTexture&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daa7c17358274fe24d511d0288a08508ac6"></a>GSAddColorTexture&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daa34a78b46781cc6031aa53fb5579f21df"></a>GSTargetRestore&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad4ec26ff908a29191c0052937d8154daaff5c31aaf710208b40a3f78795b23d7e"></a>GS_COUNT&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGFXDevice.html#a7afb5ceeaa0ddff954175417e43d5141">GFXDevice::GFXDeviceEventType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a531f9b88d21ccaa4780797716753d0ce"></a>deCreate&#160;</td><td class="fielddoc">
<p>The device has been created, but not initialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a51ab624fd7dd399629f1e45d898ecaae"></a>deInit&#160;</td><td class="fielddoc">
<p>The device has been initialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a4f3b136d74fbcdfdf1aa8e488e13899e"></a>deDestroy&#160;</td><td class="fielddoc">
<p>The device is about to be destroyed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a05c1fa3c4a024c0978fc60a85c2999c1"></a>deStartOfFrame&#160;</td><td class="fielddoc">
<p>The device has started rendering a frame. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a83e2494cae3a09d7a22e515fcb449cd6"></a>deEndOfFrame&#160;</td><td class="fielddoc">
<p>The device is about to finish rendering a frame. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a7a077ed6b615369c276ab5bbc6a042a7"></a>dePostFrame&#160;</td><td class="fielddoc">
<p>The device has rendered a frame and ended the scene. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a2b34f47ff10868d4739a83017c69aff3"></a>deStartOfField&#160;</td><td class="fielddoc">
<p>The device has started rendering a frame's field (such as for side-by-side rendering) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a2b777ea4e88f4f030ec923d09b7748f4"></a>deLeftStereoFrameRendered&#160;</td><td class="fielddoc">
<p>left stereo frame has been rendered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a485c5070f709ecd02b8e7c4e2f8f2428"></a>deRightStereoFrameRendered&#160;</td><td class="fielddoc">
<p>right stereo frame has been rendered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7afb5ceeaa0ddff954175417e43d5141a9e62077d15f8445dcac3a0eca6638ddb"></a>deEndOfField&#160;</td><td class="fielddoc">
<p>The device is about to finish rendering a frame's field. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7a682b30e5aee6a9a7c1386ac7ad1f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34">GFXDevice::GFXDeviceLimits</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123"></a>NumStereoPorts&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad3225b9116288563b521a711d8e6a44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGFXDevice.html#ad3225b9116288563b521a711d8e6a44c">GFXDevice::GFXDeviceRenderStyles</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad3225b9116288563b521a711d8e6a44ca640da156ba21718ccab0ec48a0a7abcc"></a>RS_Standard&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad3225b9116288563b521a711d8e6a44ca603394ebbc96932384669f62d01e9067"></a>RS_StereoSideBySide&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad3225b9116288563b521a711d8e6a44caa23104185c2c48c386acba6216326e89"></a>RS_StereoSeparate&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2f57e2c8b460f93b5b38d9b28e788858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858">GFXDevice::TexDirtyType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2f57e2c8b460f93b5b38d9b28e788858ab0f98aa9f323f79e3adb72d0753a702d"></a>GFXTDT_Normal&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2f57e2c8b460f93b5b38d9b28e788858a90dd633a9fc928823e63ee9de6dade9c"></a>GFXTDT_Cube&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a42aae58e3b0dd2c1abe0050a8d556193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GFXDevice::GFXDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a578967fe4b2a5b92c6582bbb848f92a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GFXDevice::~GFXDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a051a7f704e1cc95a7340365561a92e9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::_updateRenderTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the render targets and viewport in a device specific manner when they are dirty. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a8e26af5148beb29082bbc03db2eb9557">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a8a6d3f00de4d7c3a3e9b0e6cee9e3577">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a2698d44d55c6b165fe18f7acbb4a4fff">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a2a7d74c4e05f361cae85e06904ae4310">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac828dc9eb9b8cd4eec6daf8090cc4639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::activateStereoTarget </td>
          <td>(</td>
          <td class="paramtype">S32&#160;</td>
          <td class="paramname"><em>eyeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates a stereo render target, setting the correct viewport to render eye contents. </p>
<p>If eyeId is -1, set a viewport encompassing the entire size of the render targets. </p>

<p>References <a class="el" href="classGFXDevice.html#aec7270b308ee6cb8dc7d44faccf67cad">setActiveRenderTarget()</a>, and <a class="el" href="classGFXDevice.html#aff095cc01fc3319d229996a16791b919">setViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f670d81f44d389c0b4c237244c0d8dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a>* GFXDevice::allocPrimitiveBuffer </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPrimitives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GFXBufferType&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This allocates a primitive buffer and returns a pointer to the allocated buffer. </p>
<p>A primitive buffer's type argument refers to the index data - the primitive data will always be preserved from call to call.</p>
<dl class="section note"><dt>Note</dt><dd>All index buffers use unsigned 16-bit indices. </dd></dl>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#aa25017d0ea5d261ffe809b4a17728f81">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a01b2e724e7b638010623d0532be0c35c">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#add8c457e343dd79631e5ee234bf561f9">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a112638cca71850f2b865f71c94cf3516">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad993db38e2a55452481cca1522a28d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a>* GFXDevice::allocRenderToTextureTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a target for doing render to texture operations, with no depth/stencil buffer. </p>

<p>Implemented in <a class="el" href="classGFXNullDevice.html#a1206f62cc7c8c3fb92b3d61f2fdff4c7">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#a789aeffc3b763e68112feff41db26542">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a6f4dc5ef82102ba78c05be1dd2b393a0">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="a43b296b835980733311084858243c676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a>* GFXDevice::allocVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GFXBufferType&#160;</td>
          <td class="paramname"><em>bufferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This allocates a vertex buffer and returns a pointer to the allocated buffer. </p>
<p>This function should not be called directly - rather it should be used by the <a class="el" href="classGFXVertexBufferHandle.html" title="A handle object for allocating, filling, and reading a vertex buffer. ">GFXVertexBufferHandle</a> class. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#aab6c2e202f9d78204bc2543f1c50bdb8">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a4de82fc26251efaf5318084db4735ee5">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a6f4e0ba662970a042094d3af75e81c2c">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a8567cabf2e05de0c3268c05cb3ddb927">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a38052299c52e6f333cf4b038e709520d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a>* GFXDevice::allocVertexDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="classGFXVertexFormat.html" title="The vertex format structure usually created via the declare and implement macros. ...">GFXVertexFormat</a> to allocate the hardware specific vertex declaration for rendering. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a19e6decb22fd611ca5170fdc08126089">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a94480f125774fe0b1907ae40b8a819b3">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a928cf0d36aba862bd32769e08bb5033f">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a07583e358063592af0c994d93790e304">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3c4da4638b532dd340bab16f22e00bb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXWindowTarget.html">GFXWindowTarget</a>* GFXDevice::allocWindowTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPlatformWindow.html">PlatformWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a target for a given window. </p>

<p>Implemented in <a class="el" href="classGFXNullDevice.html#af5f01e64046e1dc15347cc04c2e59f95">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#aa1adc3c0ad57c7571e00b4c26aa19cd1">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a36c5d06b65773949bf46ecaf843b052b">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="afc5d2c4cb480f486ecb002f514568353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::allowRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#ab3b997ba465a5c7481616b57cc496ea9">mAllowRender</a>.</p>

</div>
</div>
<a class="anchor" id="a31022933142174acd4f8598a80c14aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::beginField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bafdaef04ee0db78d8f5c443383363f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::beginReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a680e65eaac7a29c50d64b5f5865e7a13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GFXDevice::beginScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="acf399c09070ac19e3f3c45bc9f8cfea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GFXDevice::beginSceneInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a4669da9a9462e8f6c91fe0648aa80a77">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a5339a3dd43e22deb18aa71479b2bd3b2">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#af4486d9c56fd8df68e267e87edf636d8">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#aa1848fa16e3a3ce2ef4348b6835ce1e7">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a05abdeb128c2c7d96beeb1bd2794d289">GFXPCD3D9Device</a>.</p>

</div>
</div>
<a class="anchor" id="af6891dec318410ef94116b4ec950342c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::canCurrentlyRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the scene has begun and its safe to make rendering calls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXDevice.html#a680e65eaac7a29c50d64b5f5865e7a13">beginScene</a> </dd>
<dd>
<a class="el" href="classGFXDevice.html#a47fb94fdd451d5cbba2f4b5ebdb359c2">endScene</a> </dd></dl>

<p>References <a class="el" href="classGFXDevice.html#a0640c509f516369ded3ab66d8d033af4">mCanCurrentlyRender</a>.</p>

</div>
</div>
<a class="anchor" id="a184e7aecac375ebffa3c3eb0996d2c86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::clear </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classColorI.html">ColorI</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ad30a9bd0fac4291cb75e997678dc5b7b">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a8fe0bf62f92a6d4d2e50e54a36c8bb5c">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a275b81a452e62b51f29d844688b18d6d">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a22352ef082f174c8ce9abf32cbf0d733">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="a598f5fc5632f0b89e57668e7a5e7bd3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::clearResourceFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the flag on all resources GFX is currently aware of. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a2845d65759a6c57ee430ac522baa0591"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXCubemap.html">GFXCubemap</a>* GFXDevice::createCubemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a4308e2fa93bbcde4d421aa7b9517b99a">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#adaca6736079db498085d8d0517056150">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#ad4f1f6d186ad4115d14e551313da3bd8">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#ac71c7dac51c7a6464fa0a1944fcff014">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a4e618ec59bd3af2c80feebc76bcf9c4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXFence.html">GFXFence</a>* GFXDevice::createFence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a fence. </p>
<p>The API specific implementation of <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> is responsible to make sure that the proper type is used. <a class="el" href="classGFXGeneralFence.html">GFXGeneralFence</a> should work in all cases. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a168fa89ac8b9a3aaec94260b70fcf84f">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a98f09132dad21bb841ab8b02537e7b72">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a697a4cf3dd6a92fa4ca146c66e89509e">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a848af040ad854e53e7af4478088481a1">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0a363725d0a5402fc0b4889749371ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXOcclusionQuery.html">GFXOcclusionQuery</a>* GFXDevice::createOcclusionQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a hardware occlusion query object or NULL if this device does not support them. </p>

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#a36218845d1aa69ae69fd44fb5e5719d7">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a43d40c3e7bcd434dc2e2b419d2f80776">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a2c2f97d34b471310c9f368ed13e59c69">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#abb8fac9975611ec64fb377d5bd8a8096">GFXGLDevice</a>.</p>

<p>References <a class="el" href="classGFXDevice.html#a0cb2a85886f21b71656409abd3a8ffbd">setCubeTexture()</a>, <a class="el" href="classGFXDevice.html#a831d4a88a902bc9dc13afdb4727e0d99">setGlobalAmbientColor()</a>, <a class="el" href="classGFXDevice.html#a96b201f929f4c7c5bbcd723d32f132a5">setLight()</a>, <a class="el" href="classGFXDevice.html#a9287e5cd40c9b2944b9e6d51b1550fc3">setLightMaterial()</a>, and <a class="el" href="classGFXDevice.html#a25fd4143c2a3a02865b4d39b5a8b691d">setTexture()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1782edd3fa1bfb70fe6e2477139a450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXShader.html">GFXShader</a>* GFXDevice::createShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty shader which must be initialized and deleted by the caller. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXShader.html#a70047f0ef7cff2dec32519f8664dfceb" title="Deprecated. Remove on T3D 4.0. ">GFXShader::init</a> </dd></dl>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#aca05a3c10b5903e176fc374736ba4cf5">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a32cb14f82ab5bd7c4c0a4cda170e9e77">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a790a8901c066c319a9fc9ccf0ccb491b">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a0d15913b003b00e00a18913092d96207">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="aed6f0f49a3b0d9bea9149475a412c043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a> GFXDevice::createStateBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a state block object based on the desc passed in. </p>
<p>This object represents an immutable state. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a63ba3582c1126a073cee6627539e7020">getCurrentTexture()</a>.</p>

</div>
</div>
<a class="anchor" id="a984f77b6e3ae50d8149d7e09b90035d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a> GFXDevice::createStateBlockInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to create a device specific stateblock. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ae8860fe8ff87f56de9aa20c9353e0c92">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#acf442c3f094e749db9203d6636002f4d">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#ac350a4b2e0660e790463c54e126e3bad">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a1fa9999890b5a5bba7831b150b38c08a">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a6382f1469ffc3d9eea345808999d8ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::describeResources </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>resName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a description of the specified resource types to the console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resNames</td><td>A string of space separated class names (e.g. "GFXTextureObject GFXTextureTarget GFXShader") to describe to the console </td></tr>
    <tr><td class="paramname">file</td><td>A path to the file to write the descriptions to. If it is NULL or "", descriptions are written to the console. </td></tr>
    <tr><td class="paramname">unflaggedOnly</td><td>If true, this method only counts unflagged resources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>resNames is case sensitive because there is no dStristr function. </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f2b16b1eaf4224769547cbe0959eaab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GFXDevice::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#af69076c283dcd2631fd01f9ac8e9b750">get()</a>.</p>

</div>
</div>
<a class="anchor" id="ab885e8132647e1b6ebbc5d24bad2c950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::deviceInited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> that we are initialized. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ca769dd2c67d56ae1b19f4f9212d47f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GFXDevice::devicePresent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a16b07c823a86a49eb070bfcf24ee98cc">getAdapterType()</a>.</p>

</div>
</div>
<a class="anchor" id="a175a2ba572ca80f0023c0ccdbce2ba8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::disableShaders </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#ac8411518360e879585a371e19a60a359">GFXD3D9Device</a>.</p>

<p>References <a class="el" href="classGFXDevice.html#a31022933142174acd4f8598a80c14aec">beginField()</a>, <a class="el" href="classGFXDevice.html#a680e65eaac7a29c50d64b5f5865e7a13">beginScene()</a>, <a class="el" href="classGFXDevice.html#a184e7aecac375ebffa3c3eb0996d2c86">clear()</a>, <a class="el" href="classGFXDevice.html#ac1782edd3fa1bfb70fe6e2477139a450">createShader()</a>, <a class="el" href="classGFXDevice.html#a0fbba63f9d9a6dbb5f4d90e39fa2d0f1">endField()</a>, <a class="el" href="classGFXDevice.html#a47fb94fdd451d5cbba2f4b5ebdb359c2">endScene()</a>, and <a class="el" href="classGFXDevice.html#a1fbeeb26e49406db965dd8da7c3cf778">setShaderConstBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ad38d3e939c2395566a6dddd70f2e42d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::doParanoidStateCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#a5166ed70a538182cb1497a6e604b1178">GFXD3D9Device</a>, and <a class="el" href="classGFXD3D11Device.html#ac0892aa7cdd4f58b8d0c8930e7b7c120">GFXD3D11Device</a>.</p>

<p>References <a class="el" href="classGFXDevice.html#a8d70d5cb8bdbb63f3d56c3295fa794f7">dumpStates()</a>, and <a class="el" href="classGFXDevice.html#aa2771e16ff7e612d0755fe0ef1c45e74">getDrawUtil()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd9e832fd0c3cf2946e9bbb1c1a7544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::drawIndexedPrimitive </td>
          <td>(</td>
          <td class="paramtype">GFXPrimitiveType&#160;</td>
          <td class="paramname"><em>primType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>startVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>minIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>primitiveCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parameters to drawIndexedPrimitive are somewhat complicated. </p>
<p>From a raw-data stand point they evaluate to something like the following: </p><div class="fragment"><div class="line">U16 indicies[] = { 0, 1, 2, 1, 0, 0, 2 }; </div><div class="line"><a class="code" href="classPoint3F.html">Point3F</a> verts[] = { <a class="code" href="classPoint3F.html">Point3F</a>( 0.0f, 0.0f, 0.0f ), <a class="code" href="classPoint3F.html">Point3F</a>( 0.0f, 1.0f, 0.0f ), <a class="code" href="classPoint3F.html">Point3F</a>( 0.0f, 0.0f, 1.0f ) };</div><div class="line"></div><div class="line">GFX-&gt;drawIndexedPrimitive( GFXLineList, <span class="comment">// Drawing a list of lines, each line is two verts</span></div><div class="line">                           0, <span class="comment">// vertex 0 will be referenced so minIndex = 0</span></div><div class="line">                           3, <span class="comment">// 3 verticies will be used for this draw call</span></div><div class="line">                           1, <span class="comment">// We want index 1 to be the first index used, so indicies 1-6 will be used</span></div><div class="line">                           3  <span class="comment">// Drawing 3 LineList primitives, meaning 6 verts will be drawn</span></div><div class="line">                            );</div><div class="line"></div><div class="line">U16 *idxPtr = &amp;indicies[1];  <span class="comment">// 1 = startIndex, so the pointer is offset such that:</span></div><div class="line">                             <span class="comment">//    idxPtr[0] is the same as indicies[1]</span></div><div class="line"></div><div class="line">U32 numVertsToDrawFromBuffer = primitiveCount * 2; <span class="comment">// 2 verts define a line in the GFXLineList primitive type (6)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primType</td><td>Type of primitive to draw</td></tr>
    <tr><td class="paramname">startVertex</td><td>This defines index zero. Its the offset from the start of the vertex buffer to the first vertex.</td></tr>
    <tr><td class="paramname">minIndex</td><td>The smallest index into the vertex stream which will be used for this draw call. This is a zero based index relative to startVertex. It is strictly a performance hint for implementations. No vertex below minIndex will be referenced by this draw call. For device implementors, this should <em>not</em> be used to offset the vertex buffer, or index buffer.</td></tr>
    <tr><td class="paramname">numVerts</td><td>The number of verticies which will be referenced in this draw call. This is not the number of verticies which will be drawn. That is a function of 'primType' and 'primitiveCount'.</td></tr>
    <tr><td class="paramname">startIndex</td><td>An offset from the start of the index buffer to specify where to start. If 'idxBuffer' is a pointer to an array of integers, this could be written as int *offsetIdx = idxBuffer + startIndex;</td></tr>
    <tr><td class="paramname">primitiveCount</td><td>The number of primitives of type 'primType' to draw. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ad1616c4173b48caac3843b368a789612">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ad2ef0989b63c9b4c0633f43ab96ad109">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#ac9f23e9fd95a363a4f7cbdf0877a2c88">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#af3304c6c333b0acf0262d63094ed844f">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="acd73fd289201b74cad6f80c5bbd82fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::drawPrimitive </td>
          <td>(</td>
          <td class="paramtype">GFXPrimitiveType&#160;</td>
          <td class="paramname"><em>primType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertexStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>primitiveCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#afab4432e4a507c1169e81546d865c661">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a0443037e37e9453ff9ea9065cba46ae1">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#ae075597bcfbec46c182e15e2818b42bd">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a0d5a9bc0fb35953d176f25d67481c50d">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ab38816c438c3a1caa45e3e7cd8f337b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::drawPrimitive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXPrimitive.html">GFXPrimitive</a> &amp;&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6040e00f4c6cd5cbef7fececa692a5aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::drawPrimitive </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>primitiveIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a25998cf14ca686f28529dda2cb6c50ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::drawPrimitiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a5368f06eef65c7cc370292d3b060b532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::drawPrimitives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d70d5cb8bdbb63f3d56c3295fa794f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::dumpStates </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a method designed for debugging. </p>
<p>It will allow you to dump the states in the render manager out to a file so that it can be diffed and examined. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ad38d3e939c2395566a6dddd70f2e42d4">doParanoidStateCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a0fbba63f9d9a6dbb5f4d90e39fa2d0f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::endField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="a47fb94fdd451d5cbba2f4b5ebdb359c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::endScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9b636000d55dc81bded299d5fe47b65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::endSceneInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ab900effe166a632018f7117543560f4b">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a83ce753c4f6b47443fdd53ed4decbd34">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a5fe893f640b51559e02f87a55d62a80e">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a75607a4dba9cb844c8bc4020d93c3e5f">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a36fbc0a8a18c83bee5aa3c4984905e94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::enterDebugEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classColorI.html">ColorI</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXNullDevice.html#a41a701bfab0167b14cde9b86b7189caf">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#ae182d64e926df462365bb334502d4311">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#afd62516277b4da1a8b66101ce60f115c">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a205d1b053188b4fb95aea848e3302dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::enumerateVideoModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXNullDevice.html#a2230c27cf01974d890a19e8e12dc82ef">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#a24121f46529eb7ad796c6b96eaf07854">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a5f78d31a5df96474b6b13be3f445da40">GFXPCD3D9Device</a>.</p>

</div>
</div>
<a class="anchor" id="a64bbcac49b45197d05fc5534b65551f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::fillResourceVectors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>resNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textureObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textureTargets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>windowTargets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>primitiveBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>fences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubemaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>shaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classGFXResource.html">GFXResource</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateblocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a helper method for describeResourcesToFile. </p>
<p>It walks through the <a class="el" href="classGFXResource.html" title="Mixin for the purpose of tracking GFX resources owned by a GFXDevice. ">GFXResource</a> list and sorts it by item type, putting the resources into the proper vector. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXDevice.html#a6382f1469ffc3d9eea345808999d8ede" title="Dumps a description of the specified resource types to the console. ">describeResources</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4073437d6c949e49416478ac6bac5b2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::finalizeReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ade2f7cc426b59410e378661a0c826ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::flagCurrentResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags all resources GFX is currently aware of. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="af69076c283dcd2631fd01f9ac8e9b750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGFXDevice.html">GFXDevice</a>* GFXDevice::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a4f2b16b1eaf4224769547cbe0959eaab">destroy()</a>, and <a class="el" href="classGFXDevice.html#a5d7d39ded294eb76d3c87a464fe6b675">initConsole()</a>.</p>

</div>
</div>
<a class="anchor" id="ae56964c4831dd3a1f6c1819be6bf7ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTarget.html">GFXTarget</a>* GFXDevice::getActiveRenderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current active render target. </p>

<p>References <a class="el" href="classGFXDevice.html#a4f1305c77b9071c68c7e72f267f40946">getNumRenderTargets()</a>, <a class="el" href="classGFXDevice.html#a54209fc4a4c1bef924d7bfa13d615ca3">getNumSamplers()</a>, <a class="el" href="classGFXDevice.html#a3a72024c21bc9f43c11e90e15fe86343">getPixelShaderVersion()</a>, <a class="el" href="classGFXDevice.html#af34099197db5b16c78de828ad781ef30">mCurrentRT</a>, and <a class="el" href="classGFXDevice.html#aa02b6f74b519b52757c71f744df7f092">setPixelShaderVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0bf19f579f4342e471b8d951963298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structGFXAdapter.html">GFXAdapter</a>&amp; GFXDevice::getAdapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Adapter that was used to create this device. </p>

<p>References <a class="el" href="classGFXDevice.html#a598f5fc5632f0b89e57668e7a5e7bd3c">clearResourceFlags()</a>, <a class="el" href="classGFXDevice.html#a6382f1469ffc3d9eea345808999d8ede">describeResources()</a>, <a class="el" href="classGFXDevice.html#a36fbc0a8a18c83bee5aa3c4984905e94">enterDebugEvent()</a>, <a class="el" href="classGFXDevice.html#ade2f7cc426b59410e378661a0c826ba2">flagCurrentResources()</a>, <a class="el" href="classGFXDevice.html#aca2c1dadf2039bf1441d26e8342388a5">leaveDebugEvent()</a>, <a class="el" href="classGFXDevice.html#ac593d7a7e1a885c152a1286ea0ce3414">listResources()</a>, and <a class="el" href="classGFXDevice.html#a3bc83e217ed0133cb9b9267683b03475">setDebugMarker()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b07c823a86a49eb070bfcf24ee98cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GFXAdapterType GFXDevice::getAdapterType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns active graphics adapter type. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ac967c2f8cb035b712927dfc99d064a5a">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a65bac57eb8b26f870493a89f467384a5">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#afbeb739f044c4cefd6adb508830f20a4">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a72be42d5e38bec660fdf18429522b601">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a1ca769dd2c67d56ae1b19f4f9212d47f">devicePresent()</a>, and <a class="el" href="classGFXDevice.html#a3c5f1cf6b3214e266d5fa63cc2b97539">getCardProfiler()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5f1cf6b3214e266d5fa63cc2b97539"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXCardProfiler.html">GFXCardProfiler</a>* GFXDevice::getCardProfiler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a16b07c823a86a49eb070bfcf24ee98cc">getAdapterType()</a>, and <a class="el" href="classGFXDevice.html#a42308d582bcfd5bcfc4be84ad5b74b36">mCardProfiler</a>.</p>

</div>
</div>
<a class="anchor" id="a80b3fbc6868e209a0ecec65c68b856b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classRectI.html">RectI</a>&amp; GFXDevice::getClipRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ae4474073d77a537c7f144bdffea2e425">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a80451ba31efe7037786c337db6157d97">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a23b98b412ac3fa40269d9fecb4dc46b5">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a7499d5f22d71ecf396dcc4d3a474eb7c">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="af0e3f85ba5431ed2ad27fc5c4312dd0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 GFXDevice::getCurrentRenderStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current rendering style based on GFXDeviceRenderStyles. </p>

<p>References <a class="el" href="classGFXDevice.html#a512cbf498248d8312d4403e5992f58bd">mCurrentRenderStyle</a>.</p>

</div>
</div>
<a class="anchor" id="ac311ad224954a89f24ba649a2825ceec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S32 GFXDevice::getCurrentStereoTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current stereo target being rendered to. </p>

<p>References <a class="el" href="classGFXDevice.html#aee3c4c42b4d22530a1a69fc7de1334ec">mCurrentStereoTarget</a>.</p>

</div>
</div>
<a class="anchor" id="a63ba3582c1126a073cee6627539e7020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTextureObject.html">GFXTextureObject</a>* GFXDevice::getCurrentTexture </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#aed6f0f49a3b0d9bea9149475a412c043">createStateBlock()</a>, and <a class="el" href="classGFXDevice.html#a13a2407e0e26a6eb50614d0609132b43">setStateBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a22e92df30409a034b51dfb9a906f7627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGFXDevice.html#a3e60f6690dbd79a0bd11e4af78f9fa6a">DeviceEventSignal</a>&amp; GFXDevice::getDeviceEventSignal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a707344e1c602854a433551c379c432d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a>* GFXDevice::getDeviceStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current <a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a>, stats are cleared every ::beginScene call. </p>

<p>References <a class="el" href="classGFXDevice.html#aef70d216314854ef1cdd7f601c17f38e">mDeviceStatistics</a>.</p>

</div>
</div>
<a class="anchor" id="a936a62a3dd886a1ec053b8cc42bf0d12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSwizzle.html">Swizzle</a>&lt;U8, 3&gt;* GFXDevice::getDeviceSwizzle24 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSwizzle.html" title="This class will swizzle &#39;sizeof( T )&#39; length chunks of memory into different patterns which are user ...">Swizzle</a> to convert 24bpp bitmaps from RGB to the native device format. </p>

<p>References <a class="el" href="classGFXDevice.html#ad993db38e2a55452481cca1522a28d38">allocRenderToTextureTarget()</a>, <a class="el" href="classGFXDevice.html#a3c4da4638b532dd340bab16f22e00bb1">allocWindowTarget()</a>, <a class="el" href="classGFXDevice.html#a43c873557881c5019fbe8671a18a05bb">mDeviceSwizzle24</a>, <a class="el" href="classGFXDevice.html#a0397a347c5f3211860979b0a107e3203">popActiveRenderTarget()</a>, <a class="el" href="classGFXDevice.html#ac6e7907ef7d8a23c57f74ccdc0ac4339">pushActiveRenderTarget()</a>, and <a class="el" href="classGFXDevice.html#aec7270b308ee6cb8dc7d44faccf67cad">setActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="a6fdbb77883a6fcca9ae65fabae68c2ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSwizzle.html">Swizzle</a>&lt;U8, 4&gt;* GFXDevice::getDeviceSwizzle32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSwizzle.html" title="This class will swizzle &#39;sizeof( T )&#39; length chunks of memory into different patterns which are user ...">Swizzle</a> to convert 32bpp bitmaps from RGBA to the native device format. </p>

<p>References <a class="el" href="classGFXDevice.html#afa819b68c170b3ed9540dabc2d631090">mDeviceSwizzle32</a>.</p>

</div>
</div>
<a class="anchor" id="acdfc90cf657e9a85cb3189c3452f5479"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GFXDevice::getDisableOcclusionQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occlusion query is disabled. </p>

<p>References <a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix()</a>, and <a class="el" href="classGFXDevice.html#a01aa3220067accab7a93c8b3149b50c1">smDisableOcclusionQuery</a>.</p>

</div>
</div>
<a class="anchor" id="aa2771e16ff7e612d0755fe0ef1c45e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDrawUtil.html">GFXDrawUtil</a>* GFXDevice::getDrawUtil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to this device's drawing utility class. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ad38d3e939c2395566a6dddd70f2e42d4">doParanoidStateCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a5ad5aff2a286e12b8396e024d8e33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual F32 GFXDevice::getFillConventionOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the fill convention for this device. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a5de8b32f3f5e5ff12f2d62f12aebd1e5">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a6ef1cc159dbbcf795535ad8e4f89ac11">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#aebea17888dcd96c8b3f3ccab7a8d81ef">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#ac66d589d037d9490f3e96efeb290de52">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ab07a4b0ac3141200a820922b58da5107">setupGenericShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="aac0f42c65529f7db671b731bd38d2492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGFXTexHandle.html">GFXTexHandle</a>&amp; GFXDevice::getFrontBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a4e618ec59bd3af2c80feebc76bcf9c4f">createFence()</a>, <a class="el" href="classGFXDevice.html#a9fd9e832fd0c3cf2946e9bbb1c1a7544">drawIndexedPrimitive()</a>, <a class="el" href="classGFXDevice.html#acd73fd289201b74cad6f80c5bbd82fc3">drawPrimitive()</a>, <a class="el" href="classGFXDevice.html#a25998cf14ca686f28529dda2cb6c50ae">drawPrimitiveBuffer()</a>, <a class="el" href="classGFXDevice.html#a5368f06eef65c7cc370292d3b060b532">drawPrimitives()</a>, <a class="el" href="classGFXDevice.html#adbe369bc897df355de806d52a3aeafe3">mCurrentFrontBufferIdx</a>, <a class="el" href="classGFXDevice.html#a27f5f906b6757e53a837df0fd90b0b51">setPrimitiveBuffer()</a>, <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>, and <a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a6682a478e5ec9ab1bdced5f6c3674d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::getFrustum </td>
          <td>(</td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isOrtho</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the projection frustum. </p>

</div>
</div>
<a class="anchor" id="a20267e71efa9d22e5effe9632a7fd736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFrustum.html">Frustum</a>&amp; GFXDevice::getFrustum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the projection frustum. </p>

<p>References <a class="el" href="classGFXDevice.html#a35f71a1fbf81f4866c8916078e5e3f0a">mFrustum</a>, and <a class="el" href="classGFXDevice.html#ac919f3f4e11d349b3919f851a40c7f4d">setOrtho()</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="afe3946bcacb1fe7cce0a5ad2a808d683"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>* GFXDevice::getInverseStereoEyeTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#ab28b3396082a57edce8055de839fc3f3">mInverseStereoEyeTransforms</a>.</p>

</div>
</div>
<a class="anchor" id="aab91faf2269e73d98e8c3b9a79c0af5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual U32 GFXDevice::getMaxDynamicIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#aac5c2035adbd1aef61cb8ca082c3e9bf">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a388af71a1fb39bf670195bebfb1ea37c">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a071162c800b91e2b57e9ba324accdb2d">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#af253c9fc0a94dfecef920c6425f56fb7">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ab07a4b0ac3141200a820922b58da5107">setupGenericShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="a53d2bcf9c0c38f90bfbd3c01af125a96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual U32 GFXDevice::getMaxDynamicVerts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a0b9c26764e53fdb15a6d4b4eb2d24566">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a37cc2a1a08f90c1117835a298f6205dc">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a599b020f63a2147ae38e1d927ee1d1e3">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#af58c5ec6477c423776d0b88f9153aaf6">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ab07a4b0ac3141200a820922b58da5107">setupGenericShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f1305c77b9071c68c7e72f267f40946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual U32 GFXDevice::getNumRenderTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of simultaneous render targets supported by the device. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a36569d34085bfc4d42c477efe99e09d8">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ab609ffea72fc7d046d13d715a7381e67">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#ae70313d981a34555e4891a83cdfa7499">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#ad7b5d826b18dbd2c4f753c536403c584">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="a54209fc4a4c1bef924d7bfa13d615ca3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual U32 GFXDevice::getNumSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of texture samplers that can be used in a shader rendering pass. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a21b40380a4aea18a9662787c532ce159">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a02036bc8cb24ada62455bd8f9e426680">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a83c160a5e1a1f78b7f550ecd4c3e8527">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#ab8163afcb80b6574a569c10ffd460de4">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a72024c21bc9f43c11e90e15fe86343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual F32 GFXDevice::getPixelShaderVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ac5d5fab854951a84974ed849922e5132">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#abed121579ee2c69d0a032680c3830ecb">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#aeb5a937bc37e630fcd354bdd21f402cc">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a57aeb45d5bc0f3015b566cffcd237899">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8491b8ad4fbe1c529c13886d48ac419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>&amp; GFXDevice::getProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the projection matrix. </p>

<p>References <a class="el" href="classGFXDevice.html#a3258f45fb86b003b11c54e91e5ade8a5">mProjectionMatrix</a>, and <a class="el" href="classGFXDevice.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2a86920cddd637f7bb2e33c16de9cd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXStateBlock.html">GFXStateBlock</a>* GFXDevice::getStateBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a35efe65723aa02af5fd8a16444a4d1fb">mNewStateBlock</a>, <a class="el" href="classGFXDevice.html#ad607356d34ebcaea70c35614f724b498">setStateBlockByDesc()</a>, and <a class="el" href="classGFXDevice.html#af2c5f9b69134353c0a6f3663ca2feece">updateStates()</a>.</p>

</div>
</div>
<a class="anchor" id="a774881e8870ee0dcb8d2116d6aef5a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint3F.html">Point3F</a>* GFXDevice::getStereoEyeOffsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current eye offset used during stereo rendering. </p>

<p>References <a class="el" href="classGFXDevice.html#a7c85d356eebe4d5c9e13938073f0b2e4">mStereoEyeOffset</a>.</p>

</div>
</div>
<a class="anchor" id="abc7fb9d807efd6e23c3d5316b25ecaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>* GFXDevice::getStereoEyeTransforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a0a9719978834b18a8591dbb2b9b8bd35">mStereoEyeTransforms</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf529e9c3301c71809b7cb41b052dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFovPort.html">FovPort</a>* GFXDevice::getStereoFovPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current eye offset used during stereo rendering. </p>

<p>References <a class="el" href="classGFXDevice.html#a51b9da8251f994a5b89a8999b865148c">mFovPorts</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4a01652d52c2d9884586959513d733"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>&amp; GFXDevice::getStereoHeadTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a8acce4a751019055aaf5e767203427dd">mStereoHeadTransform</a>.</p>

</div>
</div>
<a class="anchor" id="a02192f0d2b16306a5660e4f7c7d7d7d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRectI.html">RectI</a>* GFXDevice::getStereoViewports </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a5b078eeae79f9883a8ca2c5474819e65">mStereoViewports</a>.</p>

</div>
</div>
<a class="anchor" id="ae530441812a0b904302c77c30d6bc6ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTextureManager.html">GFXTextureManager</a>* GFXDevice::getTextureManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a42dbd3cae371b904e59d669b6e44382e">mTextureManager</a>.</p>

</div>
</div>
<a class="anchor" id="a1bcfdaaf73855c6ba53e472eb1d700b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="structGFXVideoMode.html">GFXVideoMode</a>&gt;* const GFXDevice::getVideoModeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the video mode list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structGFXVideoMode.html">GFXVideoMode</a> </dd></dl>

<p>References <a class="el" href="classGFXDevice.html#a9a99c283f886c8f2b009c5d981e27ad1">mVideoModes</a>, and <a class="el" href="classGFXDevice.html#a584fb79c33de9df4ebdbe8531b17b865">selectSupportedFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb96149889ba6465948deec8f1646bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>&amp; GFXDevice::getViewMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the view matrix. </p>

<p>References <a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld()</a>, <a class="el" href="classGFXDevice.html#a8914b619a373d5c753a7bae8b40140e9">mViewMatrix</a>, <a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix()</a>, and <a class="el" href="classGFXDevice.html#aff095cc01fc3319d229996a16791b919">setViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="a438a05795dc86bad94a7a1e9dffdd1e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classRectI.html">RectI</a>&amp; GFXDevice::getViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current area of the target we will render to. </p>

<p>References <a class="el" href="classGFXDevice.html#a80b3fbc6868e209a0ecec65c68b856b9">getClipRect()</a>, <a class="el" href="classGFXDevice.html#a20267e71efa9d22e5effe9632a7fd736">getFrustum()</a>, <a class="el" href="classGFXDevice.html#ad43e47fe86d99aed8172572a044bc4aa">mViewport</a>, <a class="el" href="classGFXDevice.html#afca6babdb0e6e95db55663e506a55d6a">setClipRect()</a>, and <a class="el" href="classGFXDevice.html#a468d8c68aa637bd4ff58fd4ec61a52d0">setFrustum()</a>.</p>

</div>
</div>
<a class="anchor" id="adc04807e3c0888dc6ccce3fc4f5a4343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool GFXDevice::getWireframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the forced global wireframe state. </p>

<p>References <a class="el" href="classGFXDevice.html#a29ad06dc744102faf1f4098114920931">smWireframe</a>.</p>

<p>Referenced by <a class="el" href="structSceneData.html#a37a53b2c2386e2d51c6e7c1d33a75a18">SceneData::init()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f27a6b462aa7d9b393ae9b528b00e00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixF.html">MatrixF</a>&amp; GFXDevice::getWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the matrix on the top of the world matrix stack. </p>

<p>References <a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a>, <a class="el" href="classGFXDevice.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix()</a>, and <a class="el" href="classGFXDevice.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="accb03342ccba47508daf1c98f08f08af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint2F.html">Point2F</a> GFXDevice::getWorldToScreenScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scale for converting world space units to screen space units... </p>
<p>aka pixels.</p>
<p>This is the true scale which is best used for GUI drawing. For doing lod calculations you should be using the functions in SceneState which is adjusted for special cases like shadows and reflections.</p>
<dl class="section see"><dt>See also</dt><dd>SceneState::getWorldToScreenScale() </dd>
<dd>
SceneState::projectRadius() </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a05cb441df9be45731b1bd4ee66d83f81">isFrustumOrtho()</a>.</p>

</div>
</div>
<a class="anchor" id="a975e77604d95bf67bf892a6bc6ddf15a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXVideoMode.html">GFXVideoMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPlatformWindow.html">PlatformWindow</a> *&#160;</td>
          <td class="paramname"><em>window</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize this <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a>, optionally specifying a platform window to bind to. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a69611fea353af3d0bbb9cdfc786e574e">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ae5d3ba834f25d9d5e04cd538180c98e6">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#ad138b51173d1a6f4717c4b6d4a2be619">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#abd14488627b624867e97ecaeb384e3be">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#ac4014c1bed0da4720be2c79bf9f9d4ee">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a4dfb10ddda5a685595ebdbe6c939eba4">setAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d7d39ded294eb76d3c87a464fe6b675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void GFXDevice::initConsole </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#af69076c283dcd2631fd01f9ac8e9b750">get()</a>.</p>

</div>
</div>
<a class="anchor" id="aa22f5f747e2aefd7912edb2f85521cf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::initStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State initialization. </p>
<p>This MUST BE CALLED in setVideoMode after the device is created. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a5ed4f8899a6544fb8dee28d28dbf0afe">GFXD3D9Device</a>, <a class="el" href="classGFXGLDevice.html#a9de7e0283f8eaae015bc9902074acdd9">GFXGLDevice</a>, <a class="el" href="classGFXNullDevice.html#ab55b0c52da394842b1f273890c13f3fc">GFXNullDevice</a>, <a class="el" href="classGFXD3D11Device.html#a63644a620f40601b7efb5ac8ec93cc78">GFXD3D11Device</a>, and <a class="el" href="classGFXPCD3D9Device.html#af2951edb788c071940cc62027f0da65f">GFXPCD3D9Device</a>.</p>

</div>
</div>
<a class="anchor" id="a05cb441df9be45731b1bd4ee66d83f81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::isFrustumOrtho </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the current frustum uses orthographic projection rather than perspective projection. </p>

<p>References <a class="el" href="classGFXDevice.html#accb03342ccba47508daf1c98f08f08af">getWorldToScreenScale()</a>, and <a class="el" href="classFrustum.html#a24ae8353463331095ae74bdbab4d483f">Frustum::isOrtho()</a>.</p>

</div>
</div>
<a class="anchor" id="aca2c1dadf2039bf1441d26e8342388a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::leaveDebugEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXNullDevice.html#af01e7899f1b7507a6ecfb84e88b413bc">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#a92c017d9c6c872b5a687255fb58a4710">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a9d54c4388e3f096ca4019e27b1320c3a">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="ac593d7a7e1a885c152a1286ea0ce3414"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::listResources </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unflaggedOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists how many of each GFX resource (e.g. </p>
<p>textures, texture targets, shaders, etc.) GFX is aware of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unflaggedOnly</td><td>If true, this method only counts unflagged resources </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2dd2cb45f6c371e03b065b02b4a648b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::multWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the matrix at the top of the world matrix stack by a matrix and replaces the top of the matrix stack with the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to multiply </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classMatrixF.html#ad2d6dbc4ed5a9499a861377770f74286">MatrixF::mul()</a>, <a class="el" href="classGFXDevice.html#aff5d637cc039b275af5f1c121f329dc3">mWorldMatrix</a>, <a class="el" href="classGFXDevice.html#ab92eb4b02fb61b330b3ee5ddbfcd29ba">mWorldMatrixDirty</a>, and <a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a0397a347c5f3211860979b0a107e3203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::popActiveRenderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the previous render target. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3a2651759c03f2c039fb775961a09c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::popWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the world matrix stack. </p>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#ab92eb4b02fb61b330b3ee5ddbfcd29ba">mWorldMatrixDirty</a>, and <a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b7c66bfbb861c43a14b330cbe337e24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::preDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called before this, or any other device, is deleted in the global <a class="el" href="classGFXDevice.html#a4f2b16b1eaf4224769547cbe0959eaab">destroy()</a> method. </p>
<p>It allows the device to clean up anything while everything is still valid. </p>

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#a3f4fcef6dc9dd8736e1e1e70c0249f2a">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a498cf2682dc3c0206f59d6137782735f">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a2c3b4185bdf26223296e6d60513db232">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#ad41086c6c8fe21c6848a4a0840487af7">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXGLDevice.html#ad41086c6c8fe21c6848a4a0840487af7">GFXGLDevice::preDestroy()</a>, and <a class="el" href="classGFXD3D11Device.html#a498cf2682dc3c0206f59d6137782735f">GFXD3D11Device::preDestroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6e7907ef7d8a23c57f74ccdc0ac4339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::pushActiveRenderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the current render target to restore later. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b012283186cb887f4bda73b35fad1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::pushWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the world matrix stack and copies the current top matrix to the new top of the stack. </p>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#aff5d637cc039b275af5f1c121f329dc3">mWorldMatrix</a>, <a class="el" href="classGFXDevice.html#ab92eb4b02fb61b330b3ee5ddbfcd29ba">mWorldMatrixDirty</a>, and <a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a1eab068a5df508c89b42926e272ab4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::recentlyReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classGFXDevice.html#a355c4a54be462dcd9aa41ed9c9bfe88c">mReset</a>.</p>

</div>
</div>
<a class="anchor" id="a584fb79c33de9df4ebdbe8531b17b865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GFXFormat GFXDevice::selectSupportedFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXTextureProfile.html">GFXTextureProfile</a> *&#160;</td>
          <td class="paramname"><em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; GFXFormat &gt; &amp;&#160;</td>
          <td class="paramname"><em>formats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mustblend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mustfilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first format from the list which meets all the criteria of the texture profile and query options. </p>

<p>Implemented in <a class="el" href="classGFXNullDevice.html#ade7b1034df1985fd5d54dd8472fdf6bd">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#ae0aaebd6db8cad739780dd3111d55b6a">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#aef59c65a6e3316dafc33923a7217d121">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a1bcfdaaf73855c6ba53e472eb1d700b3">getVideoModeList()</a>.</p>

</div>
</div>
<a class="anchor" id="aec7270b308ee6cb8dc7d44faccf67cad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setActiveRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXTarget.html">GFXTarget</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateViewport</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a new active render target. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ac828dc9eb9b8cd4eec6daf8090cc4639">activateStereoTarget()</a>, and <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dfb10ddda5a685595ebdbe6c939eba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setAdapter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXAdapter.html">GFXAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the adapter that this device is using. For use by <a class="el" href="classGFXInit.html#a7a3cf47311dbb6edf16a0b37d5048dff" title="Creates a GFXDevice based on an adapter from the enumerateAdapters method. ">GFXInit::createDevice</a> only. </p>

<p>References <a class="el" href="classGFXDevice.html#ab885e8132647e1b6ebbc5d24bad2c950">deviceInited()</a>, <a class="el" href="classGFXDevice.html#a42aae58e3b0dd2c1abe0050a8d556193">GFXDevice()</a>, <a class="el" href="classGFXDevice.html#a975e77604d95bf67bf892a6bc6ddf15a">init()</a>, and <a class="el" href="classGFXDevice.html#a578967fe4b2a5b92c6582bbb848f92a4">~GFXDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="aba845cb4964bf84eb90a8fa97e38adda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setAllowRender </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>render</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afca6babdb0e6e95db55663e506a55d6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setClipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a2809375ff4f8d08d15707686853e1893">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a187c7879d1a4dcce435332cb89928304">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a67626f0f69627d4a8b5b39a6e9414c6d">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a1023aca5fc2bddf0607490f95cf60636">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cb2a85886f21b71656409abd3a8ffbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setCubeTexture </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGFXCubemap.html">GFXCubemap</a> *&#160;</td>
          <td class="paramname"><em>cubemap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="aa16f89a7d220bb185911b325a168a6a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setCurrentRenderStyle </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current rendering style, based on GFXDeviceRenderStyles. </p>

</div>
</div>
<a class="anchor" id="a0fdc4198cbd7b593a18ca8be755f8998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setCurrentStereoTarget </td>
          <td>(</td>
          <td class="paramtype">const F32&#160;</td>
          <td class="paramname"><em>targetId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current stereo target being rendered to (in case we're doing anything with postfx) </p>

</div>
</div>
<a class="anchor" id="a3bc83e217ed0133cb9b9267683b03475"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setDebugMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classColorI.html">ColorI</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXNullDevice.html#a8c2e9028a56312165845c90992f08e72">GFXNullDevice</a>, <a class="el" href="classGFXGLDevice.html#afe23843e4e3b920de8a07ba5ab57e161">GFXGLDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a4b79ff7df2708ef3d198e6a3a5c80abf">GFXPCD3D9Device</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9c0bf19f579f4342e471b8d951963298">getAdapter()</a>.</p>

</div>
</div>
<a class="anchor" id="a468d8c68aa637bd4ff58fd4ec61a52d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setFrustum </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRotate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection frustum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceMathUtils.html#ae65570815e13b8e2219a117820724ba7" title="Build the frustum near plane dimensions from the parameters. ">MathUtils::makeFrustum()</a> </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="a7df6e3d25a5ecb94ba43faccba4a3c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setFrustum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRotate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a831d4a88a902bc9dc13afdb4727e0d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setGlobalAmbientColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColorF.html">ColorF</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="a2382cb2b32a67827e6b6cc8f95afc30f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setGlobalAmbientInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classColorF.html">ColorF</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a7b6494a0c556bbc2e7d63c9b3f07580c">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#af0515113ae0bed4dea842280e0116a5f">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a9e9df2100754fcccd11dda4cd0fa97d1">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#aeefe509838056df69153f1e3dc86bb89">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a96b201f929f4c7c5bbcd723d32f132a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setLight </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGFXLightInfo.html">GFXLightInfo</a> *&#160;</td>
          <td class="paramname"><em>light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bf4953b9d3aabc2797b923d0395e9f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setLightInternal </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>lightStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGFXLightInfo.html">GFXLightInfo</a>&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lightEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a74e8c8ccc1c1376c6c8d02f48acc298b">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ada7cd0a60d68c1a457d2802c082f6272">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a92dc3a60a7afd6b4eab7580d42c0fe43">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a689041ff7e3f53a4e12c18752f84d3a1">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9287e5cd40c9b2944b9e6d51b1550fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setLightMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8b380dd09d07a7b5c048c4ff9a28b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setLightMaterialInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a>&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#af48b892185ba560cd3169ed6d0938f33">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ae0b5e07138716e2fa7958706ef8cb3dc">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a9d533f8a59a2395479f9c089a0046e4c">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a8c723fc86b1c4b06abd00274e69fc3de">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae69948ce316fd8bd1979d6477100c341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setMatrix </td>
          <td>(</td>
          <td class="paramtype">GFXMatrixType&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function must be implemented differently per API and it should set ONLY the current matrix. </p>
<p>For example, in OpenGL, there should be NO matrix stack activity, all the stack stuff is managed in the GFX layer.</p>
<p>OpenGL does not have separate world and view matrices. It has ModelView which is world * view. You must take this into consideration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtype</td><td>Which matrix to set, world/view/projection </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix to assign </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGFXGLDevice.html#a323672b485f70752bc84c54b43243ae3">GFXGLDevice</a>, <a class="el" href="classGFXD3D11Device.html#ac1fdebbcdb52afa36ccc3741ac1b3627">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#aa4339a732d2dad314b6325eef96bb1c5">GFXNullDevice</a>, and <a class="el" href="classGFXPCD3D9Device.html#a4c733f82358d20cf31371a7321a4415f">GFXPCD3D9Device</a>.</p>

</div>
</div>
<a class="anchor" id="ac919f3f4e11d349b3919f851a40c7f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setOrtho </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doRotate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will construct and apply an orthographic projection matrix with the provided parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doRotate</td><td>If set to true, the resulting matrix will be rotated PI/2 around the X axis </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a20267e71efa9d22e5effe9632a7fd736">getFrustum()</a>.</p>

</div>
</div>
<a class="anchor" id="aa02b6f74b519b52757c71f744df7f092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setPixelShaderVersion </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#ab59d8a316c2d663e4fd2b51cb9b37b67">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#aaeb1569990afa3e3648734ca42409ead">GFXD3D11Device</a>, <a class="el" href="classGFXNullDevice.html#a53f58a68e88f92e0953cbd3d7d374fdd">GFXNullDevice</a>, and <a class="el" href="classGFXGLDevice.html#a62d43eb3bcf790f0ca55fb6ee3f6bb3a">GFXGLDevice</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="a27f5f906b6757e53a837df0fd90b0b51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setPrimitiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e383532f8a7db58b99310ab9a9dd2ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newProj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newProj</td><td>New projection matrix to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGFXDevice.html#a3258f45fb86b003b11c54e91e5ade8a5">mProjectionMatrix</a>, <a class="el" href="classGFXDevice.html#a3fc6a2e2c64ed6ff7df1f9558e1cefb2">mProjectionMatrixDirty</a>, and <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0e3d37b0ca3d5ff1fe20d8778c27412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXShader.html">GFXShader</a> *&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#a238de1b905306ab9578e7bc270fdc278">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#af1a5e8bd0a2361db25bf78e71dcecc27">GFXD3D11Device</a>, and <a class="el" href="classGFXGLDevice.html#a3d015f94b88c8bef8f6e7a88fcad39a6">GFXGLDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a1fbeeb26e49406db965dd8da7c3cf778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setShaderConstBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer! (Actual set happens on the next draw call, just like textures, state blocks, etc) </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a175a2ba572ca80f0023c0ccdbce2ba8e">disableShaders()</a>.</p>

</div>
</div>
<a class="anchor" id="ac092d8361c678b9aeb930213be271f55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setShaderConstBufferInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by base <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to actually set a const buffer. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#aeb8240ae64a995188a0aaf85103d6a8b">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a4902ac4df905631955bbd6f5a359a865">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a0a9efac7b425090b191232f1469fac61">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#aaa3b3e801473f492bea7838fc6dc1548">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a13a2407e0e26a6eb50614d0609132b43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setStateBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXStateBlock.html">GFXStateBlock</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current stateblock (actually activated in ::updateStates) </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a63ba3582c1126a073cee6627539e7020">getCurrentTexture()</a>.</p>

</div>
</div>
<a class="anchor" id="ad607356d34ebcaea70c35614f724b498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setStateBlockByDesc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGFXStateBlockDesc.html">GFXStateBlockDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets a stateblock directly from the description structure. </p>
<p>Its acceptable to use this for debug rendering and other low frequency rendering tasks. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae2a86920cddd637f7bb2e33c16de9cd4">getStateBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2ceb04e1a40cab3bfd42d0f53721e41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setStateBlockInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXStateBlock.html">GFXStateBlock</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a> to actually set a stateblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, set all states </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a7e7aa1348fc48bd6a5e4bed4dd90ce58">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a90127483832a8976852c8287a11b39eb">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#ac5cdab623df3104c6d563a68063c27e0">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a6b49ff7c72c4251c1c06877f1009021a">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a423dbbef99f73865489e232014932812"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStereoEyeOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current eye offset used during stereo rendering. </p>

<p>References <a class="el" href="group__ObjTrickery.html#gad9a688ed7d102e8737ed3bf331c2a4fe">dMemcpy()</a>, and <a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>.</p>

</div>
</div>
<a class="anchor" id="a4715b4049f9d80a5eff9c837835f4209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStereoEyeTransforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>transforms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="group__ObjTrickery.html#gad9a688ed7d102e8737ed3bf331c2a4fe">dMemcpy()</a>, and <a class="el" href="classMatrixF.html#a094a5311bfdd9cc7b9cd0926c279e6d4">MatrixF::inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a19b056605f616c21dd2cad10917031e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStereoFovPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFovPort.html">FovPort</a> *&#160;</td>
          <td class="paramname"><em>ports</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current eye offset used during stereo rendering. Assumes NumStereoPorts are available. </p>

<p>References <a class="el" href="group__ObjTrickery.html#gad9a688ed7d102e8737ed3bf331c2a4fe">dMemcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a78c6586d8a6a1403b3d0a65a55e236d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStereoHeadTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the head matrix for stereo rendering. </p>

</div>
</div>
<a class="anchor" id="a2cf86e581a626ae46b2e436c44d647de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setStereoTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a> **&#160;</td>
          <td class="paramname"><em>targets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets stereo render targets. </p>

</div>
</div>
<a class="anchor" id="a6ccac78b964e3c85cf054082e6e2b885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setSteroViewports </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> *&#160;</td>
          <td class="paramname"><em>ports</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets stereo viewports. </p>

<p>References <a class="el" href="group__ObjTrickery.html#gad9a688ed7d102e8737ed3bf331c2a4fe">dMemcpy()</a>, and <a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>.</p>

</div>
</div>
<a class="anchor" id="a25fd4143c2a3a02865b4d39b5a8b691d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setTexture </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGFXTextureObject.html">GFXTextureObject</a> *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae0a363725d0a5402fc0b4889749371ed">createOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="a58e6777ac71f79797458ce28b1b6fffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setTextureInternal </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>textureUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGFXTextureObject.html">GFXTextureObject</a> *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a5695c9eaf85dd71b892330c871a2766b">GFXD3D9Device</a>, <a class="el" href="classGFXGLDevice.html#a2a34817bf6f47dd9cbc29291f3bffd70">GFXGLDevice</a>, <a class="el" href="classGFXD3D11Device.html#a6b7eeb5ffe37a1830215be979ad7f3ef">GFXD3D11Device</a>, and <a class="el" href="classGFXNullDevice.html#af2ee70ec55b38ab46e712718d273e403">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae41b6b0d8ce7f82a67f82f5045837efc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setTextureMatrix </td>
          <td>(</td>
          <td class="paramtype">const U32&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>texMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set texture matrix for a sampler. </p>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#aa6a85de42022a63022dc4adc1552200d">mTextureMatrix</a>, <a class="el" href="classGFXDevice.html#a8d51de21268634908ec665e228138be0">mTextureMatrixCheckDirty</a>, and <a class="el" href="classGFXDevice.html#a7d07c95c8f756a971eaf77e38cea070a">mTextureMatrixDirty</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ab07a4b0ac3141200a820922b58da5107"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setupGenericShaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154da">GenericShaderType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classGFXDevice.html#ad4ec26ff908a29191c0052937d8154daab60202d148fd08874654a053d8f44b2f">GSColor</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a helper function to set a default shader for rendering GUI elements on systems which do not support fixed-function operations as well as for things which need just generic position/texture/color shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of generic shader, add your own if you need </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classGFXD3D9Device.html#a97b6ee4dcc5702a7efdcea0614af4d2e">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ae5443592834e9ed533ead41724e00fc6">GFXD3D11Device</a>, and <a class="el" href="classGFXGLDevice.html#a6d1ce0dd74cbb8ad53480d502378cc5d">GFXGLDevice</a>.</p>

<p>References <a class="el" href="classGFXDevice.html#ad1a5ad5aff2a286e12b8396e024d8e33">getFillConventionOffset()</a>, <a class="el" href="classGFXDevice.html#aab91faf2269e73d98e8c3b9a79c0af5a">getMaxDynamicIndices()</a>, and <a class="el" href="classGFXDevice.html#a53d2bcf9c0c38f90bfbd3c01af125a96">getMaxDynamicVerts()</a>.</p>

</div>
</div>
<a class="anchor" id="a71ddf97417de82295f859773420f3cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>frequency</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex buffer. </p>
<p>When setting the stream 0 vertex buffer it will automatically set its associated vertex format as the active format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer or NULL to clear the buffer. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream index of the vertex source stream to place the buffer. </td></tr>
    <tr><td class="paramname">frequency</td><td>The stream frequency of the vertex buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGFXDevice.html#ade79ea252d77700f99fdbd624182b79f">mCurrentVertexBuffer</a>, <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#a8da647fc184d78513d169e6b9b401ae7">mVertexBufferDirty</a>, <a class="el" href="classGFXDevice.html#a8cf14d72cee6a4eee5d2e946e2b8ab79">mVertexBufferFrequency</a>, <a class="el" href="classGFXDevice.html#a49e59790ca5758de9492a9983220cfe6">mVertexBufferFrequencyDirty</a>, <a class="el" href="classGFXVertexBuffer.html#a4b5881bb9b2096fe1db7ea41abb0b9f7">GFXVertexBuffer::mVertexFormat</a>, <a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat()</a>, and <a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a513eafd27cec212b0f4a227c0e980f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setVertexDecl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a> *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current vertex declaration on the device. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a566a0c1e2b828511f7444c9f4ff2594e">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#ae452f5f980baab208d7a05a75208c209">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#acc4dc6b527064521c7305906b5ced4f1">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a7a42166c20d4a442bcec2713c1de252c">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aee483ec4b229f6b4983a4f9bb5947fee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setVertexFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGFXVertexFormat.html">GFXVertexFormat</a> *&#160;</td>
          <td class="paramname"><em>vertexFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current vertex format. </p>
<p>This should only be used if the vertex format of the stream 0 vertex buffer is different from the one associated to it. Typically this is used when rendering from multiple vertex streams. </p>

<p>References <a class="el" href="classGFXVertexFormat.html#a15e519575990b0d9f9bccbccc0b3846c">GFXVertexFormat::getDecl()</a>, <a class="el" href="classGFXDevice.html#a5c5e09e4d66089c8359624494326a8a0">mCurrVertexDecl</a>, <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, and <a class="el" href="classGFXDevice.html#a7e1d89f66d7436373e11a2de109541c5">mVertexDeclDirty</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>, and <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ad40df8472f8ce595b8081e26d595da57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setVertexStream </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex buffer on the device. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a7be71dacdb8cf25f545c373a0e398414">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a03ab0dc4d662e6455a20fcde49045a5b">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#a9d59ac2228ed8fd1a6d680b903f0c552">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#a98f169da03923b0fb4ceebf3deb8bc00">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a83d4fe702476a93273750e994b122baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GFXDevice::setVertexStreamFrequency </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the vertex stream frequency on the device. </p>

<p>Implemented in <a class="el" href="classGFXD3D9Device.html#a49f564afd9008dff3a3d6d3e4013320c">GFXD3D9Device</a>, <a class="el" href="classGFXD3D11Device.html#a161d4337de9160a3f3ff281210c964bd">GFXD3D11Device</a>, <a class="el" href="classGFXGLDevice.html#ab9f95054dec8423216016013962f1c65">GFXGLDevice</a>, and <a class="el" href="classGFXNullDevice.html#afe348d1861f753b3ea8e19ae9479c251">GFXNullDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a612f00a3b21b5ec5d071fd9a409891a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newView</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the view matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newView</td><td>New view matrix to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#a8914b619a373d5c753a7bae8b40140e9">mViewMatrix</a>, and <a class="el" href="classGFXDevice.html#add4468a18976dcf128855c0bc5d0caf8">mViewMatrixDirty</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ad8491b8ad4fbe1c529c13886d48ac419">getProjectionMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="aff095cc01fc3319d229996a16791b919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an area of the target to render to. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ac828dc9eb9b8cd4eec6daf8090cc4639">activateStereoTarget()</a>, and <a class="el" href="classGFXDevice.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8964ddd37f4be2361cb346b1e132fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::setWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>newWorld</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the top of the world matrix stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWorld</td><td>New world matrix to set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGFXDevice.html#a3af56a682e13bfc1054bc7b676034e08">mStateDirty</a>, <a class="el" href="classGFXDevice.html#aff5d637cc039b275af5f1c121f329dc3">mWorldMatrix</a>, <a class="el" href="classGFXDevice.html#ab92eb4b02fb61b330b3ee5ddbfcd29ba">mWorldMatrixDirty</a>, and <a class="el" href="classGFXDevice.html#a948d1a7c773d0de6d78d46e7235a5107">mWorldStackSize</a>.</p>

<p>Referenced by <a class="el" href="classGFXDevice.html#acdfc90cf657e9a85cb3189c3452f5479">getDisableOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="af2c5f9b69134353c0a6f3663ca2feece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GFXDevice::updateStates </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceSetAll</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae2a86920cddd637f7bb2e33c16de9cd4">getStateBlock()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab3b997ba465a5c7481616b57cc496ea9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mAllowRender</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if we're in a mode where we want rendering to occur. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#afc5d2c4cb480f486ecb002f514568353">allowRender()</a>.</p>

</div>
</div>
<a class="anchor" id="a0640c509f516369ded3ab66d8d033af4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mCanCurrentlyRender</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set once the device is active. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#af6891dec318410ef94116b4ec950342c">canCurrentlyRender()</a>.</p>

</div>
</div>
<a class="anchor" id="a42308d582bcfd5bcfc4be84ad5b74b36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXCardProfiler.html">GFXCardProfiler</a>* GFXDevice::mCardProfiler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The CardProfiler for this device. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a3c5f1cf6b3214e266d5fa63cc2b97539">getCardProfiler()</a>.</p>

</div>
</div>
<a class="anchor" id="a873f2e2daf84075fa8f09b177cd04d29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXCubemapHandle.html">GFXCubemapHandle</a> GFXDevice::mCurrentCubemap[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbe369bc897df355de806d52a3aeafe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 GFXDevice::mCurrentFrontBufferIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aac0f42c65529f7db671b731bd38d2492">getFrontBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6a137fa62660913b15f387f84a6d4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXLightInfo.html">GFXLightInfo</a> GFXDevice::mCurrentLight[LIGHT_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a604ab7c118abd8b5d9e2ccc8fb7dd72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mCurrentLightEnable[LIGHT_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2122cca014575c1a80262b10b53091a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGFXLightMaterial.html">GFXLightMaterial</a> GFXDevice::mCurrentLightMaterial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6843bc771a1a79fe956ed982ad82986e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">StrongRefPtr</a>&lt;<a class="el" href="classGFXPrimitiveBuffer.html">GFXPrimitiveBuffer</a>&gt; GFXDevice::mCurrentPrimitiveBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a512cbf498248d8312d4403e5992f58bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 GFXDevice::mCurrentRenderStyle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The style of rendering that is to be performed, based on GFXDeviceRenderStyles. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#af0e3f85ba5431ed2ad27fc5c4312dd0f">getCurrentRenderStyle()</a>.</p>

</div>
</div>
<a class="anchor" id="af34099197db5b16c78de828ad781ef30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">GFXTargetRef</a> GFXDevice::mCurrentRT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current render target which may or may not not be yet activated. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXDevice.html#a7559e13ed0b83f00855d96b58951dba4" title="This is set when the current and/or deactivate render targets have changed and the device need to upd...">mRTDirty</a> </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#ae56964c4831dd3a1f6c1819be6bf7ad9">getActiveRenderTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6f0f57053db7faddd214efe2c05b04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXShaderConstBuffer.html">GFXShaderConstBuffer</a>* GFXDevice::mCurrentShaderConstBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5978aeb64309fdd50ed5bbb638363be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a> GFXDevice::mCurrentStateBlock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3275b8253694e118dce2bde8536c15cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDevice.html#a8b9abcb3e6bdf6b3b0fc87782b86b3c7">StateBlockMap</a> GFXDevice::mCurrentStateBlocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aee3c4c42b4d22530a1a69fc7de1334ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S32 GFXDevice::mCurrentStereoTarget</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current stereo target being rendered to. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#ac311ad224954a89f24ba649a2825ceec">getCurrentStereoTarget()</a>.</p>

</div>
</div>
<a class="anchor" id="a2621a5027fb59956868f32f4e0386553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a> GFXDevice::mCurrentTexture[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ade79ea252d77700f99fdbd624182b79f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">StrongRefPtr</a>&lt;<a class="el" href="classGFXVertexBuffer.html">GFXVertexBuffer</a>&gt; GFXDevice::mCurrentVertexBuffer[<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c5e09e4d66089c8359624494326a8a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGFXVertexDecl.html">GFXVertexDecl</a>* GFXDevice::mCurrVertexDecl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="aef70d216314854ef1cdd7f601c17f38e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDeviceStatistics.html">GFXDeviceStatistics</a> GFXDevice::mDeviceStatistics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a707344e1c602854a433551c379c432d1">getDeviceStatistics()</a>.</p>

</div>
</div>
<a class="anchor" id="a43c873557881c5019fbe8671a18a05bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSwizzle.html">Swizzle</a>&lt;U8, 3&gt;* GFXDevice::mDeviceSwizzle24</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12" title="Swizzle to convert 24bpp bitmaps from RGB to the native device format. ">getDeviceSwizzle24</a> </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a936a62a3dd886a1ec053b8cc42bf0d12">getDeviceSwizzle24()</a>.</p>

</div>
</div>
<a class="anchor" id="afa819b68c170b3ed9540dabc2d631090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSwizzle.html">Swizzle</a>&lt;U8, 4&gt;* GFXDevice::mDeviceSwizzle32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXDevice.html#a6fdbb77883a6fcca9ae65fabae68c2ea" title="Swizzle to convert 32bpp bitmaps from RGBA to the native device format. ">getDeviceSwizzle32</a> </dd></dl>

<p>Referenced by <a class="el" href="classGFXDevice.html#a6fdbb77883a6fcca9ae65fabae68c2ea">getDeviceSwizzle32()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e6c20eed5ba81d25036e9b650110e4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDrawUtil.html">GFXDrawUtil</a>* GFXDevice::mDrawer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51b9da8251f994a5b89a8999b865148c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFovPort.html">FovPort</a> GFXDevice::mFovPorts[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fov port settings. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a9cf529e9c3301c71809b7cb41b052dd2">getStereoFovPort()</a>.</p>

</div>
</div>
<a class="anchor" id="a998ce4a95beabc46cc1dabd7514742bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPlatformTimer.html">PlatformTimer</a>* GFXDevice::mFrameTime</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaac4dc34bd6e229397547b5126ab074a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a> GFXDevice::mFrontBuffer[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35f71a1fbf81f4866c8916078e5e3f0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFrustum.html">Frustum</a> GFXDevice::mFrustum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a20267e71efa9d22e5effe9632a7fd736">getFrustum()</a>.</p>

</div>
</div>
<a class="anchor" id="a4173195fde309ef9374d21bf07dbac25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classColorF.html">ColorF</a> GFXDevice::mGlobalAmbientColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab44c56b555a16db1bb8c5a0e4b5c60c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mGlobalAmbientColorDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a383de7991bfb38654381ac35bee51974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mInitialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will allow querying to see if a device is initialized and ready to have operations performed on it. </p>

</div>
</div>
<a class="anchor" id="ab28b3396082a57edce8055de839fc3f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mInverseStereoEyeTransforms[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of mStereoEyeTransforms. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#afe3946bcacb1fe7cce0a5ad2a808d683">getInverseStereoEyeTransforms()</a>.</p>

</div>
</div>
<a class="anchor" id="a85a527d0548f69341ce5090babb6cc03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mLightDirty[LIGHT_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8c105b7501fa0ac0303870e650174f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mLightMaterialDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a78ee4a2c9a16284f82db47a19f91bc34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mLightsDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a684ac98966a4c9149cd735d3a3b5eaa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXCubemapHandle.html">GFXCubemapHandle</a> GFXDevice::mNewCubemap[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35efe65723aa02af5fd8a16444a4d1fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">GFXStateBlockRef</a> GFXDevice::mNewStateBlock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae2a86920cddd637f7bb2e33c16de9cd4">getStateBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeb88935753509005512018446598043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTexHandle.html">GFXTexHandle</a> GFXDevice::mNewTexture[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90a46bbe9ca9f07165ac1b5e15a7191d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mPrimitiveBufferDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3258f45fb86b003b11c54e91e5ade8a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mProjectionMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ad8491b8ad4fbe1c529c13886d48ac419">getProjectionMatrix()</a>, and <a class="el" href="classGFXDevice.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fc6a2e2c64ed6ff7df1f9558e1cefb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mProjectionMatrixDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a355c4a54be462dcd9aa41ed9c9bfe88c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mReset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a1eab068a5df508c89b42926e272ab4fa">recentlyReset()</a>.</p>

</div>
</div>
<a class="anchor" id="a434bccb6833d494e75ebd17a3481187b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXResource.html">GFXResource</a>* GFXDevice::mResourceListHead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Head of the resource list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classGFXResource.html" title="Mixin for the purpose of tracking GFX resources owned by a GFXDevice. ">GFXResource</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acff41a4cae195f1eaf108370e450b9b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStrongRefPtr.html">GFXTargetRef</a> GFXDevice::mRTDeactivate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This tracks a previously activated render target which need to be deactivated. </p>

</div>
</div>
<a class="anchor" id="a7559e13ed0b83f00855d96b58951dba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mRTDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is set when the current and/or deactivate render targets have changed and the device need to update its state on the next draw/clear. </p>

</div>
</div>
<a class="anchor" id="a9661b2d8db8a749d77ceaa193b125fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classStrongRefPtr.html">GFXTargetRef</a>&gt; GFXDevice::mRTStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A stack of previously active render targets. </p>

</div>
</div>
<a class="anchor" id="afec0cd5b93e1f3eba2903c0bd4a551b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mStateBlockDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3af56a682e13bfc1054bc7b676034e08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mStateDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if ANY state is dirty, including matrices or primitive buffers. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld()</a>, <a class="el" href="classGFXDevice.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#a1e383532f8a7db58b99310ab9a9dd2ba">setProjectionMatrix()</a>, <a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix()</a>, <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>, <a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat()</a>, <a class="el" href="classGFXDevice.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix()</a>, and <a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c85d356eebe4d5c9e13938073f0b2e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> GFXDevice::mStereoEyeOffset[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eye offset used when using a stereo rendering style. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a774881e8870ee0dcb8d2116d6aef5a6f">getStereoEyeOffsets()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a9719978834b18a8591dbb2b9b8bd35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mStereoEyeTransforms[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left and right matrix for eyes. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#abc7fb9d807efd6e23c3d5316b25ecaba">getStereoEyeTransforms()</a>.</p>

</div>
</div>
<a class="anchor" id="a8acce4a751019055aaf5e767203427dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mStereoHeadTransform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Center matrix for head. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a4b4a01652d52c2d9884586959513d733">getStereoHeadTransform()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b294ea6b6557a29bece47901d049bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTextureTarget.html">GFXTextureTarget</a>* GFXDevice::mStereoTargets[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destination targets for stereo rendering. </p>

</div>
</div>
<a class="anchor" id="a5b078eeae79f9883a8ca2c5474819e65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRectI.html">RectI</a> GFXDevice::mStereoViewports[<a class="el" href="classGFXDevice.html#a7a682b30e5aee6a9a7c1386ac7ad1f34abdae8a31056c147ed5cc03b734513123">NumStereoPorts</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destination viewports for stereo rendering. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a02192f0d2b16306a5660e4f7c7d7d7d6">getStereoViewports()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c10f10df402ae33f15136e09419521a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mTextureDirty[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42dbd3cae371b904e59d669b6e44382e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXTextureManager.html">GFXTextureManager</a>* GFXDevice::mTextureManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae530441812a0b904302c77c30d6bc6ca">getTextureManager()</a>, and <a class="el" href="classGFXD3D11Device.html#a498cf2682dc3c0206f59d6137782735f">GFXD3D11Device::preDestroy()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a85de42022a63022dc4adc1552200d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mTextureMatrix[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d51de21268634908ec665e228138be0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mTextureMatrixCheckDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d07c95c8f756a971eaf77e38cea070a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mTextureMatrixDirty[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#ae41b6b0d8ce7f82a67f82f5045837efc">setTextureMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a8981107f9ba92cb7f876957e55b19de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mTexturesDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ddd6afe745204f748a5ab2a13a778a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGFXDevice.html#a2f57e2c8b460f93b5b38d9b28e788858">TexDirtyType</a> GFXDevice::mTexType[TEXTURE_STAGE_COUNT]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da647fc184d78513d169e6b9b401ae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mVertexBufferDirty[<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cf14d72cee6a4eee5d2e946e2b8ab79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 GFXDevice::mVertexBufferFrequency[<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a49e59790ca5758de9492a9983220cfe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mVertexBufferFrequencyDirty[<a class="el" href="classGFXDevice.html#ac5598dda8b6efbce870cb3580d3bed88">VERTEX_STREAM_COUNT</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e1d89f66d7436373e11a2de109541c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mVertexDeclDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aee483ec4b229f6b4983a4f9bb5947fee">setVertexFormat()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a99c283f886c8f2b009c5d981e27ad1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="structGFXVideoMode.html">GFXVideoMode</a>&gt; GFXDevice::mVideoModes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of valid video modes for this device. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a1bcfdaaf73855c6ba53e472eb1d700b3">getVideoModeList()</a>.</p>

</div>
</div>
<a class="anchor" id="a8914b619a373d5c753a7bae8b40140e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mViewMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a8bb96149889ba6465948deec8f1646bd">getViewMatrix()</a>, and <a class="el" href="classGFXDevice.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="add4468a18976dcf128855c0bc5d0caf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mViewMatrixDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a612f00a3b21b5ec5d071fd9a409891a1">setViewMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ad43e47fe86d99aed8172572a044bc4aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRectI.html">RectI</a> GFXDevice::mViewport</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current viewport rect. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a438a05795dc86bad94a7a1e9dffdd1e4">getViewport()</a>.</p>

</div>
</div>
<a class="anchor" id="a51b127b09986479d663abb4b75745e96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mViewportDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true the viewport has been changed and it must be updated on the next draw/clear. </p>

</div>
</div>
<a class="anchor" id="aff5d637cc039b275af5f1c121f329dc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> GFXDevice::mWorldMatrix[WORLD_STACK_MAX]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld()</a>, <a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix()</a>, and <a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ab92eb4b02fb61b330b3ee5ddbfcd29ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::mWorldMatrixDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld()</a>, <a class="el" href="classGFXDevice.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix()</a>, and <a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a948d1a7c773d0de6d78d46e7235a5107"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S32 GFXDevice::mWorldStackSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classGFXDevice.html#a2f27a6b462aa7d9b393ae9b528b00e00">getWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#aa2dd2cb45f6c371e03b065b02b4a648b">multWorld()</a>, <a class="el" href="classGFXDevice.html#a2b3a2651759c03f2c039fb775961a09c">popWorldMatrix()</a>, <a class="el" href="classGFXDevice.html#ab1b012283186cb887f4bda73b35fad1a">pushWorldMatrix()</a>, and <a class="el" href="classGFXDevice.html#ae8964ddd37f4be2361cb346b1e132fe9">setWorldMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a01aa3220067accab7a93c8b3149b50c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::smDisableOcclusionQuery</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable all hardware occlusion queries causing them to return only the visibile state. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#acdfc90cf657e9a85cb3189c3452f5479">getDisableOcclusionQuery()</a>.</p>

</div>
</div>
<a class="anchor" id="a58e38378deb803d3c18b5e0c572d75b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::smDisableVSync</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global vsync state. </p>

</div>
</div>
<a class="anchor" id="a6df2c70b6334aeeb9cbcd7dab1630ade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">F32 GFXDevice::smForcedPixVersion</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The forced shader model version if non-zero. </p>

</div>
</div>
<a class="anchor" id="a29ad06dc744102faf1f4098114920931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GFXDevice::smWireframe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A global forced wireframe mode. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#adc04807e3c0888dc6ccce3fc4f5a4343">getWireframe()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5598dda8b6efbce870cb3580d3bed88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const U32 GFXDevice::VERTEX_STREAM_COUNT = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of supported vertex streams which may be more than the device supports. </p>

<p>Referenced by <a class="el" href="classGFXDevice.html#a71ddf97417de82295f859773420f3cdc">setVertexBuffer()</a>.</p>

</div>
</div>
</div><!-- contents -->

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
