<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Torque3D - Engine Reference: PolyhedronImpl&lt; Base &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Torque3D - Engine Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="struct_polyhedron_impl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PolyhedronImpl&lt; Base &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="m_polyhedron_8h_source.html">mPolyhedron.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PolyhedronImpl&lt; Base &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="struct_polyhedron_impl__inherit__graph.png" border="0" usemap="#_polyhedron_impl_3_01_base_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_polyhedron_impl_3_01_base_01_4_inherit__map" id="_polyhedron_impl_3_01_base_01_4_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PolyhedronImpl&lt; Base &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="struct_polyhedron_impl__coll__graph.png" border="0" usemap="#_polyhedron_impl_3_01_base_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_polyhedron_impl_3_01_base_01_4_coll__map" id="_polyhedron_impl_3_01_base_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6666da9a146dd8db588b4b965e377b80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6666da9a146dd8db588b4b965e377b80"></a>
typedef Base::Edge&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a6666da9a146dd8db588b4b965e377b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"></a>
typedef Base::PlaneListType&#160;</td><td class="memItemRight" valign="bottom"><b>PlaneListType</b></td></tr>
<tr class="separator:a6bcbb6c849d2a24c7a5c0e7bdfe8cd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c4f2b0c52b113910c188273db49675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88c4f2b0c52b113910c188273db49675"></a>
typedef Base::PointListType&#160;</td><td class="memItemRight" valign="bottom"><b>PointListType</b></td></tr>
<tr class="separator:a88c4f2b0c52b113910c188273db49675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55897e8802e23d3fe48033bd39c03164"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55897e8802e23d3fe48033bd39c03164"></a>
typedef Base::EdgeListType&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeListType</b></td></tr>
<tr class="separator:a55897e8802e23d3fe48033bd39c03164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a995ec41ee31a6ff601d8514130c07bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995ec41ee31a6ff601d8514130c07bbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a995ec41ee31a6ff601d8514130c07bbb">PolyhedronImpl</a> ()</td></tr>
<tr class="memdesc:a995ec41ee31a6ff601d8514130c07bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty polyhedron. <br /></td></tr>
<tr class="separator:a995ec41ee31a6ff601d8514130c07bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5118b39df900b0c75c77b144424b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15c5118b39df900b0c75c77b144424b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a15c5118b39df900b0c75c77b144424b7">PolyhedronImpl</a> (PlaneListType planes, PointListType points, EdgeListType edges)</td></tr>
<tr class="memdesc:a15c5118b39df900b0c75c77b144424b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a polyhedron described by the given planes and edges. <br /></td></tr>
<tr class="separator:a15c5118b39df900b0c75c77b144424b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b4cd32c0bb7b185d7e9150b156767"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27b4cd32c0bb7b185d7e9150b156767"></a>
<a class="el" href="class_box3_f.html">Box3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#ae27b4cd32c0bb7b185d7e9150b156767">getBounds</a> () const </td></tr>
<tr class="memdesc:ae27b4cd32c0bb7b185d7e9150b156767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the AABB around the polyhedron. <br /></td></tr>
<tr class="separator:ae27b4cd32c0bb7b185d7e9150b156767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891d67d99ccf153f78b28e558a3933a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad891d67d99ccf153f78b28e558a3933a"></a>
<a class="el" href="class_point3_f.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#ad891d67d99ccf153f78b28e558a3933a">getCenterPoint</a> () const </td></tr>
<tr class="memdesc:ad891d67d99ccf153f78b28e558a3933a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the median point of all points defined on the polyhedron. <br /></td></tr>
<tr class="separator:ad891d67d99ccf153f78b28e558a3933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transform</div></td></tr>
<tr class="memitem:ad9f47528b69f00afffc3686a46289040"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f47528b69f00afffc3686a46289040"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#ad9f47528b69f00afffc3686a46289040">transform</a> (const <a class="el" href="class_matrix_f.html">MatrixF</a> &amp;matrix, const <a class="el" href="class_point3_f.html">Point3F</a> &amp;scale=Point3F::One)</td></tr>
<tr class="memdesc:ad9f47528b69f00afffc3686a46289040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the polyhedron using the given transform matrix and scale. <br /></td></tr>
<tr class="separator:ad9f47528b69f00afffc3686a46289040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Containment</div></td></tr>
<tr class="memitem:aaf4c10f923722657e589cbcbf75f3858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#aaf4c10f923722657e589cbcbf75f3858">isContained</a> (const <a class="el" href="class_point3_f.html">Point3F</a> &amp;point, F32 epsilon=0.f) const </td></tr>
<tr class="separator:aaf4c10f923722657e589cbcbf75f3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad243fedd25ddfa92f124793a3671ff66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#ad243fedd25ddfa92f124793a3671ff66">isContained</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *points, U32 numPoints) const </td></tr>
<tr class="separator:ad243fedd25ddfa92f124793a3671ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc71944718b3521ec143a8833a4e733"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#adfc71944718b3521ec143a8833a4e733">isContained</a> (const <a class="el" href="class_box3_f.html">Box3F</a> &amp;aabb) const </td></tr>
<tr class="separator:adfc71944718b3521ec143a8833a4e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c1350c070ccf3b5c5ca4af975274d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#ad2c1350c070ccf3b5c5ca4af975274d3">isContained</a> (const <a class="el" href="class_sphere_f.html">SphereF</a> &amp;sphere) const </td></tr>
<tr class="separator:ad2c1350c070ccf3b5c5ca4af975274d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3506dc44cdb3708f6dbbf0b4f8aa5156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a3506dc44cdb3708f6dbbf0b4f8aa5156">isContained</a> (const <a class="el" href="class_oriented_box3_f.html">OrientedBox3F</a> &amp;obb) const </td></tr>
<tr class="separator:a3506dc44cdb3708f6dbbf0b4f8aa5156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Intersection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All of these intersection methods are approximate in that they can produce false positives on GeometryIntersecting. For precise testing, use <a class="el" href="struct_intersector.html">Intersector</a>. </p>
</div></td></tr>
<tr class="memitem:a5e84c994610cf371269af2f0920b5903"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a5e84c994610cf371269af2f0920b5903">testPotentialIntersection</a> (const <a class="el" href="class_box3_f.html">Box3F</a> &amp;aabb) const </td></tr>
<tr class="separator:a5e84c994610cf371269af2f0920b5903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290980d0d9bcd82f226719404473715b"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a290980d0d9bcd82f226719404473715b">testPotentialIntersection</a> (const <a class="el" href="class_sphere_f.html">SphereF</a> &amp;sphere) const </td></tr>
<tr class="separator:a290980d0d9bcd82f226719404473715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7c4298e73a81e415c95f0000fe6383"><td class="memItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a9d7c4298e73a81e415c95f0000fe6383">testPotentialIntersection</a> (const <a class="el" href="class_oriented_box3_f.html">OrientedBox3F</a> &amp;obb) const </td></tr>
<tr class="separator:a9d7c4298e73a81e415c95f0000fe6383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec79027fc757f0797cfca195b1502c"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a16ec79027fc757f0797cfca195b1502c">testPlanes</a> (const <a class="el" href="class_box3_f.html">Box3F</a> &amp;bounds, U32 planeMask=0xFFFFFFFF, F32 expand=0.0f) const </td></tr>
<tr class="separator:a16ec79027fc757f0797cfca195b1502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Clipping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functionality to clip other geometries against the polyhedron. </p>
</div></td></tr>
<tr class="memitem:abb49eca2927a80a721268e70ce5f2825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#abb49eca2927a80a721268e70ce5f2825">clipSegment</a> (<a class="el" href="class_point3_f.html">Point3F</a> &amp;pnt0, <a class="el" href="class_point3_f.html">Point3F</a> &amp;pnt1) const </td></tr>
<tr class="separator:abb49eca2927a80a721268e70ce5f2825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a6cf15594f6792f53d15f23ffd3e85"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a83a6cf15594f6792f53d15f23ffd3e85">clipPolygon</a> (const <a class="el" href="class_point3_f.html">Point3F</a> *inVertices, U32 inNumVertices, <a class="el" href="class_point3_f.html">Point3F</a> *outVertices, U32 maxOutVertices) const </td></tr>
<tr class="separator:a83a6cf15594f6792f53d15f23ffd3e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operations for constructing solids and polygons through boolean operations involving the polyhedron. </p>
</div></td></tr>
<tr class="memitem:a6562f9bb01803b6a2e820c46d6c01d62"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#a6562f9bb01803b6a2e820c46d6c01d62">constructIntersection</a> (const <a class="el" href="class_plane_f.html">PlaneF</a> &amp;plane, <a class="el" href="class_point3_f.html">Point3F</a> *outPoints, U32 maxOutPoints) const </td></tr>
<tr class="separator:a6562f9bb01803b6a2e820c46d6c01d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extraction</div></td></tr>
<tr class="memitem:acb1a34e1139bde084bccde470230486d"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:acb1a34e1139bde084bccde470230486d"><td class="memTemplItemLeft" align="right" valign="top">U32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_polyhedron_impl.html#acb1a34e1139bde084bccde470230486d">extractFace</a> (U32 plane, IndexType *outIndices, U32 maxOutIndices) const </td></tr>
<tr class="separator:acb1a34e1139bde084bccde470230486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a735d3a23e4c74d19602cc038b1506405"><td class="memTemplParams" colspan="2"><a class="anchor" id="a735d3a23e4c74d19602cc038b1506405"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a735d3a23e4c74d19602cc038b1506405"><td class="memTemplItemLeft" align="right" valign="top">OverlapTestResult&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_testOverlap</b> (const P &amp;bounds) const </td></tr>
<tr class="separator:a735d3a23e4c74d19602cc038b1506405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Base = PolyhedronVectorData&gt;<br />
struct PolyhedronImpl&lt; Base &gt;</h3>

<p>A polyhedron.</p>
<p>Polyhedrons are stored as both sets of planes as well sets of edges and vertices (basically a winged-edge format).</p>
<p>Polyhedrons must be convex.</p>
<dl class="section note"><dt>Note</dt><dd>The default orientation for the plane normals of a polyhedron is <em>inwards</em>. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a83a6cf15594f6792f53d15f23ffd3e85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::clipPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>inVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>inNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_plane_set.html#a96db7203e14a1fdeabdce73a7c1bf911">PlaneSet::clipPolygon</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb49eca2927a80a721268e70ce5f2825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::clipSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>pnt1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_plane_set.html#a74a5593ea51c612767c4c3191776081d">PlaneSet::clipSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6562f9bb01803b6a2e820c46d6c01d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::constructIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_plane_f.html">PlaneF</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the intersection of this polyhedron with the given plane. The result is a polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>Plane to intersect the polyhedron with. </td></tr>
    <tr><td class="paramname">outPoints</td><td>(out) Array where the resulting polygon points are stored. A safe size is to just allocate as many points as there are edges in the polyhedron. If you know the maximum number of vertices that can result from the intersection (for example, 4 for a box), then it is ok to only allocate that much. </td></tr>
    <tr><td class="paramname">maxOutPoints</td><td>Number of points that can be stored in <em>outPoints</em>. If insufficient, the return value will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of points written to <em>outPoints</em>. If there is no intersection between the given plane and the polyhedron, this will be zero.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The resulting points will be ordered to form a proper polygon but there is no guarantee on which direction the ordering is in compared to the plane. </dd></dl>

</div>
</div>
<a class="anchor" id="acb1a34e1139bde084bccde470230486d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::extractFace </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>outIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>maxOutIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the polygon for the given plane.</p>
<p>The resulting indices will be CW ordered if the plane normals on the polyhedron are facing inwards and CCW ordered otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>Index of the plane on the polyhedron. </td></tr>
    <tr><td class="paramname">outIndices</td><td>Array where the resulting vertex indices will be stored. Must have enough room. If you don't know the exact size that you need, just allocate one index for any point in the mesh. </td></tr>
    <tr><td class="paramname">maxOutIndices</td><td>The number of indices that can be stored in <em>outIndices</em>. If insufficient, the return value will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of indices written to <em>outIndices</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method relies on correct CW ordering of edges with respect to face[0]. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf4c10f923722657e589cbcbf75f3858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Point3F&amp;,F32) </dd></dl>

</div>
</div>
<a class="anchor" id="ad243fedd25ddfa92f124793a3671ff66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point3_f.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Point3F*,U32) </dd></dl>

</div>
</div>
<a class="anchor" id="adfc71944718b3521ec143a8833a4e733"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box3_f.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const Box3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c1350c070ccf3b5c5ca4af975274d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sphere_f.html">SphereF</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const SphereF&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a3506dc44cdb3708f6dbbf0b4f8aa5156"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::isContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_oriented_box3_f.html">OrientedBox3F</a> &amp;&#160;</td>
          <td class="paramname"><em>obb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::isContained(const OrientedBox3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a16ec79027fc757f0797cfca195b1502c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U32 <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::testPlanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box3_f.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>planeMask</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>expand</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_plane_set.html#afdfc5ad6b059245c4b7c4b13a3556116" title="Returns a bitmask of which planes are hit by the given box. ">PlaneSet::testPlanes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e84c994610cf371269af2f0920b5903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_box3_f.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const Box3F&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a290980d0d9bcd82f226719404473715b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sphere_f.html">SphereF</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const SphereF&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a9d7c4298e73a81e415c95f0000fe6383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base = PolyhedronVectorData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OverlapTestResult <a class="el" href="struct_polyhedron_impl.html">PolyhedronImpl</a>&lt; Base &gt;::testPotentialIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_oriented_box3_f.html">OrientedBox3F</a> &amp;&#160;</td>
          <td class="paramname"><em>obb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>PlaneSet::testPotentialIntersection(const OrientedBox3F&amp;) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>C:/projects/torque3d-qw64q/Engine/source/math/<a class="el" href="m_polyhedron_8h_source.html">mPolyhedron.h</a></li>
<li>C:/projects/torque3d-qw64q/Engine/source/math/<a class="el" href="m_polyhedron_8impl_8h_source.html">mPolyhedron.impl.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
