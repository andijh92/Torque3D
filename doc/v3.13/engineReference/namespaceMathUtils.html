<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MathUtils Namespace Reference</title>
<link href="torquedoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%" class="header">
<tr>
<td style="background-image: url( 'images/t3d-documentation-header.png' ); height: 100px;">
   <!-- hack... makes the HTML Help compiler include the image into the project -->
   <img src="images/t3d-documentation-header.png" style="width: 0; height: 0; borders: 0;">
</td>
</tr>
<tr><td class="headermenu">
	<center>
	<a class="qindex" href="index.html">Main</a> &nbsp; 
	<a class="qindex" href="modules.html">Modules</a> &nbsp; 
	<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
	<a class="qindex" href="namespaces.html">Namespace List</a>	&nbsp; 
	<a class="qindex" target="_blank" href="http://www.garagegames.com/documentation/torque-3d">Online</a>
	</center>
</td></tr>
</table>
<br>
<!-- END HEADER --><!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MathUtils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous math utility functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMathUtils_1_1IntersectInfo.html">IntersectInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="namespaceMathUtils.html#a11137f2229ddb8570ef11c0c68d1ab2c" title="Returns the distance between a point and triangle &#39;abc&#39;. ">mTriangleDistance()</a> to pass along collision info.  <a href="structMathUtils_1_1IntersectInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMathUtils_1_1Line.html">Line</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to define a line.  <a href="structMathUtils_1_1Line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMathUtils_1_1LineSegment.html">LineSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to define a line segment.  <a href="structMathUtils_1_1LineSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMathUtils_1_1Quad.html">Quad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper struct to define a clockwise winding quad.  <a href="structMathUtils_1_1Quad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5dd642fe2fdecc388667610dcd26a532"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structMathUtils_1_1Line.html">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a></td></tr>
<tr class="memdesc:a5dd642fe2fdecc388667610dcd26a532"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ray is also a line.  <a href="#a5dd642fe2fdecc388667610dcd26a532">More...</a><br /></td></tr>
<tr class="separator:a5dd642fe2fdecc388667610dcd26a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af87ed2416d92fc1f83ea006742c5a58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#af87ed2416d92fc1f83ea006742c5a58f">buildMatrix</a> (const <a class="el" href="classPoint3F.html">VectorF</a> *rvec, const <a class="el" href="classPoint3F.html">VectorF</a> *fvec, const <a class="el" href="classPoint3F.html">VectorF</a> *uvec, const <a class="el" href="classPoint3F.html">VectorF</a> *pos, <a class="el" href="classMatrixF.html">MatrixF</a> *outMat)</td></tr>
<tr class="memdesc:af87ed2416d92fc1f83ea006742c5a58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">WORK IN PROGRESS.  <a href="#af87ed2416d92fc1f83ea006742c5a58f">More...</a><br /></td></tr>
<tr class="separator:af87ed2416d92fc1f83ea006742c5a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7fb34fd1f365dd4d46fddab8f7a1cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ace7fb34fd1f365dd4d46fddab8f7a1cf">capsuleCapsuleOverlap</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;a1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;b1, F32 radius1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;a2, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;b2, F32 radius2)</td></tr>
<tr class="memdesc:ace7fb34fd1f365dd4d46fddab8f7a1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collide two capsules (sphere swept lines) against each other, reporting only if they intersect or not.  <a href="#ace7fb34fd1f365dd4d46fddab8f7a1cf">More...</a><br /></td></tr>
<tr class="separator:ace7fb34fd1f365dd4d46fddab8f7a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b569dd52dbaa608c9e7954ae5b426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a7a7b569dd52dbaa608c9e7954ae5b426">capsuleSphereNearestOverlap</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;A0, const <a class="el" href="classPoint3F.html">Point3F</a> A1, F32 radA, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;B, F32 radB, F32 &amp;t)</td></tr>
<tr class="memdesc:a7a7b569dd52dbaa608c9e7954ae5b426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return capsule-sphere overlap.  <a href="#a7a7b569dd52dbaa608c9e7954ae5b426">More...</a><br /></td></tr>
<tr class="separator:a7a7b569dd52dbaa608c9e7954ae5b426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113cb6faa0d914457b67c058af3f428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ab113cb6faa0d914457b67c058af3f428">clipFrustumByPolygon</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *points, U32 numPoints, const <a class="el" href="classRectI.html">RectI</a> &amp;viewport, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;world, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;projection, const <a class="el" href="classFrustum.html">Frustum</a> &amp;inFrustum, const <a class="el" href="classFrustum.html">Frustum</a> &amp;rootFrustum, <a class="el" href="classFrustum.html">Frustum</a> &amp;outFrustum)</td></tr>
<tr class="memdesc:ab113cb6faa0d914457b67c058af3f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip <em>inFrustum</em> by the given polygon.  <a href="#ab113cb6faa0d914457b67c058af3f428">More...</a><br /></td></tr>
<tr class="separator:ab113cb6faa0d914457b67c058af3f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac389f4ebfe61ab816696f310d6551b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixF.html">MatrixF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ac389f4ebfe61ab816696f310d6551b32">createOrientFromDir</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;direction)</td></tr>
<tr class="memdesc:ac389f4ebfe61ab816696f310d6551b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates orientation matrix from a direction vector. Assumes ( 0 0 1 ) is up.  <a href="#ac389f4ebfe61ab816696f310d6551b32">More...</a><br /></td></tr>
<tr class="separator:ac389f4ebfe61ab816696f310d6551b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5bb9616837c363e7c71d4456c1bf48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a4c5bb9616837c363e7c71d4456c1bf48">edgeFaceIntersect</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;edgeA, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;edgeB, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;faceA, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;faceB, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;faceC, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;faceD, <a class="el" href="classPoint3F.html">Point3F</a> *intersection)</td></tr>
<tr class="memdesc:a4c5bb9616837c363e7c71d4456c1bf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of the line going from <em>edgeA</em> to <em>edgeB</em> with the triangle given by <em>faceA</em>, <em>faceB</em>, and <em>faceC</em>.  <a href="#a4c5bb9616837c363e7c71d4456c1bf48">More...</a><br /></td></tr>
<tr class="separator:a4c5bb9616837c363e7c71d4456c1bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ae1fcc28cca391419f78fac6f7f0c5ccb">extrudePolygonEdges</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *vertices, U32 numVertices, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;direction, <a class="el" href="classPlaneF.html">PlaneF</a> *outPlanes)</td></tr>
<tr class="memdesc:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrude the given polygon along the given direction.  <a href="#ae1fcc28cca391419f78fac6f7f0c5ccb">More...</a><br /></td></tr>
<tr class="separator:ae1fcc28cca391419f78fac6f7f0c5ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b96771d044bb177cfa138f83a9c42"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a7a4b96771d044bb177cfa138f83a9c42">extrudePolygonEdgesFromPoint</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *vertices, U32 numVertices, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;fromPoint, <a class="el" href="classPlaneF.html">PlaneF</a> *outPlanes)</td></tr>
<tr class="memdesc:a7a4b96771d044bb177cfa138f83a9c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrude the edges of the given polygon away from <em>fromPoint</em> by constructing a set of planes that each go through <em>fromPoint</em> and a pair of vertices.  <a href="#a7a4b96771d044bb177cfa138f83a9c42">More...</a><br /></td></tr>
<tr class="separator:a7a4b96771d044bb177cfa138f83a9c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47200320e4e7753b240dd1c27a872e2a"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a47200320e4e7753b240dd1c27a872e2a">getAngleBetweenVectors</a> (<a class="el" href="classPoint3F.html">VectorF</a> vecA, <a class="el" href="classPoint3F.html">VectorF</a> vecB)</td></tr>
<tr class="memdesc:a47200320e4e7753b240dd1c27a872e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between two given vectors.  <a href="#a47200320e4e7753b240dd1c27a872e2a">More...</a><br /></td></tr>
<tr class="separator:a47200320e4e7753b240dd1c27a872e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d70f8d68205d739d500c033ae81277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a64d70f8d68205d739d500c033ae81277">getAnglesFromVector</a> (const <a class="el" href="classPoint3F.html">VectorF</a> &amp;vec, F32 &amp;yawAng, F32 &amp;pitchAng)</td></tr>
<tr class="memdesc:a64d70f8d68205d739d500c033ae81277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns yaw and pitch angles from a given vector.  <a href="#a64d70f8d68205d739d500c033ae81277">More...</a><br /></td></tr>
<tr class="separator:a64d70f8d68205d739d500c033ae81277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a1452c6905026a655d6a588965c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a7a6a1452c6905026a655d6a588965c8f">getMatrixFromForwardVector</a> (const <a class="el" href="classPoint3F.html">VectorF</a> &amp;forward, <a class="el" href="classMatrixF.html">MatrixF</a> *outMat)</td></tr>
<tr class="memdesc:a7a6a1452c6905026a655d6a588965c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an orthonormal basis matrix with the unit length input vector in column 1 (forward vector).  <a href="#a7a6a1452c6905026a655d6a588965c8f">More...</a><br /></td></tr>
<tr class="separator:a7a6a1452c6905026a655d6a588965c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cec655954009e3be9ea519053645cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a7cec655954009e3be9ea519053645cf3">getMatrixFromUpVector</a> (const <a class="el" href="classPoint3F.html">VectorF</a> &amp;up, <a class="el" href="classMatrixF.html">MatrixF</a> *outMat)</td></tr>
<tr class="memdesc:a7cec655954009e3be9ea519053645cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an orthonormal basis matrix with the unit length input vector in column 2 (up vector).  <a href="#a7cec655954009e3be9ea519053645cf3">More...</a><br /></td></tr>
<tr class="separator:a7cec655954009e3be9ea519053645cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824186c39acfc5d2cd9859e68bf39a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ad824186c39acfc5d2cd9859e68bf39a3">getVectorFromAngles</a> (<a class="el" href="classPoint3F.html">VectorF</a> &amp;vec, F32 yawAng, F32 pitchAng)</td></tr>
<tr class="memdesc:ad824186c39acfc5d2cd9859e68bf39a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector from given yaw and pitch angles.  <a href="#ad824186c39acfc5d2cd9859e68bf39a3">More...</a><br /></td></tr>
<tr class="separator:ad824186c39acfc5d2cd9859e68bf39a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ca3e974ae787c1e5d7b9fba84bfbd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a28ca3e974ae787c1e5d7b9fba84bfbd8">getZBiasProjectionMatrix</a> (F32 bias, const <a class="el" href="classFrustum.html">Frustum</a> &amp;frustum, <a class="el" href="classMatrixF.html">MatrixF</a> *outMat, bool rotate=true)</td></tr>
<tr class="memdesc:a28ca3e974ae787c1e5d7b9fba84bfbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a projection matrix with the near plane moved forward by the bias amount.  <a href="#a28ca3e974ae787c1e5d7b9fba84bfbd8">More...</a><br /></td></tr>
<tr class="separator:a28ca3e974ae787c1e5d7b9fba84bfbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1868a42f377f78fe3d43f509a5621ae8"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a1868a42f377f78fe3d43f509a5621ae8">greatestCommonDivisor</a> (U32 u, U32 v)</td></tr>
<tr class="memdesc:a1868a42f377f78fe3d43f509a5621ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest common divisor of two positive integers.  <a href="#a1868a42f377f78fe3d43f509a5621ae8">More...</a><br /></td></tr>
<tr class="separator:a1868a42f377f78fe3d43f509a5621ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cca7c205482c4d7485c55a2f3a7ce6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a9cca7c205482c4d7485c55a2f3a7ce6d">isConvexPolygon</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *vertices, U32 numVertices)</td></tr>
<tr class="memdesc:a9cca7c205482c4d7485c55a2f3a7ce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether the given polygon is convex.  <a href="#a9cca7c205482c4d7485c55a2f3a7ce6d">More...</a><br /></td></tr>
<tr class="separator:a9cca7c205482c4d7485c55a2f3a7ce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88eeb14df080acf0012f938b26e0b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#aa88eeb14df080acf0012f938b26e0b83">isPlanarPolygon</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *vertices, U32 numVertices)</td></tr>
<tr class="memdesc:aa88eeb14df080acf0012f938b26e0b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out whether the given polygon is planar.  <a href="#aa88eeb14df080acf0012f938b26e0b83">More...</a><br /></td></tr>
<tr class="separator:aa88eeb14df080acf0012f938b26e0b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47b2c01c94d7fe462f682608ce50b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ad47b2c01c94d7fe462f682608ce50b35">makeFovPortFrustum</a> (<a class="el" href="classFrustum.html">Frustum</a> *outFrustum, bool isOrtho, F32 nearDist, F32 farDist, const <a class="el" href="structFovPort.html">FovPort</a> &amp;inPort, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;transform=<a class="el" href="classMatrixF.html">MatrixF</a>(1))</td></tr>
<tr class="separator:ad47b2c01c94d7fe462f682608ce50b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65570815e13b8e2219a117820724ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ae65570815e13b8e2219a117820724ba7">makeFrustum</a> (F32 *outLeft, F32 *outRight, F32 *outTop, F32 *outBottom, F32 fovYInRadians, F32 aspectRatio, F32 nearPlane)</td></tr>
<tr class="memdesc:ae65570815e13b8e2219a117820724ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the frustum near plane dimensions from the parameters.  <a href="#ae65570815e13b8e2219a117820724ba7">More...</a><br /></td></tr>
<tr class="separator:ae65570815e13b8e2219a117820724ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac307a2ceb7d95252dcd726d01c08aaf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ac307a2ceb7d95252dcd726d01c08aaf0">makeOrthoProjection</a> (<a class="el" href="classMatrixF.html">MatrixF</a> *outMatrix, F32 left, F32 right, F32 top, F32 bottom, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="memdesc:ac307a2ceb7d95252dcd726d01c08aaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthographic projection matrix from the frustum near plane dimensions including the optional rotation required by GFX.  <a href="#ac307a2ceb7d95252dcd726d01c08aaf0">More...</a><br /></td></tr>
<tr class="separator:ac307a2ceb7d95252dcd726d01c08aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee85d4ec4970b21d72017ed68d8c0c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#aee85d4ec4970b21d72017ed68d8c0c31">makeProjection</a> (<a class="el" href="classMatrixF.html">MatrixF</a> *outMatrix, F32 fovYInRadians, F32 aspectRatio, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="memdesc:aee85d4ec4970b21d72017ed68d8c0c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a GFX projection matrix from the frustum parameters including the optional rotation required by GFX.  <a href="#aee85d4ec4970b21d72017ed68d8c0c31">More...</a><br /></td></tr>
<tr class="separator:aee85d4ec4970b21d72017ed68d8c0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d99ebbae72f402afddf1ec233ca1c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a62d99ebbae72f402afddf1ec233ca1c9">makeProjection</a> (<a class="el" href="classMatrixF.html">MatrixF</a> *outMatrix, F32 left, F32 right, F32 top, F32 bottom, F32 nearPlane, F32 farPlane, bool gfxRotate)</td></tr>
<tr class="memdesc:a62d99ebbae72f402afddf1ec233ca1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a projection matrix from the frustum near plane dimensions including the optional rotation required by GFX.  <a href="#a62d99ebbae72f402afddf1ec233ca1c9">More...</a><br /></td></tr>
<tr class="separator:a62d99ebbae72f402afddf1ec233ca1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157b973c3d634c9e8ab0c02883383637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a157b973c3d634c9e8ab0c02883383637">mBuildHull2D</a> (const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classPoint2F.html">Point2F</a> &gt; inPoints, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classPoint2F.html">Point2F</a> &gt; &amp;hullPoints)</td></tr>
<tr class="memdesc:a157b973c3d634c9e8ab0c02883383637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a convex hull from a cloud of 2D points, first and last hull point are the same.  <a href="#a157b973c3d634c9e8ab0c02883383637">More...</a><br /></td></tr>
<tr class="separator:a157b973c3d634c9e8ab0c02883383637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ebf9ba8053323cd463d32e393a156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a0a4ebf9ba8053323cd463d32e393a156">mClosestPointOnSegment</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;a, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;b, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p)</td></tr>
<tr class="memdesc:a0a4ebf9ba8053323cd463d32e393a156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest point on the segment defined by points a, b to the point p.  <a href="#a0a4ebf9ba8053323cd463d32e393a156">More...</a><br /></td></tr>
<tr class="separator:a0a4ebf9ba8053323cd463d32e393a156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170dc6863f2efeb40396293c1777fe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a9170dc6863f2efeb40396293c1777fe5">mLineTriangleCollide</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p2, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;t1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;t2, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;t3, <a class="el" href="classPoint3F.html">Point3F</a> *outUVW=NULL, F32 *outT=NULL)</td></tr>
<tr class="memdesc:a9170dc6863f2efeb40396293c1777fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the barycentric coordinates and time of intersection between a line segment and a triangle.  <a href="#a9170dc6863f2efeb40396293c1777fe5">More...</a><br /></td></tr>
<tr class="separator:a9170dc6863f2efeb40396293c1777fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca40c90df7be68daf0a584dabffd29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a0ca40c90df7be68daf0a584dabffd29b">mProjectScreenToWorld</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;in, <a class="el" href="classPoint3F.html">Point3F</a> *out, const <a class="el" href="classRectI.html">RectI</a> &amp;view, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;world, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;projection, F32 far, F32 near)</td></tr>
<tr class="separator:a0ca40c90df7be68daf0a584dabffd29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602a8e076327a242acaa18bee414f4dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a602a8e076327a242acaa18bee414f4dd">mProjectWorldToScreen</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;in, <a class="el" href="classPoint3F.html">Point3F</a> *out, const <a class="el" href="classRectI.html">RectI</a> &amp;view, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;world, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;projection)</td></tr>
<tr class="separator:a602a8e076327a242acaa18bee414f4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6926d24b2e85fcecc7b6bbf37335d4c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a6926d24b2e85fcecc7b6bbf37335d4c3">mProjectWorldToScreen</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;in, <a class="el" href="classPoint3F.html">Point3F</a> *out, const <a class="el" href="classRectI.html">RectI</a> &amp;view, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;worldProjection)</td></tr>
<tr class="separator:a6926d24b2e85fcecc7b6bbf37335d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e2ea61445e7876953574c8861ec0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ad98e2ea61445e7876953574c8861ec0c">mRayQuadCollide</a> (const <a class="el" href="structMathUtils_1_1Quad.html">Quad</a> &amp;quad, const <a class="el" href="namespaceMathUtils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a> &amp;ray, <a class="el" href="classPoint2F.html">Point2F</a> *outUV=NULL, F32 *outT=NULL)</td></tr>
<tr class="memdesc:ad98e2ea61445e7876953574c8861ec0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uv coords and time of intersection between a ray and a quad.  <a href="#ad98e2ea61445e7876953574c8861ec0c">More...</a><br /></td></tr>
<tr class="separator:ad98e2ea61445e7876953574c8861ec0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d265f7766c3421708fb3bb4486c1afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a3d265f7766c3421708fb3bb4486c1afc">mShortestSegmentBetweenLines</a> (const <a class="el" href="structMathUtils_1_1Line.html">Line</a> &amp;line0, const <a class="el" href="structMathUtils_1_1Line.html">Line</a> &amp;line1, <a class="el" href="structMathUtils_1_1LineSegment.html">LineSegment</a> *outSegment)</td></tr>
<tr class="memdesc:a3d265f7766c3421708fb3bb4486c1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the shortest line segment between two lines.  <a href="#a3d265f7766c3421708fb3bb4486c1afc">More...</a><br /></td></tr>
<tr class="separator:a3d265f7766c3421708fb3bb4486c1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a11137f2229ddb8570ef11c0c68d1ab2c">mTriangleDistance</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;a, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;b, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;c, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p, <a class="el" href="structMathUtils_1_1IntersectInfo.html">IntersectInfo</a> *info=NULL)</td></tr>
<tr class="memdesc:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between a point and triangle 'abc'.  <a href="#a11137f2229ddb8570ef11c0c68d1ab2c">More...</a><br /></td></tr>
<tr class="separator:a11137f2229ddb8570ef11c0c68d1ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1bdae12d21c01fa11be3e4bc44895e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a9a1bdae12d21c01fa11be3e4bc44895e">mTriangleNormal</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;a, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;b, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;c)</td></tr>
<tr class="memdesc:a9a1bdae12d21c01fa11be3e4bc44895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal of the passed triangle 'abc'.  <a href="#a9a1bdae12d21c01fa11be3e4bc44895e">More...</a><br /></td></tr>
<tr class="separator:a9a1bdae12d21c01fa11be3e4bc44895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260dc9225e4c1059f0176834f6cbf840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a260dc9225e4c1059f0176834f6cbf840">pointInPolygon</a> (const <a class="el" href="classPoint2F.html">Point2F</a> *verts, U32 vertCount, const <a class="el" href="classPoint2F.html">Point2F</a> &amp;testPt)</td></tr>
<tr class="memdesc:a260dc9225e4c1059f0176834f6cbf840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the test point is within the polygon.  <a href="#a260dc9225e4c1059f0176834f6cbf840">More...</a><br /></td></tr>
<tr class="separator:a260dc9225e4c1059f0176834f6cbf840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07aed72ee17ffb702c21e473e7ab3d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a07aed72ee17ffb702c21e473e7ab3d3f">randomDir</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;axis, F32 thetaAngleMin, F32 thetaAngleMax, F32 phiAngleMin=0.0, F32 phiAngleMax=360.0)</td></tr>
<tr class="memdesc:a07aed72ee17ffb702c21e473e7ab3d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates random direction given angle parameters similar to the particle system.  <a href="#a07aed72ee17ffb702c21e473e7ab3d3f">More...</a><br /></td></tr>
<tr class="separator:a07aed72ee17ffb702c21e473e7ab3d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc627fff58f05ce1beb143ef0b7c5f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint2F.html">Point2F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#abc627fff58f05ce1beb143ef0b7c5f90">randomPointInCircle</a> (F32 radius)</td></tr>
<tr class="memdesc:abc627fff58f05ce1beb143ef0b7c5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random 2D point within a circle of the specified radius centered at the origin.  <a href="#abc627fff58f05ce1beb143ef0b7c5f90">More...</a><br /></td></tr>
<tr class="separator:abc627fff58f05ce1beb143ef0b7c5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191f3093e4a41f12eecf99f69d293752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a191f3093e4a41f12eecf99f69d293752">randomPointInSphere</a> (F32 radius)</td></tr>
<tr class="memdesc:a191f3093e4a41f12eecf99f69d293752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random 3D point within a sphere of the specified radius centered at the origin.  <a href="#a191f3093e4a41f12eecf99f69d293752">More...</a><br /></td></tr>
<tr class="separator:a191f3093e4a41f12eecf99f69d293752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a01616d3939903f96d9f4fc38c74f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a36a01616d3939903f96d9f4fc38c74f8">reduceFrustum</a> (const <a class="el" href="classFrustum.html">Frustum</a> &amp;frustum, const <a class="el" href="classRectI.html">RectI</a> &amp;viewport, const <a class="el" href="classRectF.html">RectF</a> &amp;area, <a class="el" href="classFrustum.html">Frustum</a> &amp;outFrustum)</td></tr>
<tr class="separator:a36a01616d3939903f96d9f4fc38c74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cce22be05e355d56fd4bcee7640060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint3F.html">Point3F</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect</a> (<a class="el" href="classPoint3F.html">Point3F</a> &amp;inVec, <a class="el" href="classPoint3F.html">Point3F</a> &amp;norm)</td></tr>
<tr class="memdesc:ab9cce22be05e355d56fd4bcee7640060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple reflection equation - pass in a vector and a normal to reflect off of.  <a href="#ab9cce22be05e355d56fd4bcee7640060">More...</a><br /></td></tr>
<tr class="separator:ab9cce22be05e355d56fd4bcee7640060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"><td class="memItemLeft" align="right" valign="top">U32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6">removeShortPolygonEdges</a> (const <a class="el" href="classPoint3F.html">Point3F</a> *verts, U32 vertCount, F32 epsilon)</td></tr>
<tr class="memdesc:a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all edges from the given polygon that have a total length shorter than <em>epsilon</em>.  <a href="#a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6">More...</a><br /></td></tr>
<tr class="separator:a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0c7a7814a5e625e6ad48220a81e49"><td class="memItemLeft" align="right" valign="top">F32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a6ce0c7a7814a5e625e6ad48220a81e49">segmentSegmentNearest</a> (const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;q1, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;p2, const <a class="el" href="classPoint3F.html">Point3F</a> &amp;q2, F32 &amp;s, F32 &amp;t, <a class="el" href="classPoint3F.html">Point3F</a> &amp;c1, <a class="el" href="classPoint3F.html">Point3F</a> &amp;c2)</td></tr>
<tr class="memdesc:a6ce0c7a7814a5e625e6ad48220a81e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect two line segments (p1,q1) and (p2,q2), returning points on lines (c1 &amp; c2) and line parameters (s,t).  <a href="#a6ce0c7a7814a5e625e6ad48220a81e49">More...</a><br /></td></tr>
<tr class="separator:a6ce0c7a7814a5e625e6ad48220a81e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65cc13fb2ac1b66d07cdcf92c0cad25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#ae65cc13fb2ac1b66d07cdcf92c0cad25">sortQuadWindingOrder</a> (const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;quadMat, bool clockwise, const <a class="el" href="classPoint3F.html">Point3F</a> *verts, U32 *vertMap, U32 count)</td></tr>
<tr class="memdesc:ae65cc13fb2ac1b66d07cdcf92c0cad25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the passed verts ( <a class="el" href="classPoint3F.html">Point3F</a> ) in a clockwise or counter-clockwise winding order.  <a href="#ae65cc13fb2ac1b66d07cdcf92c0cad25">More...</a><br /></td></tr>
<tr class="separator:ae65cc13fb2ac1b66d07cdcf92c0cad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc1cc9eae809b05afe077a6953acf88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#aebc1cc9eae809b05afe077a6953acf88">sortQuadWindingOrder</a> (bool clockwise, const <a class="el" href="classPoint3F.html">Point3F</a> *verts, U32 *vertMap, U32 count)</td></tr>
<tr class="memdesc:aebc1cc9eae809b05afe077a6953acf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above except we assume that the passed verts ( <a class="el" href="classPoint3F.html">Point3F</a> ) are already transformed into 'quad space'.  <a href="#aebc1cc9eae809b05afe077a6953acf88">More...</a><br /></td></tr>
<tr class="separator:aebc1cc9eae809b05afe077a6953acf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe5544b3534cb6ecee99739850755f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a5fe5544b3534cb6ecee99739850755f4">transformBoundingBox</a> (const <a class="el" href="classBox3F.html">Box3F</a> &amp;sbox, const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;mat, const <a class="el" href="classPoint3F.html">Point3F</a> scale, <a class="el" href="classBox3F.html">Box3F</a> &amp;dbox)</td></tr>
<tr class="memdesc:a5fe5544b3534cb6ecee99739850755f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform bounding box making sure to keep original box entirely contained.  <a href="#a5fe5544b3534cb6ecee99739850755f4">More...</a><br /></td></tr>
<tr class="separator:a5fe5544b3534cb6ecee99739850755f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a3122473cfd09b0860f4cc8e4555bc4fb">vectorRotateZAxis</a> (<a class="el" href="classPoint3F.html">Point3F</a> &amp;vector, F32 radians)</td></tr>
<tr class="memdesc:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the passed vector around the world-z axis by the passed radians.  <a href="#a3122473cfd09b0860f4cc8e4555bc4fb">More...</a><br /></td></tr>
<tr class="separator:a3122473cfd09b0860f4cc8e4555bc4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88453c8514422af6715e8a7d30443eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMathUtils.html#a88453c8514422af6715e8a7d30443eee">vectorRotateZAxis</a> (F32 radians, <a class="el" href="classPoint3F.html">Point3F</a> *vectors, U32 count)</td></tr>
<tr class="separator:a88453c8514422af6715e8a7d30443eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous math utility functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5dd642fe2fdecc388667610dcd26a532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structMathUtils_1_1Line.html">Line</a> <a class="el" href="namespaceMathUtils.html#a5dd642fe2fdecc388667610dcd26a532">MathUtils::Ray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A ray is also a line. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af87ed2416d92fc1f83ea006742c5a58f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::buildMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>fvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WORK IN PROGRESS. </p>
<p>Creates an orthonormal basis matrix from one, two, or three unit length input vectors. If more than one input vector is provided they must be mutually perpendicular.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rvec</td><td>Optional unit length right vector. </td></tr>
    <tr><td class="paramname">fvec</td><td>Optional unit length forward vector. </td></tr>
    <tr><td class="paramname">uvec</td><td>Optional unit length up vector. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional position to initialize the matrix. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ace7fb34fd1f365dd4d46fddab8f7a1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::capsuleCapsuleOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collide two capsules (sphere swept lines) against each other, reporting only if they intersect or not. </p>
<p>Based on routine from "Real Time Collision Detection" by Christer Ericson pp 114. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a7b569dd52dbaa608c9e7954ae5b426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::capsuleSphereNearestOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>A0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a>&#160;</td>
          <td class="paramname"><em>A1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return capsule-sphere overlap. </p>
<p>Returns time of first overlap, where time is viewed as a sphere of radius radA moving from point A0 to A1. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ab113cb6faa0d914457b67c058af3f428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::clipFrustumByPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>inFrustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>rootFrustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>outFrustum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip <em>inFrustum</em> by the given polygon. </p>
<dl class="section note"><dt>Note</dt><dd>The input polygon is limited to 58 vertices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Polygon vertices. </td></tr>
    <tr><td class="paramname">numPoints</td><td>Number of vertices in <em>points</em>. </td></tr>
    <tr><td class="paramname">viewport</td><td>Screen viewport. Note that this corresponds to the root frustum and not necessarily to <em>inFrustum</em>. </td></tr>
    <tr><td class="paramname">world</td><td>World-&gt;view transform. </td></tr>
    <tr><td class="paramname">projection</td><td>Projection matrix. </td></tr>
    <tr><td class="paramname">inFrustum</td><td><a class="el" href="classFrustum.html" title="This class implements a view frustum for use in culling scene objects and rendering the scene...">Frustum</a> to clip. </td></tr>
    <tr><td class="paramname">rootFrustum</td><td><a class="el" href="classFrustum.html" title="This class implements a view frustum for use in culling scene objects and rendering the scene...">Frustum</a> corresponding to <em>viewport</em>. </td></tr>
    <tr><td class="paramname">outFrustum</td><td>Resulting clipped frustum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the frustum was successfully clipped and <em>outFrustum</em> is valid, false otherwise (if, for example, the input polygon is completely outside <em>inFrustum</em>). </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ac389f4ebfe61ab816696f310d6551b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixF.html">MatrixF</a> MathUtils::createOrientFromDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates orientation matrix from a direction vector. Assumes ( 0 0 1 ) is up. </p>

</div>
</div>
<a class="anchor" id="a4c5bb9616837c363e7c71d4456c1bf48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::edgeFaceIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>faceD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the intersection of the line going from <em>edgeA</em> to <em>edgeB</em> with the triangle given by <em>faceA</em>, <em>faceB</em>, and <em>faceC</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeA</td><td>Starting point of edge. </td></tr>
    <tr><td class="paramname">edgeB</td><td>End point of edge. </td></tr>
    <tr><td class="paramname">faceA</td><td>First vertex of triangle. </td></tr>
    <tr><td class="paramname">faceB</td><td>Second vertex of triangle. </td></tr>
    <tr><td class="paramname">faceC</td><td>Third vertex of triangle. </td></tr>
    <tr><td class="paramname">intersection</td><td>If there is an intersection, the point of intersection on the triangle's face is stored here. </td></tr>
    <tr><td class="paramname">True</td><td>if there is an intersection, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1fcc28cca391419f78fac6f7f0c5ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::extrudePolygonEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPlaneF.html">PlaneF</a> *&#160;</td>
          <td class="paramname"><em>outPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrude the given polygon along the given direction. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a4b96771d044bb177cfa138f83a9c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::extrudePolygonEdgesFromPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>fromPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPlaneF.html">PlaneF</a> *&#160;</td>
          <td class="paramname"><em>outPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrude the edges of the given polygon away from <em>fromPoint</em> by constructing a set of planes that each go through <em>fromPoint</em> and a pair of vertices. </p>
<p>The resulting planes are in the same order as the vertices and have their normals facing <em>inwards</em>, i.e. the resulting volume will enclose the polygon's interior space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Vertices of the polygon in CCW or CW order (both are acceptable). </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
    <tr><td class="paramname">fromPoint</td><td></td></tr>
    <tr><td class="paramname">outPlanes</td><td>Array in which the resulting planes are stored. Must have room for at least as many planes are there are edges in the polygon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The input polygon does not necessarily need to be planar but it must be convex. </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a47200320e4e7753b240dd1c27a872e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::getAngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">VectorF</a>&#160;</td>
          <td class="paramname"><em>vecB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the angle between two given vectors. </p>
<p>Angles is in RADIANS </p>

</div>
</div>
<a class="anchor" id="a64d70f8d68205d739d500c033ae81277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getAnglesFromVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>yawAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>pitchAng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns yaw and pitch angles from a given vector. </p>
<p>Angles are in RADIANS.</p>
<p>Assumes north is (0.0, 1.0, 0.0), the degrees move upwards clockwise.</p>
<p>The range of yaw is 0 - 2PI. The range of pitch is -PI/2 - PI/2.</p>
<p><b>ASSUMES Z AXIS IS UP</b> </p>

</div>
</div>
<a class="anchor" id="a7a6a1452c6905026a655d6a588965c8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getMatrixFromForwardVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an orthonormal basis matrix with the unit length input vector in column 1 (forward vector). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forward</td><td>The non-zero unit length forward vector. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cec655954009e3be9ea519053645cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getMatrixFromUpVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an orthonormal basis matrix with the unit length input vector in column 2 (up vector). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">up</td><td>The non-zero unit length up vector. </td></tr>
    <tr><td class="paramname">outMat</td><td>The output matrix which must be initialized prior to the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad824186c39acfc5d2cd9859e68bf39a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getVectorFromAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">VectorF</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>yawAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>pitchAng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector from given yaw and pitch angles. </p>
<p>Angles are in RADIANS.</p>
<p>Assumes north is (0.0, 1.0, 0.0), the degrees move upwards clockwise.</p>
<p>The range of yaw is 0 - 2PI. The range of pitch is -PI/2 - PI/2.</p>
<p><b>ASSUMES Z AXIS IS UP</b> </p>

</div>
</div>
<a class="anchor" id="a28ca3e974ae787c1e5d7b9fba84bfbd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::getZBiasProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a projection matrix with the near plane moved forward by the bias amount. </p>
<p>This function is a helper primarily for working around z-fighting issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bias</td><td>The amount to move the near plane forward. </td></tr>
    <tr><td class="paramname">frustum</td><td>The frustum to generate the new projection matrix from. </td></tr>
    <tr><td class="paramname">outMat</td><td>The resulting z-biased projection matrix. Note: It must be initialized before the call. </td></tr>
    <tr><td class="paramname">rotate</td><td>Optional parameter specifying whether to rotate the projection matrix similarly to <a class="el" href="classGFXDevice.html" title="GFXDevice is the TSE graphics interface layer. ">GFXDevice</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1868a42f377f78fe3d43f509a5621ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::greatestCommonDivisor </td>
          <td>(</td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest common divisor of two positive integers. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a9cca7c205482c4d7485c55a2f3a7ce6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::isConvexPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out whether the given polygon is convex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices of the polygon. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is convex, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="aa88eeb14df080acf0012f938b26e0b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::isPlanarPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>numVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out whether the given polygon is planar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Array of vertices of the polygon. </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in <em>vertices</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the polygon is planar, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ad47b2c01c94d7fe462f682608ce50b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeFovPortFrustum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFrustum.html">Frustum</a> *&#160;</td>
          <td class="paramname"><em>outFrustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOrtho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFovPort.html">FovPort</a> &amp;&#160;</td>
          <td class="paramname"><em>inPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classMatrixF.html">MatrixF</a>(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ae65570815e13b8e2219a117820724ba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeFrustum </td>
          <td>(</td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>fovYInRadians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the frustum near plane dimensions from the parameters. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ac307a2ceb7d95252dcd726d01c08aaf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeOrthoProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthographic projection matrix from the frustum near plane dimensions including the optional rotation required by GFX. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="aee85d4ec4970b21d72017ed68d8c0c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>fovYInRadians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a GFX projection matrix from the frustum parameters including the optional rotation required by GFX. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a62d99ebbae72f402afddf1ec233ca1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::makeProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixF.html">MatrixF</a> *&#160;</td>
          <td class="paramname"><em>outMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gfxRotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a projection matrix from the frustum near plane dimensions including the optional rotation required by GFX. </p>

</div>
</div>
<a class="anchor" id="a157b973c3d634c9e8ab0c02883383637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::mBuildHull2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classPoint2F.html">Point2F</a> &gt;&#160;</td>
          <td class="paramname"><em>inPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classPoint2F.html">Point2F</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hullPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a convex hull from a cloud of 2D points, first and last hull point are the same. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a4ebf9ba8053323cd463d32e393a156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> MathUtils::mClosestPointOnSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest point on the segment defined by points a, b to the point p. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a9170dc6863f2efeb40396293c1777fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mLineTriangleCollide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>outUVW</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outT</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the barycentric coordinates and time of intersection between a line segment and a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first point of the line segment. </td></tr>
    <tr><td class="paramname">p2</td><td>The second point of the line segment. </td></tr>
    <tr><td class="paramname">t1</td><td>The first point of the triangle. </td></tr>
    <tr><td class="paramname">t2</td><td>The second point of the triangle. </td></tr>
    <tr><td class="paramname">t2</td><td>The third point of the triangle. </td></tr>
    <tr><td class="paramname">outUVW</td><td>The optional output barycentric coords. </td></tr>
    <tr><td class="paramname">outT</td><td>The optional output time of intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a collision occurs. </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ca40c90df7be68daf0a584dabffd29b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::mProjectScreenToWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>far</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>near</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a602a8e076327a242acaa18bee414f4dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mProjectWorldToScreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>projection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a6926d24b2e85fcecc7b6bbf37335d4c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mProjectWorldToScreen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>worldProjection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad98e2ea61445e7876953574c8861ec0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::mRayQuadCollide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMathUtils_1_1Quad.html">Quad</a> &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMathUtils.html#a5dd642fe2fdecc388667610dcd26a532">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint2F.html">Point2F</a> *&#160;</td>
          <td class="paramname"><em>outUV</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 *&#160;</td>
          <td class="paramname"><em>outT</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uv coords and time of intersection between a ray and a quad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad</td><td>The quad. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray. </td></tr>
    <tr><td class="paramname">outUV</td><td>The optional output UV coords of the intersection. </td></tr>
    <tr><td class="paramname">outT</td><td>The optional output time of intersection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a collision occurs. </dd></dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d265f7766c3421708fb3bb4486c1afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::mShortestSegmentBetweenLines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMathUtils_1_1Line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>line0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMathUtils_1_1Line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>line1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMathUtils_1_1LineSegment.html">LineSegment</a> *&#160;</td>
          <td class="paramname"><em>outSegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the shortest line segment between two lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outSegment</td><td>The result where .p0 is the point on line0 and .p1 is the point on line1. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a11137f2229ddb8570ef11c0c68d1ab2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::mTriangleDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMathUtils_1_1IntersectInfo.html">IntersectInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance between a point and triangle 'abc'. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a1bdae12d21c01fa11be3e4bc44895e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> MathUtils::mTriangleNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the normal of the passed triangle 'abc'. </p>
<p>If we assume counter-clockwise triangle culling, normal will point out from the 'solid' side of the triangle. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a260dc9225e4c1059f0176834f6cbf840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::pointInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint2F.html">Point2F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint2F.html">Point2F</a> &amp;&#160;</td>
          <td class="paramname"><em>testPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the test point is within the polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verts</td><td>The array of points which forms the polygon. </td></tr>
    <tr><td class="paramname">vertCount</td><td>The number of points in the polygon. </td></tr>
    <tr><td class="paramname">testPt</td><td>The point to test. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a07aed72ee17ffb702c21e473e7ab3d3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> MathUtils::randomDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>thetaAngleMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>thetaAngleMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>phiAngleMin</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>phiAngleMax</em> = <code>360.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates random direction given angle parameters similar to the particle system. </p>
<p>The angles are relative to the specified axis. Both phi and theta are in degrees. </p>

</div>
</div>
<a class="anchor" id="abc627fff58f05ce1beb143ef0b7c5f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint2F.html">Point2F</a> MathUtils::randomPointInCircle </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random 2D point within a circle of the specified radius centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a191f3093e4a41f12eecf99f69d293752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> MathUtils::randomPointInSphere </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random 3D point within a sphere of the specified radius centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a36a01616d3939903f96d9f4fc38c74f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MathUtils::reduceFrustum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectI.html">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectF.html">RectF</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFrustum.html">Frustum</a> &amp;&#160;</td>
          <td class="paramname"><em>outFrustum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9cce22be05e355d56fd4bcee7640060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint3F.html">Point3F</a> MathUtils::reflect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple reflection equation - pass in a vector and a normal to reflect off of. </p>

<p>References <a class="el" href="namespaceMathUtils.html#af87ed2416d92fc1f83ea006742c5a58f">buildMatrix()</a>, <a class="el" href="namespaceMathUtils.html#ace7fb34fd1f365dd4d46fddab8f7a1cf">capsuleCapsuleOverlap()</a>, <a class="el" href="namespaceMathUtils.html#a7a7b569dd52dbaa608c9e7954ae5b426">capsuleSphereNearestOverlap()</a>, <a class="el" href="namespaceMathUtils.html#ab113cb6faa0d914457b67c058af3f428">clipFrustumByPolygon()</a>, <a class="el" href="structMathUtils_1_1Line.html#a3bd4423a5ea74765b4815ac31878c4e8">MathUtils::Line::direction</a>, <a class="el" href="namespaceMathUtils.html#a4c5bb9616837c363e7c71d4456c1bf48">edgeFaceIntersect()</a>, <a class="el" href="namespaceMathUtils.html#ae1fcc28cca391419f78fac6f7f0c5ccb">extrudePolygonEdges()</a>, <a class="el" href="namespaceMathUtils.html#a7a4b96771d044bb177cfa138f83a9c42">extrudePolygonEdgesFromPoint()</a>, <a class="el" href="namespaceMathUtils.html#a1868a42f377f78fe3d43f509a5621ae8">greatestCommonDivisor()</a>, <a class="el" href="namespaceMathUtils.html#a9cca7c205482c4d7485c55a2f3a7ce6d">isConvexPolygon()</a>, <a class="el" href="namespaceMathUtils.html#aa88eeb14df080acf0012f938b26e0b83">isPlanarPolygon()</a>, <a class="el" href="namespaceMathUtils.html#ad47b2c01c94d7fe462f682608ce50b35">makeFovPortFrustum()</a>, <a class="el" href="namespaceMathUtils.html#ae65570815e13b8e2219a117820724ba7">makeFrustum()</a>, <a class="el" href="namespaceMathUtils.html#ac307a2ceb7d95252dcd726d01c08aaf0">makeOrthoProjection()</a>, <a class="el" href="namespaceMathUtils.html#aee85d4ec4970b21d72017ed68d8c0c31">makeProjection()</a>, <a class="el" href="namespaceMathUtils.html#a157b973c3d634c9e8ab0c02883383637">mBuildHull2D()</a>, <a class="el" href="namespaceMathUtils.html#a0a4ebf9ba8053323cd463d32e393a156">mClosestPointOnSegment()</a>, <a class="el" href="namespaceMathUtils.html#a9170dc6863f2efeb40396293c1777fe5">mLineTriangleCollide()</a>, <a class="el" href="namespaceMathUtils.html#a0ca40c90df7be68daf0a584dabffd29b">mProjectScreenToWorld()</a>, <a class="el" href="namespaceMathUtils.html#a602a8e076327a242acaa18bee414f4dd">mProjectWorldToScreen()</a>, <a class="el" href="namespaceMathUtils.html#ad98e2ea61445e7876953574c8861ec0c">mRayQuadCollide()</a>, <a class="el" href="namespaceMathUtils.html#a3d265f7766c3421708fb3bb4486c1afc">mShortestSegmentBetweenLines()</a>, <a class="el" href="namespaceMathUtils.html#a11137f2229ddb8570ef11c0c68d1ab2c">mTriangleDistance()</a>, <a class="el" href="namespaceMathUtils.html#a9a1bdae12d21c01fa11be3e4bc44895e">mTriangleNormal()</a>, <a class="el" href="namespaceMathUtils.html#a260dc9225e4c1059f0176834f6cbf840">pointInPolygon()</a>, <a class="el" href="namespaceMathUtils.html#a36a01616d3939903f96d9f4fc38c74f8">reduceFrustum()</a>, <a class="el" href="namespaceMathUtils.html#a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6">removeShortPolygonEdges()</a>, <a class="el" href="namespaceMathUtils.html#a6ce0c7a7814a5e625e6ad48220a81e49">segmentSegmentNearest()</a>, <a class="el" href="namespaceMathUtils.html#ae65cc13fb2ac1b66d07cdcf92c0cad25">sortQuadWindingOrder()</a>, and <a class="el" href="namespaceMathUtils.html#a5fe5544b3534cb6ecee99739850755f4">transformBoundingBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a57f0ec9a02a3ba4e9ca6e5cbbdedcaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U32 MathUtils::removeShortPolygonEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>vertCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all edges from the given polygon that have a total length shorter than <em>epsilon</em>. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ce0c7a7814a5e625e6ad48220a81e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F32 MathUtils::segmentSegmentNearest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32 &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect two line segments (p1,q1) and (p2,q2), returning points on lines (c1 &amp; c2) and line parameters (s,t). </p>
<p>Based on routine from "Real Time Collision Detection" by Christer Ericson pp 149. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="ae65cc13fb2ac1b66d07cdcf92c0cad25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::sortQuadWindingOrder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>quadMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clockwise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>vertMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the passed verts ( <a class="el" href="classPoint3F.html">Point3F</a> ) in a clockwise or counter-clockwise winding order. </p>
<p>Verts must be co-planar and non-collinear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadMat</td><td>Transform matrix from vert space to quad space. </td></tr>
    <tr><td class="paramname">clockwise</td><td>Sort clockwise or counter-clockwise </td></tr>
    <tr><td class="paramname">verts</td><td>Array of <a class="el" href="classPoint3F.html">Point3F</a> verts. </td></tr>
    <tr><td class="paramname">vertMap</td><td>Output - Array of vert element ids sorted by winding order. </td></tr>
    <tr><td class="paramname">count</td><td>Element count of the verts and vertMap arrays which must be allocated prior to this call. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="aebc1cc9eae809b05afe077a6953acf88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::sortQuadWindingOrder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clockwise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32 *&#160;</td>
          <td class="paramname"><em>vertMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above except we assume that the passed verts ( <a class="el" href="classPoint3F.html">Point3F</a> ) are already transformed into 'quad space'. </p>
<p>If this was done correctly and the points are coplanar this means their z components will all be zero. </p>

</div>
</div>
<a class="anchor" id="a5fe5544b3534cb6ecee99739850755f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::transformBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBox3F.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>sbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixF.html">MatrixF</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint3F.html">Point3F</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBox3F.html">Box3F</a> &amp;&#160;</td>
          <td class="paramname"><em>dbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform bounding box making sure to keep original box entirely contained. </p>

<p>Referenced by <a class="el" href="namespaceMathUtils.html#ab9cce22be05e355d56fd4bcee7640060">reflect()</a>.</p>

</div>
</div>
<a class="anchor" id="a3122473cfd09b0860f4cc8e4555bc4fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::vectorRotateZAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the passed vector around the world-z axis by the passed radians. </p>

</div>
</div>
<a class="anchor" id="a88453c8514422af6715e8a7d30443eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MathUtils::vectorRotateZAxis </td>
          <td>(</td>
          <td class="paramtype">F32&#160;</td>
          <td class="paramname"><em>radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint3F.html">Point3F</a> *&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->

<!-- START FOOTER -->
<br>
<br>
<center>
	<div style="color: #777777;">
	Copyright &copy; <a style="color: #777777;" target="_blank" href="http://www.garagegames.com">GarageGames, LLC</a>. All Rights Reserved.
	</div>
</center>
</body>
</html>
